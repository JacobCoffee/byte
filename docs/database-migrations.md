# Database Migrations

This document describes how to work with database migrations in the Byte Bot project after the microservices migration.

## Overview

Database migrations are managed using [Alembic](https://alembic.sqlalchemy.org/) through
[Advanced Alchemy](https://docs.advanced-alchemy.litestar.dev/), which provides async-aware migration support integrated
with SQLAlchemy 2.0.

## Location

- **Migration files**: `services/api/src/byte_api/lib/db/migrations/versions/`
- **Alembic config**: `services/api/src/byte_api/lib/db/alembic.ini`
- **Environment**: `services/api/src/byte_api/lib/db/migrations/env.py`

## Migration History

The project contains the following migrations (in order):

1. **initial.py** (`43165a559e89`) - Initial schema with guild, user, GitHub, and SO tags configuration
2. **002_simplify_models.py** (`feebdacfdd91`) - Simplified model structure, consolidated configuration tables
3. **003_forum_models.py** (`73a26ceab2c4`) - Added forum configuration support
4. **004_snowflake_fixes.py** (`f32ee278015d`) - Fixed Discord snowflake ID handling and foreign key relationships

## Running Migrations

### Prerequisites

1. PostgreSQL database running (use docker-compose):

   ```bash
   docker compose -f docker-compose.infra.yml up -d db
   ```

2. Environment variables configured (create `.env` from `.env.example`):
   ```bash
   DB_URL=postgresql+asyncpg://byte:bot@localhost:5432/byte
   ```

### Upgrade to Latest

To apply all pending migrations:

```python
from advanced_alchemy.alembic.commands import AlembicCommands
from byte_api.lib.db.base import config

cmds = AlembicCommands(sqlalchemy_config=config)
cmds.upgrade()
```

Or from shell:

```bash
uv run python -c "
from advanced_alchemy.alembic.commands import AlembicCommands
from byte_api.lib.db.base import config

AlembicCommands(sqlalchemy_config=config).upgrade()
"
```

### Check Current Version

```python
from advanced_alchemy.alembic.commands import AlembicCommands
from byte_api.lib.db.base import config

cmds = AlembicCommands(sqlalchemy_config=config)
cmds.current()
```

### Downgrade

To rollback one migration:

```python
from advanced_alchemy.alembic.commands import AlembicCommands
from byte_api.lib.db.base import config

cmds = AlembicCommands(sqlalchemy_config=config)
cmds.downgrade(revision="-1")
```

To rollback to a specific version:

```python
cmds.downgrade(revision="<revision_id>")
```

## Creating New Migrations

### Auto-generate from Model Changes

When you modify models in `byte-common/src/byte_common/models.py`:

```python
from advanced_alchemy.alembic.commands import AlembicCommands
from byte_api.lib.db.base import config

cmds = AlembicCommands(sqlalchemy_config=config)
cmds.revision(message="description of changes", autogenerate=True)
```

### Manual Migration

For data migrations or complex schema changes:

```python
cmds.revision(message="description of changes", autogenerate=False)
```

Then edit the generated file in `services/api/src/byte_api/lib/db/migrations/versions/`.

## Migration File Structure

Each migration file follows this pattern:

```python
# type: ignore
"""Revision ID: <id>
Revises: <parent_id>
Create Date: <timestamp>
"""

from __future__ import annotations

import warnings
import sqlalchemy as sa
from advanced_alchemy.types import GUID, ORA_JSONB, DateTimeUTC
from alembic import op

# revision identifiers, used by Alembic
revision = "<id>"
down_revision = "<parent_id>"
branch_labels = None
depends_on = None


def upgrade() -> None:
    with warnings.catch_warnings():
        warnings.filterwarnings("ignore", category=UserWarning)
        with op.get_context().autocommit_block():
            schema_upgrades()
            data_upgrades()


def downgrade() -> None:
    with warnings.catch_warnings():
        warnings.filterwarnings("ignore", category=UserWarning)
        with op.get_context().autocommit_block():
            data_downgrades()
            schema_downgrades()


def schema_upgrades() -> None:
    """Schema upgrade migrations go here."""
    # ### commands auto generated by Alembic ###
    pass


def schema_downgrades() -> None:
    """Schema downgrade migrations go here."""
    # ### commands auto generated by Alembic ###
    pass


def data_upgrades() -> None:
    """Add any optional data upgrade migrations here!"""
    pass


def data_downgrades() -> None:
    """Add any optional data downgrade migrations here!"""
    pass
```

## Configuration

### Alembic.ini

The Alembic configuration uses `%(here)s` to resolve paths relative to the config file location:

```ini
[alembic]
prepend_sys_path = .
script_location = %(here)s/migrations
file_template = %%(year)d-%%(month).2d-%%(day).2d_%%(slug)s_%%(rev)s
timezone = UTC
truncate_slug_length = 40
```

### Database Settings

Migration paths are configured in `services/api/src/byte_api/lib/settings.py`:

```python
class DatabaseSettings(BaseSettings):
    MIGRATION_CONFIG: str = f"{BASE_DIR}/lib/db/alembic.ini"
    MIGRATION_PATH: str = f"{BASE_DIR}/lib/db/migrations"
    MIGRATION_DDL_VERSION_TABLE: str = "ddl_version"
```

## Model Location

All database models are defined in the `byte-common` package:

- **Location**: `packages/byte-common/src/byte_common/models.py`
- **Import**: `from byte_common.models import Guild, User, GitHubConfig, etc.`

This allows models to be shared between the API service and bot service.

## Troubleshooting

### "Path doesn't exist" Error

If you see this error when running alembic commands directly, it's because alembic.ini uses relative paths. Use the
Python API shown above instead.

### "Cannot import name 'get_settings'"

Use `load_settings()` instead, which returns a tuple of settings objects.

### Database Connection Refused

Ensure PostgreSQL is running:

```bash
docker compose -f docker-compose.infra.yml ps
```

### Import Errors for Models

Ensure you're importing from `byte_common.models`, not the old `byte_bot.server.domain.db.models` path.

## Production Deployment

On Railway, migrations are automatically applied before the service starts via the start command:

```bash
uv run app database upgrade --no-prompt && uv run app run-all ...
```

Note: The `app` CLI is currently only available in the monolithic setup. For microservices, migrations should be run
programmatically as shown above or through a dedicated migration service.

## Rollback Plan

In case of migration issues:

1. **Identify the problem revision**:

   ```python
   cmds.current()  # Shows current version
   ```

2. **Downgrade to previous stable version**:

   ```python
   cmds.downgrade(revision="<previous_revision_id>")
   ```

3. **For complete rollback**:

   ```python
   cmds.downgrade(revision="base")  # WARNING: Drops all tables
   ```

4. **Re-apply migrations after fixes**:
   ```python
   cmds.upgrade()
   ```

## Best Practices

1. **Always test migrations locally** before deploying to production
2. **Use transactions** - Alembic automatically wraps migrations in transactions
3. **Backup production data** before running migrations
4. **Write reversible migrations** - Always implement both `upgrade()` and `downgrade()`
5. **Test rollback** - Verify that downgrade works as expected
6. **Document data migrations** - Add comments explaining complex transformations
7. **Avoid destructive changes** - Use separate migrations for adding and dropping columns
8. **Keep migrations small** - One logical change per migration file

## References

- [Alembic Documentation](https://alembic.sqlalchemy.org/)
- [Advanced Alchemy Migrations](https://docs.advanced-alchemy.litestar.dev/usage/migrations.html)
- [SQLAlchemy 2.0 Documentation](https://docs.sqlalchemy.org/)
