<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <title>typing - Docs</title>
    <link rel="index" title="Index" href="../genindex.html" /><link rel="search" title="Search" href="../search.html" />
  <script>
    const isDarkTheme = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
    const sessionTheme = sessionStorage['_theme']
    if (sessionTheme) {
      document.documentElement.classList.add(sessionTheme)
    } else if (isDarkTheme) {
      document.documentElement.classList.add('dark')
    }
  </script><link rel="shortcut icon" href="../_static/badge.svg"/><link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=aecf457f" />
    <link rel="stylesheet" type="text/css" href="../_static/shibuya.css?v=28c32440" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="../_static/autodoc_pydantic.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-design.min.css?v=95c83b7e" />
    <link media="print" rel="stylesheet" type="text/css" href="../_static/print.css?v=ee381b95" />
    <link rel="stylesheet" type="text/css" href="../_static/custom.css?v=80d31e7b" />
    <style>
:root {
  --sy-f-sys:-apple-system, BlinkMacSystemFont, Segoe UI, Oxygen, Ubuntu, Droid Sans, Helvetica Neue;--sy-f-cjk:PingFang SC, Hiragino Sans GB, Droid Sans Fallback, Microsoft YaHei;--sy-f-heading:var(--sy-f-sys), var(--sy-f-cjk), sans-serif;--sy-f-text:var(--sy-f-sys), var(--sy-f-cjk), sans-serif;--sy-f-mono:Menlo, Monaco, Consolas, "Courier New", monospace;--sy-c-divider:rgba(var(--sy-rc-text), 0.1);--sy-c-divider-weak:rgba(var(--sy-rc-text), 0.05);--sy-c-border:rgba(var(--sy-rc-text), 0.14);--sy-s-banner-height:0rem;--sy-s-navbar-height:56px;--sy-s-offset-top:calc(var(--sy-s-navbar-height) + var(--sy-s-banner-height));--sy-c-link:rgb(var(--sy-rc-theme));--sy-c-link-weak:rgba(var(--sy-rc-theme), 0.86);
  --sy-rc-theme:66, 177, 168;--sy-rc-bg:255, 255, 255;--sy-rc-invert:66, 177, 168;--sy-rc-text:66, 177, 168;--sy-c-bg:#fff;--sy-c-bg-weak:12, 12, 12;--sy-c-text:#0C0C0C;--sy-c-text-weak:#42B1A8;--sy-c-heading:#42B1A8;--sy-c-bold:#42B1A8;--sy-c-foot-text:#0C0C0C;--sy-c-foot-bg:#fafafa;--sy-c-foot-divider:#42B1A8;
}
@media (prefers-color-scheme: light) {
  :root {
    --sy-rc-theme:66, 177, 168;--sy-rc-bg:255, 255, 255;--sy-rc-invert:66, 177, 168;--sy-rc-text:66, 177, 168;--sy-c-bg:#fff;--sy-c-bg-weak:12, 12, 12;--sy-c-text:#0C0C0C;--sy-c-text-weak:#42B1A8;--sy-c-heading:#42B1A8;--sy-c-bold:#42B1A8;--sy-c-foot-text:#0C0C0C;--sy-c-foot-bg:#fafafa;--sy-c-foot-divider:#42B1A8;
  }
}
@media (prefers-color-scheme: dark) {
  :root {
    --sy-rc-theme:66, 177, 168;--sy-rc-bg:12, 12, 12;--sy-rc-invert:66, 177, 168;--sy-rc-text:66, 177, 168;--sy-c-bg:#42B1A8;--sy-c-bg-weak:#0C0C0C;--sy-c-text:#EBEBE9;--sy-c-text-weak:#42B1A8;--sy-c-heading:#42B1A8;--sy-c-bold:#42B1A8;--sy-c-foot-text:#EBEBE9;--sy-c-foot-bg:#0C0C0C;--sy-c-foot-divider:#42B1A8;
  }
}
html.light {
  --sy-rc-theme:66, 177, 168;--sy-rc-bg:255, 255, 255;--sy-rc-invert:66, 177, 168;--sy-rc-text:66, 177, 168;--sy-c-bg:#fff;--sy-c-bg-weak:12, 12, 12;--sy-c-text:#0C0C0C;--sy-c-text-weak:#42B1A8;--sy-c-heading:#42B1A8;--sy-c-bold:#42B1A8;--sy-c-foot-text:#0C0C0C;--sy-c-foot-bg:#fafafa;--sy-c-foot-divider:#42B1A8;
}
html.dark {
  --sy-rc-theme:66, 177, 168;--sy-rc-bg:12, 12, 12;--sy-rc-invert:66, 177, 168;--sy-rc-text:66, 177, 168;--sy-c-bg:#42B1A8;--sy-c-bg-weak:#0C0C0C;--sy-c-text:#EBEBE9;--sy-c-text-weak:#42B1A8;--sy-c-heading:#42B1A8;--sy-c-bold:#42B1A8;--sy-c-foot-text:#EBEBE9;--sy-c-foot-bg:#0C0C0C;--sy-c-foot-divider:#42B1A8;
}
</style>
    <link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@500;600;700&display=swap" rel="stylesheet">
<style>
:root {
  --sy-f-heading: Inter, var(--sy-f-sys), var(--sy-f-cjk), sans-serif;
}
</style>
    <meta property="og:type" content="website"/><meta property="og:title" content="typing"/>
<meta name="twitter:card" content="summary"/></head>
<body><div class="document"><div class="announcement">
    <div class="announcement-inner">
      <p>This documentation is currently under development.</p>
      <button class="announcement-close" aria-label="Close announcement">
        <i class="i-icon close"></i>
      </button>
    </div>
  </div><div class="sy-head">
  <div class="sy-head-blur"></div>
  <div class="sy-head-inner sy-container mx-auto">
    <a class="sy-head-brand mr-4" href="/">
      <img class="light-logo" src="../_static/badge.svg" alt="byte-bot" height="28" />
      <img class="dark-logo" src="../_static/badge.svg" alt="byte-bot" height="28" />
      <strong>byte-bot</strong>
    </a>
    <div class="sy-head-links" id="NavLinks">
      <nav class="sy-head-nav">

<ul><li class="link">
          <a href="https://byte-bot.app/"><span>Dashboard</span><i class="i-icon external-link"></i></a>
        </li><li class="link">
          <a href="https://github.com/sponsors/JacobCoffee"><span>Sponsor me</span><i class="i-icon external-link"></i></a>
        </li></ul></nav>
      <div class="sy-head-extra flex items-center print:hidden"><form class="searchbox flex items-center" action="../search.html" method="get">
  <input type="text" name="q" placeholder="Search" />
  <kbd>/</kbd>
</form>
        
        
        <div class="sy-head-social flex items-center">
            <a class="flex items-center" href="https://github.com/JacobCoffee/byte-bot" aria-label="GitHub">
              <i class="i-icon github"></i>
            </a>
            <a class="flex items-center" href="https://discord.gg/ZVG8hN6RrJ/" aria-label="Discord">
              <i class="i-icon discord"></i>
            </a>
        </div>
      </div>
    </div>
    <div class="sy-head-actions flex items-center shrink-0 print:hidden">
      <button class="js-theme theme-switch flex items-center" data-aria-light="Switch to dark mode" data-aria-dark="Switch to light mode">
        <i class="i-icon theme-icon"></i>
      </button>
      <button class="md:hidden flex items-center js-menu" aria-label="Menu" type="button" aria-controls="NavLinks" aria-expanded="false">
        <div class="hamburger">
          <span class="hamburger_1"></span>
          <span class="hamburger_2 -translate-x-2"></span>
          <span class="hamburger_3 -translate-x-1"></span>
        </div>
      </button>
    </div>
  </div>
</div>
<div class="sy-page sy-container flex mx-auto">
  <aside id="lside" class="sy-lside md:w-72 md:shrink-0 print:hidden">
    <div class="sy-lside-inner md:sticky">
      <div class="sy-scrollbar p-6">
        <div class="globaltoc" data-expand-depth="0"><p class="caption" role="heading"><span class="caption-text">Byte Docs</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../byte/usage/index.html">Usage</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../byte/usage/byte.html">About Byte</a></li>
<li class="toctree-l2"><a class="reference internal" href="../byte/usage/starting.html">Starting Byte</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../byte/api/index.html">API Reference</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../byte/api/bot.html">bot</a></li>
<li class="toctree-l2"><a class="reference internal" href="../byte/api/plugins/index.html">plugins</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../byte/api/plugins/admin.html">admin</a></li>
<li class="toctree-l3"><a class="reference internal" href="../byte/api/plugins/astral.html">astral</a></li>
<li class="toctree-l3"><a class="reference internal" href="../byte/api/plugins/events.html">events</a></li>
<li class="toctree-l3"><a class="reference internal" href="../byte/api/plugins/general.html">general</a></li>
<li class="toctree-l3"><a class="reference internal" href="../byte/api/plugins/github.html">github</a></li>
<li class="toctree-l3"><a class="reference internal" href="../byte/api/plugins/testing.html">testing</a></li>
<li class="toctree-l3"><a class="reference internal" href="../byte/api/plugins/python.html">python</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../byte/api/views/index.html">views</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../byte/api/views/forums.html">forums</a></li>
<li class="toctree-l3"><a class="reference internal" href="../byte/api/views/astral.html">astral</a></li>
<li class="toctree-l3"><a class="reference internal" href="../byte/api/views/python.html">python</a></li>
<li class="toctree-l3"><a class="reference internal" href="../byte/api/views/abstract.html">abstract</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../byte/api/lib/index.html">lib</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../byte/api/lib/common.html">common</a></li>
<li class="toctree-l3"><a class="reference internal" href="../byte/api/lib/logging.html">logging</a></li>
<li class="toctree-l3"><a class="reference internal" href="../byte/api/lib/settings.html">settings</a></li>
<li class="toctree-l3"><a class="reference internal" href="../byte/api/lib/utils.html">utils</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Web Docs</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../web/usage/index.html">Usage</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../web/usage/server.html">About the Server</a></li>
<li class="toctree-l2"><a class="reference internal" href="../web/usage/starting.html">Starting Server</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../web/api/index.html">API Reference</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../web/api/app.html">app</a></li>
<li class="toctree-l2"><a class="reference internal" href="../web/api/cli.html">cli</a></li>
<li class="toctree-l2"><a class="reference internal" href="../web/api/metadata.html">metadata</a></li>
<li class="toctree-l2"><a class="reference internal" href="../web/api/utils.html">utils</a></li>
<li class="toctree-l2"><a class="reference internal" href="../web/api/domain/index.html">domain</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../web/api/domain/init.html">Domain Initializer</a></li>
<li class="toctree-l3"><a class="reference internal" href="../web/api/domain/urls.html">urls</a></li>
<li class="toctree-l3"><a class="reference internal" href="../web/api/domain/system/index.html">system</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../web/api/domain/system/controllers.html">controllers</a></li>
<li class="toctree-l4"><a class="reference internal" href="../web/api/domain/system/dtos.html">dtos</a></li>
<li class="toctree-l4"><a class="reference internal" href="../web/api/domain/system/helpers.html">helpers</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../web/api/domain/guilds/index.html">guilds</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../web/api/domain/guilds/controllers.html">controllers</a></li>
<li class="toctree-l4"><a class="reference internal" href="../web/api/domain/guilds/dependencies.html">dependencies</a></li>
<li class="toctree-l4"><a class="reference internal" href="../web/api/domain/guilds/helpers.html">helpers</a></li>
<li class="toctree-l4"><a class="reference internal" href="../web/api/domain/guilds/schemas.html">schemas</a></li>
<li class="toctree-l4"><a class="reference internal" href="../web/api/domain/guilds/services.html">services</a></li>
<li class="toctree-l4"><a class="reference internal" href="../web/api/domain/guilds/urls.html">urls</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../web/api/domain/github/index.html">github</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../web/api/domain/github/helpers.html">helpers</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../web/api/domain/web/index.html">web</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../web/api/domain/web/controllers.html">controllers</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../web/api/domain/db/index.html">Database</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../web/api/domain/db/models.html">models</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../web/api/lib/index.html">lib</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../web/api/lib/constants.html">constants</a></li>
<li class="toctree-l3"><a class="reference internal" href="../web/api/lib/cors.html">cors</a></li>
<li class="toctree-l3"><a class="reference internal" href="../web/api/lib/dependencies.html">dependencies</a></li>
<li class="toctree-l3"><a class="reference internal" href="../web/api/lib/dtos.html">dtos</a></li>
<li class="toctree-l3"><a class="reference internal" href="../web/api/lib/exceptions.html">exceptions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../web/api/lib/openapi.html">openapi</a></li>
<li class="toctree-l3"><a class="reference internal" href="../web/api/lib/schema.html">schema</a></li>
<li class="toctree-l3"><a class="reference internal" href="../web/api/lib/serialization.html">serialization</a></li>
<li class="toctree-l3"><a class="reference internal" href="../web/api/lib/settings.html">settings</a></li>
<li class="toctree-l3"><a class="reference internal" href="../web/api/lib/static_files.html">static files</a></li>
<li class="toctree-l3"><a class="reference internal" href="../web/api/lib/types.html">types</a></li>
<li class="toctree-l3"><a class="reference internal" href="../web/api/lib/template.html">template</a></li>
<li class="toctree-l3"><a class="reference internal" href="../web/api/lib/log/index.html">logging</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../web/api/lib/log/controller.html">controller</a></li>
<li class="toctree-l4"><a class="reference internal" href="../web/api/lib/log/init.html">init</a></li>
<li class="toctree-l4"><a class="reference internal" href="../web/api/lib/log/utils.html">utils</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../web/api/lib/db/index.html">Database Library</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../web/api/lib/db/base.html">base</a></li>
<li class="toctree-l4"><a class="reference internal" href="../web/api/lib/db/orm.html">orm</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Development</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../contribution-guide.html">Contribution guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../changelog.html">Changelog</a></li>
</ul>

        </div>
      </div>
      
    </div>
  </aside>
  <div class="lside-overlay js-menu" role="button" aria-label="Close left sidebar" aria-controls="lside" aria-expanded="false"></div>
  <aside id="rside" class="sy-rside pb-3 w-64 shrink-0 order-last">
    <button class="rside-close js-menu xl:hidden" aria-label="Close Table of Contents" type="button" aria-controls="rside" aria-expanded="false">
      <i class="i-icon close"></i>
    </button>
    <div class="sy-scrollbar sy-rside-inner px-6 xl:top-16 xl:sticky xl:pl-0 pt-6 pb-4"><a class="js-repo-stats repo-stats flex items-center" href="https://github.com/JacobCoffee/byte"
  data-type="github" data-user="JacobCoffee" data-repo="byte">
  <span class="w-8 flex items-center justify-around shrink-0 text-2xl">
    <i class="i-icon github"></i>
  </span>
  <span class="flex-grow px-2">
    <span>JacobCoffee/byte</span>
    <span class="flex text-sm repo-stats-count">
      <span class="flex items-center pr-3">
        <i class="i-icon star"></i>
        <strong class="js-repo-stars ml-1">0</strong>
      </span>
      <span class="flex items-center">
        <i class="i-icon git-fork"></i>
        <strong class="js-repo-forks ml-1">0</strong>
      </span>
    </span>
  </span>
</a><div id="ethical-ad-placement" data-ea-publisher="readthedocs"></div>
    </div>
  </aside>
  <div class="rside-overlay js-menu" role="button" aria-label="Close Table of Contents" aria-controls="rside" aria-expanded="false"></div>
  <main class="sy-main w-full max-sm:max-w-full print:pt-6">
    <div class="sy-breadcrumbs" role="navigation">
  <div class="sy-breadcrumbs-inner flex items-center">
    <div class="md:hidden mr-3">
      <button class="js-menu" aria-label="Menu" type="button" aria-controls="lside" aria-expanded="false">
        <i class="i-icon menu"></i>
      </button>
    </div>
    <ul class="flex-1">
      
      
      <li><a href="../index.html">byte-bot</a><span>/</span></li>
      
      <li><a href="index.html">Module code</a><span>/</span></li>
      
      <li><strong>typing</strong></li>
      
      
    </ul>
    <div class="xl:hidden ml-1">
      <button class="js-menu" aria-label="Show table of contents" type="button" aria-controls="rside"
        aria-expanded="false">
        <i class="i-icon outdent"></i>
      </button>
    </div>
  </div>
</div>
    <div class="flex flex-col break-words justify-between">
      <div class="min-w-0 max-w-6xl px-6 pb-6 pt-8 xl:px-12">
        <article class="yue" role="main">
          <h1>Source code for typing</h1><div class="highlight"><pre>
<span></span><span id="1-1"><span class="sd">&quot;&quot;&quot;</span>
</span><span id="1-2"><span class="sd">The typing module: Support for gradual typing as defined by PEP 484 and subsequent PEPs.</span>
</span><span id="1-3">
</span><span id="1-4"><span class="sd">Among other things, the module includes the following:</span>
</span><span id="1-5"><span class="sd">* Generic, Protocol, and internal machinery to support generic aliases.</span>
</span><span id="1-6"><span class="sd">  All subscripted types like X[int], Union[int, str] are generic aliases.</span>
</span><span id="1-7"><span class="sd">* Various &quot;special forms&quot; that have unique meanings in type annotations:</span>
</span><span id="1-8"><span class="sd">  NoReturn, Never, ClassVar, Self, Concatenate, Unpack, and others.</span>
</span><span id="1-9"><span class="sd">* Classes whose instances can be type arguments to generic classes and functions:</span>
</span><span id="1-10"><span class="sd">  TypeVar, ParamSpec, TypeVarTuple.</span>
</span><span id="1-11"><span class="sd">* Public helper functions: get_type_hints, overload, cast, final, and others.</span>
</span><span id="1-12"><span class="sd">* Several protocols to support duck-typing:</span>
</span><span id="1-13"><span class="sd">  SupportsFloat, SupportsIndex, SupportsAbs, and others.</span>
</span><span id="1-14"><span class="sd">* Special types: NewType, NamedTuple, TypedDict.</span>
</span><span id="1-15"><span class="sd">* Deprecated wrapper submodules for re and io related types.</span>
</span><span id="1-16"><span class="sd">* Deprecated aliases for builtin types and collections.abc ABCs.</span>
</span><span id="1-17">
</span><span id="1-18"><span class="sd">Any name not present in __all__ is an implementation detail</span>
</span><span id="1-19"><span class="sd">that may be changed without notice. Use at your own risk!</span>
</span><span id="1-20"><span class="sd">&quot;&quot;&quot;</span>
</span><span id="1-21">
</span><span id="1-22"><span class="kn">from</span><span class="w"> </span><span class="nn">abc</span><span class="w"> </span><span class="kn">import</span> <span class="n">abstractmethod</span><span class="p">,</span> <span class="n">ABCMeta</span>
</span><span id="1-23"><span class="kn">import</span><span class="w"> </span><span class="nn">collections</span>
</span><span id="1-24"><span class="kn">from</span><span class="w"> </span><span class="nn">collections</span><span class="w"> </span><span class="kn">import</span> <span class="n">defaultdict</span>
</span><span id="1-25"><span class="kn">import</span><span class="w"> </span><span class="nn">collections.abc</span>
</span><span id="1-26"><span class="kn">import</span><span class="w"> </span><span class="nn">copyreg</span>
</span><span id="1-27"><span class="kn">import</span><span class="w"> </span><span class="nn">contextlib</span>
</span><span id="1-28"><span class="kn">import</span><span class="w"> </span><span class="nn">functools</span>
</span><span id="1-29"><span class="kn">import</span><span class="w"> </span><span class="nn">operator</span>
</span><span id="1-30"><span class="kn">import</span><span class="w"> </span><span class="nn">re</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">stdlib_re</span>  <span class="c1"># Avoid confusion with the re we export.</span>
</span><span id="1-31"><span class="kn">import</span><span class="w"> </span><span class="nn">sys</span>
</span><span id="1-32"><span class="kn">import</span><span class="w"> </span><span class="nn">types</span>
</span><span id="1-33"><span class="kn">import</span><span class="w"> </span><span class="nn">warnings</span>
</span><span id="1-34"><span class="kn">from</span><span class="w"> </span><span class="nn">types</span><span class="w"> </span><span class="kn">import</span> <span class="n">WrapperDescriptorType</span><span class="p">,</span> <span class="n">MethodWrapperType</span><span class="p">,</span> <span class="n">MethodDescriptorType</span><span class="p">,</span> <span class="n">GenericAlias</span>
</span><span id="1-35">
</span><span id="1-36"><span class="kn">from</span><span class="w"> </span><span class="nn">_typing</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
</span><span id="1-37">    <span class="n">_idfunc</span><span class="p">,</span>
</span><span id="1-38">    <span class="n">TypeVar</span><span class="p">,</span>
</span><span id="1-39">    <span class="n">ParamSpec</span><span class="p">,</span>
</span><span id="1-40">    <span class="n">TypeVarTuple</span><span class="p">,</span>
</span><span id="1-41">    <span class="n">ParamSpecArgs</span><span class="p">,</span>
</span><span id="1-42">    <span class="n">ParamSpecKwargs</span><span class="p">,</span>
</span><span id="1-43">    <span class="n">TypeAliasType</span><span class="p">,</span>
</span><span id="1-44">    <span class="n">Generic</span><span class="p">,</span>
</span><span id="1-45"><span class="p">)</span>
</span><span id="1-46">
</span><span id="1-47"><span class="c1"># Please keep __all__ alphabetized within each category.</span>
</span><span id="1-48"><span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span>
</span><span id="1-49">    <span class="c1"># Super-special typing primitives.</span>
</span><span id="1-50">    <span class="s1">&#39;Annotated&#39;</span><span class="p">,</span>
</span><span id="1-51">    <span class="s1">&#39;Any&#39;</span><span class="p">,</span>
</span><span id="1-52">    <span class="s1">&#39;Callable&#39;</span><span class="p">,</span>
</span><span id="1-53">    <span class="s1">&#39;ClassVar&#39;</span><span class="p">,</span>
</span><span id="1-54">    <span class="s1">&#39;Concatenate&#39;</span><span class="p">,</span>
</span><span id="1-55">    <span class="s1">&#39;Final&#39;</span><span class="p">,</span>
</span><span id="1-56">    <span class="s1">&#39;ForwardRef&#39;</span><span class="p">,</span>
</span><span id="1-57">    <span class="s1">&#39;Generic&#39;</span><span class="p">,</span>
</span><span id="1-58">    <span class="s1">&#39;Literal&#39;</span><span class="p">,</span>
</span><span id="1-59">    <span class="s1">&#39;Optional&#39;</span><span class="p">,</span>
</span><span id="1-60">    <span class="s1">&#39;ParamSpec&#39;</span><span class="p">,</span>
</span><span id="1-61">    <span class="s1">&#39;Protocol&#39;</span><span class="p">,</span>
</span><span id="1-62">    <span class="s1">&#39;Tuple&#39;</span><span class="p">,</span>
</span><span id="1-63">    <span class="s1">&#39;Type&#39;</span><span class="p">,</span>
</span><span id="1-64">    <span class="s1">&#39;TypeVar&#39;</span><span class="p">,</span>
</span><span id="1-65">    <span class="s1">&#39;TypeVarTuple&#39;</span><span class="p">,</span>
</span><span id="1-66">    <span class="s1">&#39;Union&#39;</span><span class="p">,</span>
</span><span id="1-67">
</span><span id="1-68">    <span class="c1"># ABCs (from collections.abc).</span>
</span><span id="1-69">    <span class="s1">&#39;AbstractSet&#39;</span><span class="p">,</span>  <span class="c1"># collections.abc.Set.</span>
</span><span id="1-70">    <span class="s1">&#39;ByteString&#39;</span><span class="p">,</span>
</span><span id="1-71">    <span class="s1">&#39;Container&#39;</span><span class="p">,</span>
</span><span id="1-72">    <span class="s1">&#39;ContextManager&#39;</span><span class="p">,</span>
</span><span id="1-73">    <span class="s1">&#39;Hashable&#39;</span><span class="p">,</span>
</span><span id="1-74">    <span class="s1">&#39;ItemsView&#39;</span><span class="p">,</span>
</span><span id="1-75">    <span class="s1">&#39;Iterable&#39;</span><span class="p">,</span>
</span><span id="1-76">    <span class="s1">&#39;Iterator&#39;</span><span class="p">,</span>
</span><span id="1-77">    <span class="s1">&#39;KeysView&#39;</span><span class="p">,</span>
</span><span id="1-78">    <span class="s1">&#39;Mapping&#39;</span><span class="p">,</span>
</span><span id="1-79">    <span class="s1">&#39;MappingView&#39;</span><span class="p">,</span>
</span><span id="1-80">    <span class="s1">&#39;MutableMapping&#39;</span><span class="p">,</span>
</span><span id="1-81">    <span class="s1">&#39;MutableSequence&#39;</span><span class="p">,</span>
</span><span id="1-82">    <span class="s1">&#39;MutableSet&#39;</span><span class="p">,</span>
</span><span id="1-83">    <span class="s1">&#39;Sequence&#39;</span><span class="p">,</span>
</span><span id="1-84">    <span class="s1">&#39;Sized&#39;</span><span class="p">,</span>
</span><span id="1-85">    <span class="s1">&#39;ValuesView&#39;</span><span class="p">,</span>
</span><span id="1-86">    <span class="s1">&#39;Awaitable&#39;</span><span class="p">,</span>
</span><span id="1-87">    <span class="s1">&#39;AsyncIterator&#39;</span><span class="p">,</span>
</span><span id="1-88">    <span class="s1">&#39;AsyncIterable&#39;</span><span class="p">,</span>
</span><span id="1-89">    <span class="s1">&#39;Coroutine&#39;</span><span class="p">,</span>
</span><span id="1-90">    <span class="s1">&#39;Collection&#39;</span><span class="p">,</span>
</span><span id="1-91">    <span class="s1">&#39;AsyncGenerator&#39;</span><span class="p">,</span>
</span><span id="1-92">    <span class="s1">&#39;AsyncContextManager&#39;</span><span class="p">,</span>
</span><span id="1-93">
</span><span id="1-94">    <span class="c1"># Structural checks, a.k.a. protocols.</span>
</span><span id="1-95">    <span class="s1">&#39;Reversible&#39;</span><span class="p">,</span>
</span><span id="1-96">    <span class="s1">&#39;SupportsAbs&#39;</span><span class="p">,</span>
</span><span id="1-97">    <span class="s1">&#39;SupportsBytes&#39;</span><span class="p">,</span>
</span><span id="1-98">    <span class="s1">&#39;SupportsComplex&#39;</span><span class="p">,</span>
</span><span id="1-99">    <span class="s1">&#39;SupportsFloat&#39;</span><span class="p">,</span>
</span><span id="1-100">    <span class="s1">&#39;SupportsIndex&#39;</span><span class="p">,</span>
</span><span id="1-101">    <span class="s1">&#39;SupportsInt&#39;</span><span class="p">,</span>
</span><span id="1-102">    <span class="s1">&#39;SupportsRound&#39;</span><span class="p">,</span>
</span><span id="1-103">
</span><span id="1-104">    <span class="c1"># Concrete collection types.</span>
</span><span id="1-105">    <span class="s1">&#39;ChainMap&#39;</span><span class="p">,</span>
</span><span id="1-106">    <span class="s1">&#39;Counter&#39;</span><span class="p">,</span>
</span><span id="1-107">    <span class="s1">&#39;Deque&#39;</span><span class="p">,</span>
</span><span id="1-108">    <span class="s1">&#39;Dict&#39;</span><span class="p">,</span>
</span><span id="1-109">    <span class="s1">&#39;DefaultDict&#39;</span><span class="p">,</span>
</span><span id="1-110">    <span class="s1">&#39;List&#39;</span><span class="p">,</span>
</span><span id="1-111">    <span class="s1">&#39;OrderedDict&#39;</span><span class="p">,</span>
</span><span id="1-112">    <span class="s1">&#39;Set&#39;</span><span class="p">,</span>
</span><span id="1-113">    <span class="s1">&#39;FrozenSet&#39;</span><span class="p">,</span>
</span><span id="1-114">    <span class="s1">&#39;NamedTuple&#39;</span><span class="p">,</span>  <span class="c1"># Not really a type.</span>
</span><span id="1-115">    <span class="s1">&#39;TypedDict&#39;</span><span class="p">,</span>  <span class="c1"># Not really a type.</span>
</span><span id="1-116">    <span class="s1">&#39;Generator&#39;</span><span class="p">,</span>
</span><span id="1-117">
</span><span id="1-118">    <span class="c1"># Other concrete types.</span>
</span><span id="1-119">    <span class="s1">&#39;BinaryIO&#39;</span><span class="p">,</span>
</span><span id="1-120">    <span class="s1">&#39;IO&#39;</span><span class="p">,</span>
</span><span id="1-121">    <span class="s1">&#39;Match&#39;</span><span class="p">,</span>
</span><span id="1-122">    <span class="s1">&#39;Pattern&#39;</span><span class="p">,</span>
</span><span id="1-123">    <span class="s1">&#39;TextIO&#39;</span><span class="p">,</span>
</span><span id="1-124">
</span><span id="1-125">    <span class="c1"># One-off things.</span>
</span><span id="1-126">    <span class="s1">&#39;AnyStr&#39;</span><span class="p">,</span>
</span><span id="1-127">    <span class="s1">&#39;assert_type&#39;</span><span class="p">,</span>
</span><span id="1-128">    <span class="s1">&#39;assert_never&#39;</span><span class="p">,</span>
</span><span id="1-129">    <span class="s1">&#39;cast&#39;</span><span class="p">,</span>
</span><span id="1-130">    <span class="s1">&#39;clear_overloads&#39;</span><span class="p">,</span>
</span><span id="1-131">    <span class="s1">&#39;dataclass_transform&#39;</span><span class="p">,</span>
</span><span id="1-132">    <span class="s1">&#39;final&#39;</span><span class="p">,</span>
</span><span id="1-133">    <span class="s1">&#39;get_args&#39;</span><span class="p">,</span>
</span><span id="1-134">    <span class="s1">&#39;get_origin&#39;</span><span class="p">,</span>
</span><span id="1-135">    <span class="s1">&#39;get_overloads&#39;</span><span class="p">,</span>
</span><span id="1-136">    <span class="s1">&#39;get_type_hints&#39;</span><span class="p">,</span>
</span><span id="1-137">    <span class="s1">&#39;is_typeddict&#39;</span><span class="p">,</span>
</span><span id="1-138">    <span class="s1">&#39;LiteralString&#39;</span><span class="p">,</span>
</span><span id="1-139">    <span class="s1">&#39;Never&#39;</span><span class="p">,</span>
</span><span id="1-140">    <span class="s1">&#39;NewType&#39;</span><span class="p">,</span>
</span><span id="1-141">    <span class="s1">&#39;no_type_check&#39;</span><span class="p">,</span>
</span><span id="1-142">    <span class="s1">&#39;no_type_check_decorator&#39;</span><span class="p">,</span>
</span><span id="1-143">    <span class="s1">&#39;NoReturn&#39;</span><span class="p">,</span>
</span><span id="1-144">    <span class="s1">&#39;NotRequired&#39;</span><span class="p">,</span>
</span><span id="1-145">    <span class="s1">&#39;overload&#39;</span><span class="p">,</span>
</span><span id="1-146">    <span class="s1">&#39;override&#39;</span><span class="p">,</span>
</span><span id="1-147">    <span class="s1">&#39;ParamSpecArgs&#39;</span><span class="p">,</span>
</span><span id="1-148">    <span class="s1">&#39;ParamSpecKwargs&#39;</span><span class="p">,</span>
</span><span id="1-149">    <span class="s1">&#39;Required&#39;</span><span class="p">,</span>
</span><span id="1-150">    <span class="s1">&#39;reveal_type&#39;</span><span class="p">,</span>
</span><span id="1-151">    <span class="s1">&#39;runtime_checkable&#39;</span><span class="p">,</span>
</span><span id="1-152">    <span class="s1">&#39;Self&#39;</span><span class="p">,</span>
</span><span id="1-153">    <span class="s1">&#39;Text&#39;</span><span class="p">,</span>
</span><span id="1-154">    <span class="s1">&#39;TYPE_CHECKING&#39;</span><span class="p">,</span>
</span><span id="1-155">    <span class="s1">&#39;TypeAlias&#39;</span><span class="p">,</span>
</span><span id="1-156">    <span class="s1">&#39;TypeGuard&#39;</span><span class="p">,</span>
</span><span id="1-157">    <span class="s1">&#39;TypeAliasType&#39;</span><span class="p">,</span>
</span><span id="1-158">    <span class="s1">&#39;Unpack&#39;</span><span class="p">,</span>
</span><span id="1-159"><span class="p">]</span>
</span><span id="1-160">
</span><span id="1-161"><span class="c1"># The pseudo-submodules &#39;re&#39; and &#39;io&#39; are part of the public</span>
</span><span id="1-162"><span class="c1"># namespace, but excluded from __all__ because they might stomp on</span>
</span><span id="1-163"><span class="c1"># legitimate imports of those modules.</span>
</span><span id="1-164">
</span><span id="1-165">
</span><span id="1-166"><span class="k">def</span><span class="w"> </span><span class="nf">_type_convert</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">module</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">allow_special_forms</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
</span><span id="1-167"><span class="w">    </span><span class="sd">&quot;&quot;&quot;For converting None to type(None), and strings to ForwardRef.&quot;&quot;&quot;</span>
</span><span id="1-168">    <span class="k">if</span> <span class="n">arg</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
</span><span id="1-169">        <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
</span><span id="1-170">    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
</span><span id="1-171">        <span class="k">return</span> <span class="n">ForwardRef</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">module</span><span class="o">=</span><span class="n">module</span><span class="p">,</span> <span class="n">is_class</span><span class="o">=</span><span class="n">allow_special_forms</span><span class="p">)</span>
</span><span id="1-172">    <span class="k">return</span> <span class="n">arg</span>
</span><span id="1-173">
</span><span id="1-174">
</span><span id="1-175"><span class="k">def</span><span class="w"> </span><span class="nf">_type_check</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">is_argument</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">module</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">allow_special_forms</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
</span><span id="1-176"><span class="w">    </span><span class="sd">&quot;&quot;&quot;Check that the argument is a type, and return it (internal helper).</span>
</span><span id="1-177">
</span><span id="1-178"><span class="sd">    As a special case, accept None and return type(None) instead. Also wrap strings</span>
</span><span id="1-179"><span class="sd">    into ForwardRef instances. Consider several corner cases, for example plain</span>
</span><span id="1-180"><span class="sd">    special forms like Union are not valid, while Union[int, str] is OK, etc.</span>
</span><span id="1-181"><span class="sd">    The msg argument is a human-readable error message, e.g.::</span>
</span><span id="1-182">
</span><span id="1-183"><span class="sd">        &quot;Union[arg, ...]: arg should be a type.&quot;</span>
</span><span id="1-184">
</span><span id="1-185"><span class="sd">    We append the repr() of the actual value (truncated to 100 chars).</span>
</span><span id="1-186"><span class="sd">    &quot;&quot;&quot;</span>
</span><span id="1-187">    <span class="n">invalid_generic_forms</span> <span class="o">=</span> <span class="p">(</span><span class="n">Generic</span><span class="p">,</span> <span class="n">Protocol</span><span class="p">)</span>
</span><span id="1-188">    <span class="k">if</span> <span class="ow">not</span> <span class="n">allow_special_forms</span><span class="p">:</span>
</span><span id="1-189">        <span class="n">invalid_generic_forms</span> <span class="o">+=</span> <span class="p">(</span><span class="n">ClassVar</span><span class="p">,)</span>
</span><span id="1-190">        <span class="k">if</span> <span class="n">is_argument</span><span class="p">:</span>
</span><span id="1-191">            <span class="n">invalid_generic_forms</span> <span class="o">+=</span> <span class="p">(</span><span class="n">Final</span><span class="p">,)</span>
</span><span id="1-192">
</span><span id="1-193">    <span class="n">arg</span> <span class="o">=</span> <span class="n">_type_convert</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">module</span><span class="o">=</span><span class="n">module</span><span class="p">,</span> <span class="n">allow_special_forms</span><span class="o">=</span><span class="n">allow_special_forms</span><span class="p">)</span>
</span><span id="1-194">    <span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">_GenericAlias</span><span class="p">)</span> <span class="ow">and</span>
</span><span id="1-195">            <span class="n">arg</span><span class="o">.</span><span class="n">__origin__</span> <span class="ow">in</span> <span class="n">invalid_generic_forms</span><span class="p">):</span>
</span><span id="1-196">        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">arg</span><span class="si">}</span><span class="s2"> is not valid as type argument&quot;</span><span class="p">)</span>
</span><span id="1-197">    <span class="k">if</span> <span class="n">arg</span> <span class="ow">in</span> <span class="p">(</span><span class="n">Any</span><span class="p">,</span> <span class="n">LiteralString</span><span class="p">,</span> <span class="n">NoReturn</span><span class="p">,</span> <span class="n">Never</span><span class="p">,</span> <span class="n">Self</span><span class="p">,</span> <span class="n">TypeAlias</span><span class="p">):</span>
</span><span id="1-198">        <span class="k">return</span> <span class="n">arg</span>
</span><span id="1-199">    <span class="k">if</span> <span class="n">allow_special_forms</span> <span class="ow">and</span> <span class="n">arg</span> <span class="ow">in</span> <span class="p">(</span><span class="n">ClassVar</span><span class="p">,</span> <span class="n">Final</span><span class="p">):</span>
</span><span id="1-200">        <span class="k">return</span> <span class="n">arg</span>
</span><span id="1-201">    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">_SpecialForm</span><span class="p">)</span> <span class="ow">or</span> <span class="n">arg</span> <span class="ow">in</span> <span class="p">(</span><span class="n">Generic</span><span class="p">,</span> <span class="n">Protocol</span><span class="p">):</span>
</span><span id="1-202">        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Plain </span><span class="si">{</span><span class="n">arg</span><span class="si">}</span><span class="s2"> is not valid as type argument&quot;</span><span class="p">)</span>
</span><span id="1-203">    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">tuple</span><span class="p">:</span>
</span><span id="1-204">        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">msg</span><span class="si">}</span><span class="s2"> Got </span><span class="si">{</span><span class="n">arg</span><span class="si">!r:</span><span class="s2">.100</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
</span><span id="1-205">    <span class="k">return</span> <span class="n">arg</span>
</span><span id="1-206">
</span><span id="1-207">
</span><span id="1-208"><span class="k">def</span><span class="w"> </span><span class="nf">_is_param_expr</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span>
</span><span id="1-209">    <span class="k">return</span> <span class="n">arg</span> <span class="ow">is</span> <span class="o">...</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span>
</span><span id="1-210">            <span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">,</span> <span class="n">ParamSpec</span><span class="p">,</span> <span class="n">_ConcatenateGenericAlias</span><span class="p">))</span>
</span><span id="1-211">
</span><span id="1-212">
</span><span id="1-213"><span class="k">def</span><span class="w"> </span><span class="nf">_should_unflatten_callable_args</span><span class="p">(</span><span class="n">typ</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
</span><span id="1-214"><span class="w">    </span><span class="sd">&quot;&quot;&quot;Internal helper for munging collections.abc.Callable&#39;s __args__.</span>
</span><span id="1-215">
</span><span id="1-216"><span class="sd">    The canonical representation for a Callable&#39;s __args__ flattens the</span>
</span><span id="1-217"><span class="sd">    argument types, see https://github.com/python/cpython/issues/86361.</span>
</span><span id="1-218">
</span><span id="1-219"><span class="sd">    For example::</span>
</span><span id="1-220">
</span><span id="1-221"><span class="sd">        &gt;&gt;&gt; import collections.abc</span>
</span><span id="1-222"><span class="sd">        &gt;&gt;&gt; P = ParamSpec(&#39;P&#39;)</span>
</span><span id="1-223"><span class="sd">        &gt;&gt;&gt; collections.abc.Callable[[int, int], str].__args__ == (int, int, str)</span>
</span><span id="1-224"><span class="sd">        True</span>
</span><span id="1-225"><span class="sd">        &gt;&gt;&gt; collections.abc.Callable[P, str].__args__ == (P, str)</span>
</span><span id="1-226"><span class="sd">        True</span>
</span><span id="1-227">
</span><span id="1-228"><span class="sd">    As a result, if we need to reconstruct the Callable from its __args__,</span>
</span><span id="1-229"><span class="sd">    we need to unflatten it.</span>
</span><span id="1-230"><span class="sd">    &quot;&quot;&quot;</span>
</span><span id="1-231">    <span class="k">return</span> <span class="p">(</span>
</span><span id="1-232">        <span class="n">typ</span><span class="o">.</span><span class="n">__origin__</span> <span class="ow">is</span> <span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">Callable</span>
</span><span id="1-233">        <span class="ow">and</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">_is_param_expr</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
</span><span id="1-234">    <span class="p">)</span>
</span><span id="1-235">
</span><span id="1-236">
</span><span id="1-237"><span class="k">def</span><span class="w"> </span><span class="nf">_type_repr</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
</span><span id="1-238"><span class="w">    </span><span class="sd">&quot;&quot;&quot;Return the repr() of an object, special-casing types (internal helper).</span>
</span><span id="1-239">
</span><span id="1-240"><span class="sd">    If obj is a type, we return a shorter version than the default</span>
</span><span id="1-241"><span class="sd">    type.__repr__, based on the module and qualified name, which is</span>
</span><span id="1-242"><span class="sd">    typically enough to uniquely identify a type.  For everything</span>
</span><span id="1-243"><span class="sd">    else, we fall back on repr(obj).</span>
</span><span id="1-244"><span class="sd">    &quot;&quot;&quot;</span>
</span><span id="1-245">    <span class="c1"># When changing this function, don&#39;t forget about</span>
</span><span id="1-246">    <span class="c1"># `_collections_abc._type_repr`, which does the same thing</span>
</span><span id="1-247">    <span class="c1"># and must be consistent with this one.</span>
</span><span id="1-248">    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="nb">type</span><span class="p">):</span>
</span><span id="1-249">        <span class="k">if</span> <span class="n">obj</span><span class="o">.</span><span class="vm">__module__</span> <span class="o">==</span> <span class="s1">&#39;builtins&#39;</span><span class="p">:</span>
</span><span id="1-250">            <span class="k">return</span> <span class="n">obj</span><span class="o">.</span><span class="vm">__qualname__</span>
</span><span id="1-251">        <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">obj</span><span class="o">.</span><span class="vm">__module__</span><span class="si">}</span><span class="s1">.</span><span class="si">{</span><span class="n">obj</span><span class="o">.</span><span class="vm">__qualname__</span><span class="si">}</span><span class="s1">&#39;</span>
</span><span id="1-252">    <span class="k">if</span> <span class="n">obj</span> <span class="ow">is</span> <span class="o">...</span><span class="p">:</span>
</span><span id="1-253">        <span class="k">return</span> <span class="s1">&#39;...&#39;</span>
</span><span id="1-254">    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">FunctionType</span><span class="p">):</span>
</span><span id="1-255">        <span class="k">return</span> <span class="n">obj</span><span class="o">.</span><span class="vm">__name__</span>
</span><span id="1-256">    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
</span><span id="1-257">        <span class="c1"># Special case for `repr` of types with `ParamSpec`:</span>
</span><span id="1-258">        <span class="k">return</span> <span class="s1">&#39;[&#39;</span> <span class="o">+</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">_type_repr</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">obj</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;]&#39;</span>
</span><span id="1-259">    <span class="k">return</span> <span class="nb">repr</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
</span><span id="1-260">
</span><span id="1-261">
</span><span id="1-262"><span class="k">def</span><span class="w"> </span><span class="nf">_collect_parameters</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
</span><span id="1-263"><span class="w">    </span><span class="sd">&quot;&quot;&quot;Collect all type variables and parameter specifications in args</span>
</span><span id="1-264"><span class="sd">    in order of first appearance (lexicographic order).</span>
</span><span id="1-265">
</span><span id="1-266"><span class="sd">    For example::</span>
</span><span id="1-267">
</span><span id="1-268"><span class="sd">        &gt;&gt;&gt; P = ParamSpec(&#39;P&#39;)</span>
</span><span id="1-269"><span class="sd">        &gt;&gt;&gt; T = TypeVar(&#39;T&#39;)</span>
</span><span id="1-270"><span class="sd">        &gt;&gt;&gt; _collect_parameters((T, Callable[P, T]))</span>
</span><span id="1-271"><span class="sd">        (~T, ~P)</span>
</span><span id="1-272"><span class="sd">    &quot;&quot;&quot;</span>
</span><span id="1-273">    <span class="n">parameters</span> <span class="o">=</span> <span class="p">[]</span>
</span><span id="1-274">    <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
</span><span id="1-275">        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="nb">type</span><span class="p">):</span>
</span><span id="1-276">            <span class="c1"># We don&#39;t want __parameters__ descriptor of a bare Python class.</span>
</span><span id="1-277">            <span class="k">pass</span>
</span><span id="1-278">        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
</span><span id="1-279">            <span class="c1"># `t` might be a tuple, when `ParamSpec` is substituted with</span>
</span><span id="1-280">            <span class="c1"># `[T, int]`, or `[int, *Ts]`, etc.</span>
</span><span id="1-281">            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">t</span><span class="p">:</span>
</span><span id="1-282">                <span class="k">for</span> <span class="n">collected</span> <span class="ow">in</span> <span class="n">_collect_parameters</span><span class="p">([</span><span class="n">x</span><span class="p">]):</span>
</span><span id="1-283">                    <span class="k">if</span> <span class="n">collected</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">parameters</span><span class="p">:</span>
</span><span id="1-284">                        <span class="n">parameters</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">collected</span><span class="p">)</span>
</span><span id="1-285">        <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="s1">&#39;__typing_subst__&#39;</span><span class="p">):</span>
</span><span id="1-286">            <span class="k">if</span> <span class="n">t</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">parameters</span><span class="p">:</span>
</span><span id="1-287">                <span class="n">parameters</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
</span><span id="1-288">        <span class="k">else</span><span class="p">:</span>
</span><span id="1-289">            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="s1">&#39;__parameters__&#39;</span><span class="p">,</span> <span class="p">()):</span>
</span><span id="1-290">                <span class="k">if</span> <span class="n">x</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">parameters</span><span class="p">:</span>
</span><span id="1-291">                    <span class="n">parameters</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</span><span id="1-292">    <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">parameters</span><span class="p">)</span>
</span><span id="1-293">
</span><span id="1-294">
</span><span id="1-295"><span class="k">def</span><span class="w"> </span><span class="nf">_check_generic</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">parameters</span><span class="p">,</span> <span class="n">elen</span><span class="p">):</span>
</span><span id="1-296"><span class="w">    </span><span class="sd">&quot;&quot;&quot;Check correct count for parameters of a generic cls (internal helper).</span>
</span><span id="1-297">
</span><span id="1-298"><span class="sd">    This gives a nice error message in case of count mismatch.</span>
</span><span id="1-299"><span class="sd">    &quot;&quot;&quot;</span>
</span><span id="1-300">    <span class="k">if</span> <span class="ow">not</span> <span class="n">elen</span><span class="p">:</span>
</span><span id="1-301">        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">cls</span><span class="si">}</span><span class="s2"> is not a generic class&quot;</span><span class="p">)</span>
</span><span id="1-302">    <span class="n">alen</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">parameters</span><span class="p">)</span>
</span><span id="1-303">    <span class="k">if</span> <span class="n">alen</span> <span class="o">!=</span> <span class="n">elen</span><span class="p">:</span>
</span><span id="1-304">        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Too </span><span class="si">{</span><span class="s1">&#39;many&#39;</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">alen</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">elen</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="s1">&#39;few&#39;</span><span class="si">}</span><span class="s2"> arguments for </span><span class="si">{</span><span class="bp">cls</span><span class="si">}</span><span class="s2">;&quot;</span>
</span><span id="1-305">                        <span class="sa">f</span><span class="s2">&quot; actual </span><span class="si">{</span><span class="n">alen</span><span class="si">}</span><span class="s2">, expected </span><span class="si">{</span><span class="n">elen</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</span><span id="1-306">
</span><span id="1-307"><span class="k">def</span><span class="w"> </span><span class="nf">_unpack_args</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
</span><span id="1-308">    <span class="n">newargs</span> <span class="o">=</span> <span class="p">[]</span>
</span><span id="1-309">    <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
</span><span id="1-310">        <span class="n">subargs</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="s1">&#39;__typing_unpacked_tuple_args__&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
</span><span id="1-311">        <span class="k">if</span> <span class="n">subargs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="p">(</span><span class="n">subargs</span> <span class="ow">and</span> <span class="n">subargs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="o">...</span><span class="p">):</span>
</span><span id="1-312">            <span class="n">newargs</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">subargs</span><span class="p">)</span>
</span><span id="1-313">        <span class="k">else</span><span class="p">:</span>
</span><span id="1-314">            <span class="n">newargs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
</span><span id="1-315">    <span class="k">return</span> <span class="n">newargs</span>
</span><span id="1-316">
</span><span id="1-317"><span class="k">def</span><span class="w"> </span><span class="nf">_deduplicate</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">unhashable_fallback</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
</span><span id="1-318">    <span class="c1"># Weed out strict duplicates, preserving the first of each occurrence.</span>
</span><span id="1-319">    <span class="k">try</span><span class="p">:</span>
</span><span id="1-320">        <span class="k">return</span> <span class="nb">dict</span><span class="o">.</span><span class="n">fromkeys</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
</span><span id="1-321">    <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
</span><span id="1-322">        <span class="k">if</span> <span class="ow">not</span> <span class="n">unhashable_fallback</span><span class="p">:</span>
</span><span id="1-323">            <span class="k">raise</span>
</span><span id="1-324">        <span class="c1"># Happens for cases like `Annotated[dict, {&#39;x&#39;: IntValidator()}]`</span>
</span><span id="1-325">        <span class="k">return</span> <span class="n">_deduplicate_unhashable</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
</span><span id="1-326">
</span><span id="1-327"><span class="k">def</span><span class="w"> </span><span class="nf">_deduplicate_unhashable</span><span class="p">(</span><span class="n">unhashable_params</span><span class="p">):</span>
</span><span id="1-328">    <span class="n">new_unhashable</span> <span class="o">=</span> <span class="p">[]</span>
</span><span id="1-329">    <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">unhashable_params</span><span class="p">:</span>
</span><span id="1-330">        <span class="k">if</span> <span class="n">t</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">new_unhashable</span><span class="p">:</span>
</span><span id="1-331">            <span class="n">new_unhashable</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
</span><span id="1-332">    <span class="k">return</span> <span class="n">new_unhashable</span>
</span><span id="1-333">
</span><span id="1-334"><span class="k">def</span><span class="w"> </span><span class="nf">_compare_args_orderless</span><span class="p">(</span><span class="n">first_args</span><span class="p">,</span> <span class="n">second_args</span><span class="p">):</span>
</span><span id="1-335">    <span class="n">first_unhashable</span> <span class="o">=</span> <span class="n">_deduplicate_unhashable</span><span class="p">(</span><span class="n">first_args</span><span class="p">)</span>
</span><span id="1-336">    <span class="n">second_unhashable</span> <span class="o">=</span> <span class="n">_deduplicate_unhashable</span><span class="p">(</span><span class="n">second_args</span><span class="p">)</span>
</span><span id="1-337">    <span class="n">t</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">second_unhashable</span><span class="p">)</span>
</span><span id="1-338">    <span class="k">try</span><span class="p">:</span>
</span><span id="1-339">        <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">first_unhashable</span><span class="p">:</span>
</span><span id="1-340">            <span class="n">t</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span>
</span><span id="1-341">    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
</span><span id="1-342">        <span class="k">return</span> <span class="kc">False</span>
</span><span id="1-343">    <span class="k">return</span> <span class="ow">not</span> <span class="n">t</span>
</span><span id="1-344">
</span><span id="1-345"><span class="k">def</span><span class="w"> </span><span class="nf">_remove_dups_flatten</span><span class="p">(</span><span class="n">parameters</span><span class="p">):</span>
</span><span id="1-346"><span class="w">    </span><span class="sd">&quot;&quot;&quot;Internal helper for Union creation and substitution.</span>
</span><span id="1-347">
</span><span id="1-348"><span class="sd">    Flatten Unions among parameters, then remove duplicates.</span>
</span><span id="1-349"><span class="sd">    &quot;&quot;&quot;</span>
</span><span id="1-350">    <span class="c1"># Flatten out Union[Union[...], ...].</span>
</span><span id="1-351">    <span class="n">params</span> <span class="o">=</span> <span class="p">[]</span>
</span><span id="1-352">    <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">parameters</span><span class="p">:</span>
</span><span id="1-353">        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="p">(</span><span class="n">_UnionGenericAlias</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">UnionType</span><span class="p">)):</span>
</span><span id="1-354">            <span class="n">params</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">__args__</span><span class="p">)</span>
</span><span id="1-355">        <span class="k">else</span><span class="p">:</span>
</span><span id="1-356">            <span class="n">params</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
</span><span id="1-357">
</span><span id="1-358">    <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">_deduplicate</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">unhashable_fallback</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
</span><span id="1-359">
</span><span id="1-360">
</span><span id="1-361"><span class="k">def</span><span class="w"> </span><span class="nf">_flatten_literal_params</span><span class="p">(</span><span class="n">parameters</span><span class="p">):</span>
</span><span id="1-362"><span class="w">    </span><span class="sd">&quot;&quot;&quot;Internal helper for Literal creation: flatten Literals among parameters.&quot;&quot;&quot;</span>
</span><span id="1-363">    <span class="n">params</span> <span class="o">=</span> <span class="p">[]</span>
</span><span id="1-364">    <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">parameters</span><span class="p">:</span>
</span><span id="1-365">        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">_LiteralGenericAlias</span><span class="p">):</span>
</span><span id="1-366">            <span class="n">params</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">__args__</span><span class="p">)</span>
</span><span id="1-367">        <span class="k">else</span><span class="p">:</span>
</span><span id="1-368">            <span class="n">params</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
</span><span id="1-369">    <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
</span><span id="1-370">
</span><span id="1-371">
</span><span id="1-372"><span class="n">_cleanups</span> <span class="o">=</span> <span class="p">[]</span>
</span><span id="1-373"><span class="n">_caches</span> <span class="o">=</span> <span class="p">{}</span>
</span><span id="1-374">
</span><span id="1-375">
</span><span id="1-376"><span class="k">def</span><span class="w"> </span><span class="nf">_tp_cache</span><span class="p">(</span><span class="n">func</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">typed</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
</span><span id="1-377"><span class="w">    </span><span class="sd">&quot;&quot;&quot;Internal wrapper caching __getitem__ of generic types.</span>
</span><span id="1-378">
</span><span id="1-379"><span class="sd">    For non-hashable arguments, the original function is used as a fallback.</span>
</span><span id="1-380"><span class="sd">    &quot;&quot;&quot;</span>
</span><span id="1-381">    <span class="k">def</span><span class="w"> </span><span class="nf">decorator</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
</span><span id="1-382">        <span class="c1"># The callback &#39;inner&#39; references the newly created lru_cache</span>
</span><span id="1-383">        <span class="c1"># indirectly by performing a lookup in the global &#39;_caches&#39; dictionary.</span>
</span><span id="1-384">        <span class="c1"># This breaks a reference that can be problematic when combined with</span>
</span><span id="1-385">        <span class="c1"># C API extensions that leak references to types. See GH-98253.</span>
</span><span id="1-386">
</span><span id="1-387">        <span class="n">cache</span> <span class="o">=</span> <span class="n">functools</span><span class="o">.</span><span class="n">lru_cache</span><span class="p">(</span><span class="n">typed</span><span class="o">=</span><span class="n">typed</span><span class="p">)(</span><span class="n">func</span><span class="p">)</span>
</span><span id="1-388">        <span class="n">_caches</span><span class="p">[</span><span class="n">func</span><span class="p">]</span> <span class="o">=</span> <span class="n">cache</span>
</span><span id="1-389">        <span class="n">_cleanups</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cache</span><span class="o">.</span><span class="n">cache_clear</span><span class="p">)</span>
</span><span id="1-390">        <span class="k">del</span> <span class="n">cache</span>
</span><span id="1-391">
</span><span id="1-392">        <span class="nd">@functools</span><span class="o">.</span><span class="n">wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
</span><span id="1-393">        <span class="k">def</span><span class="w"> </span><span class="nf">inner</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
</span><span id="1-394">            <span class="k">try</span><span class="p">:</span>
</span><span id="1-395">                <span class="k">return</span> <span class="n">_caches</span><span class="p">[</span><span class="n">func</span><span class="p">](</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>
</span><span id="1-396">            <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
</span><span id="1-397">                <span class="k">pass</span>  <span class="c1"># All real errors (not unhashable args) are raised below.</span>
</span><span id="1-398">            <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>
</span><span id="1-399">        <span class="k">return</span> <span class="n">inner</span>
</span><span id="1-400">
</span><span id="1-401">    <span class="k">if</span> <span class="n">func</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
</span><span id="1-402">        <span class="k">return</span> <span class="n">decorator</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
</span><span id="1-403">
</span><span id="1-404">    <span class="k">return</span> <span class="n">decorator</span>
</span><span id="1-405">
</span><span id="1-406">
</span><span id="1-407"><span class="k">def</span><span class="w"> </span><span class="nf">_eval_type</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">globalns</span><span class="p">,</span> <span class="n">localns</span><span class="p">,</span> <span class="n">type_params</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">recursive_guard</span><span class="o">=</span><span class="nb">frozenset</span><span class="p">()):</span>
</span><span id="1-408"><span class="w">    </span><span class="sd">&quot;&quot;&quot;Evaluate all forward references in the given type t.</span>
</span><span id="1-409">
</span><span id="1-410"><span class="sd">    For use of globalns and localns see the docstring for get_type_hints().</span>
</span><span id="1-411"><span class="sd">    recursive_guard is used to prevent infinite recursion with a recursive</span>
</span><span id="1-412"><span class="sd">    ForwardRef.</span>
</span><span id="1-413"><span class="sd">    &quot;&quot;&quot;</span>
</span><span id="1-414">    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">ForwardRef</span><span class="p">):</span>
</span><span id="1-415">        <span class="k">return</span> <span class="n">t</span><span class="o">.</span><span class="n">_evaluate</span><span class="p">(</span><span class="n">globalns</span><span class="p">,</span> <span class="n">localns</span><span class="p">,</span> <span class="n">type_params</span><span class="p">,</span> <span class="n">recursive_guard</span><span class="o">=</span><span class="n">recursive_guard</span><span class="p">)</span>
</span><span id="1-416">    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="p">(</span><span class="n">_GenericAlias</span><span class="p">,</span> <span class="n">GenericAlias</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">UnionType</span><span class="p">)):</span>
</span><span id="1-417">        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">GenericAlias</span><span class="p">):</span>
</span><span id="1-418">            <span class="n">args</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
</span><span id="1-419">                <span class="n">ForwardRef</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">else</span> <span class="n">arg</span>
</span><span id="1-420">                <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">t</span><span class="o">.</span><span class="n">__args__</span>
</span><span id="1-421">            <span class="p">)</span>
</span><span id="1-422">            <span class="n">is_unpacked</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">__unpacked__</span>
</span><span id="1-423">            <span class="k">if</span> <span class="n">_should_unflatten_callable_args</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
</span><span id="1-424">                <span class="n">t</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">__origin__</span><span class="p">[(</span><span class="n">args</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">args</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])]</span>
</span><span id="1-425">            <span class="k">else</span><span class="p">:</span>
</span><span id="1-426">                <span class="n">t</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">__origin__</span><span class="p">[</span><span class="n">args</span><span class="p">]</span>
</span><span id="1-427">            <span class="k">if</span> <span class="n">is_unpacked</span><span class="p">:</span>
</span><span id="1-428">                <span class="n">t</span> <span class="o">=</span> <span class="n">Unpack</span><span class="p">[</span><span class="n">t</span><span class="p">]</span>
</span><span id="1-429">
</span><span id="1-430">        <span class="n">ev_args</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
</span><span id="1-431">            <span class="n">_eval_type</span><span class="p">(</span>
</span><span id="1-432">                <span class="n">a</span><span class="p">,</span> <span class="n">globalns</span><span class="p">,</span> <span class="n">localns</span><span class="p">,</span> <span class="n">type_params</span><span class="p">,</span> <span class="n">recursive_guard</span><span class="o">=</span><span class="n">recursive_guard</span>
</span><span id="1-433">            <span class="p">)</span>
</span><span id="1-434">            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">t</span><span class="o">.</span><span class="n">__args__</span>
</span><span id="1-435">        <span class="p">)</span>
</span><span id="1-436">        <span class="k">if</span> <span class="n">ev_args</span> <span class="o">==</span> <span class="n">t</span><span class="o">.</span><span class="n">__args__</span><span class="p">:</span>
</span><span id="1-437">            <span class="k">return</span> <span class="n">t</span>
</span><span id="1-438">        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">GenericAlias</span><span class="p">):</span>
</span><span id="1-439">            <span class="k">return</span> <span class="n">GenericAlias</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">__origin__</span><span class="p">,</span> <span class="n">ev_args</span><span class="p">)</span>
</span><span id="1-440">        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">UnionType</span><span class="p">):</span>
</span><span id="1-441">            <span class="k">return</span> <span class="n">functools</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">or_</span><span class="p">,</span> <span class="n">ev_args</span><span class="p">)</span>
</span><span id="1-442">        <span class="k">else</span><span class="p">:</span>
</span><span id="1-443">            <span class="k">return</span> <span class="n">t</span><span class="o">.</span><span class="n">copy_with</span><span class="p">(</span><span class="n">ev_args</span><span class="p">)</span>
</span><span id="1-444">    <span class="k">return</span> <span class="n">t</span>
</span><span id="1-445">
</span><span id="1-446">
</span><span id="1-447"><span class="k">class</span><span class="w"> </span><span class="nc">_Final</span><span class="p">:</span>
</span><span id="1-448"><span class="w">    </span><span class="sd">&quot;&quot;&quot;Mixin to prohibit subclassing.&quot;&quot;&quot;</span>
</span><span id="1-449">
</span><span id="1-450">    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;__weakref__&#39;</span><span class="p">,)</span>
</span><span id="1-451">
</span><span id="1-452">    <span class="k">def</span><span class="w"> </span><span class="nf">__init_subclass__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
</span><span id="1-453">        <span class="k">if</span> <span class="s1">&#39;_root&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwds</span><span class="p">:</span>
</span><span id="1-454">            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Cannot subclass special typing classes&quot;</span><span class="p">)</span>
</span><span id="1-455">
</span><span id="1-456">
</span><span id="1-457"><span class="k">class</span><span class="w"> </span><span class="nc">_NotIterable</span><span class="p">:</span>
</span><span id="1-458"><span class="w">    </span><span class="sd">&quot;&quot;&quot;Mixin to prevent iteration, without being compatible with Iterable.</span>
</span><span id="1-459">
</span><span id="1-460"><span class="sd">    That is, we could do::</span>
</span><span id="1-461">
</span><span id="1-462"><span class="sd">        def __iter__(self): raise TypeError()</span>
</span><span id="1-463">
</span><span id="1-464"><span class="sd">    But this would make users of this mixin duck type-compatible with</span>
</span><span id="1-465"><span class="sd">    collections.abc.Iterable - isinstance(foo, Iterable) would be True.</span>
</span><span id="1-466">
</span><span id="1-467"><span class="sd">    Luckily, we can instead prevent iteration by setting __iter__ to None, which</span>
</span><span id="1-468"><span class="sd">    is treated specially.</span>
</span><span id="1-469"><span class="sd">    &quot;&quot;&quot;</span>
</span><span id="1-470">
</span><span id="1-471">    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">()</span>
</span><span id="1-472">    <span class="fm">__iter__</span> <span class="o">=</span> <span class="kc">None</span>
</span><span id="1-473">
</span><span id="1-474">
</span><span id="1-475"><span class="c1"># Internal indicator of special typing constructs.</span>
</span><span id="1-476"><span class="c1"># See __doc__ instance attribute for specific docs.</span>
</span><span id="1-477"><span class="k">class</span><span class="w"> </span><span class="nc">_SpecialForm</span><span class="p">(</span><span class="n">_Final</span><span class="p">,</span> <span class="n">_NotIterable</span><span class="p">,</span> <span class="n">_root</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
</span><span id="1-478">    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;_name&#39;</span><span class="p">,</span> <span class="s1">&#39;__doc__&#39;</span><span class="p">,</span> <span class="s1">&#39;_getitem&#39;</span><span class="p">)</span>
</span><span id="1-479">
</span><span id="1-480">    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">getitem</span><span class="p">):</span>
</span><span id="1-481">        <span class="bp">self</span><span class="o">.</span><span class="n">_getitem</span> <span class="o">=</span> <span class="n">getitem</span>
</span><span id="1-482">        <span class="bp">self</span><span class="o">.</span><span class="n">_name</span> <span class="o">=</span> <span class="n">getitem</span><span class="o">.</span><span class="vm">__name__</span>
</span><span id="1-483">        <span class="bp">self</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">getitem</span><span class="o">.</span><span class="vm">__doc__</span>
</span><span id="1-484">
</span><span id="1-485">    <span class="k">def</span><span class="w"> </span><span class="fm">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
</span><span id="1-486">        <span class="k">if</span> <span class="n">item</span> <span class="ow">in</span> <span class="p">{</span><span class="s1">&#39;__name__&#39;</span><span class="p">,</span> <span class="s1">&#39;__qualname__&#39;</span><span class="p">}:</span>
</span><span id="1-487">            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name</span>
</span><span id="1-488">
</span><span id="1-489">        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
</span><span id="1-490">
</span><span id="1-491">    <span class="k">def</span><span class="w"> </span><span class="nf">__mro_entries__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bases</span><span class="p">):</span>
</span><span id="1-492">        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Cannot subclass </span><span class="si">{</span><span class="bp">self</span><span class="si">!r}</span><span class="s2">&quot;</span><span class="p">)</span>
</span><span id="1-493">
</span><span id="1-494">    <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span id="1-495">        <span class="k">return</span> <span class="s1">&#39;typing.&#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name</span>
</span><span id="1-496">
</span><span id="1-497">    <span class="k">def</span><span class="w"> </span><span class="nf">__reduce__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span id="1-498">        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name</span>
</span><span id="1-499">
</span><span id="1-500">    <span class="k">def</span><span class="w"> </span><span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
</span><span id="1-501">        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Cannot instantiate </span><span class="si">{</span><span class="bp">self</span><span class="si">!r}</span><span class="s2">&quot;</span><span class="p">)</span>
</span><span id="1-502">
</span><span id="1-503">    <span class="k">def</span><span class="w"> </span><span class="fm">__or__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
</span><span id="1-504">        <span class="k">return</span> <span class="n">Union</span><span class="p">[</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">]</span>
</span><span id="1-505">
</span><span id="1-506">    <span class="k">def</span><span class="w"> </span><span class="fm">__ror__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
</span><span id="1-507">        <span class="k">return</span> <span class="n">Union</span><span class="p">[</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="p">]</span>
</span><span id="1-508">
</span><span id="1-509">    <span class="k">def</span><span class="w"> </span><span class="fm">__instancecheck__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
</span><span id="1-510">        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s2"> cannot be used with isinstance()&quot;</span><span class="p">)</span>
</span><span id="1-511">
</span><span id="1-512">    <span class="k">def</span><span class="w"> </span><span class="fm">__subclasscheck__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">cls</span><span class="p">):</span>
</span><span id="1-513">        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s2"> cannot be used with issubclass()&quot;</span><span class="p">)</span>
</span><span id="1-514">
</span><span id="1-515">    <span class="nd">@_tp_cache</span>
</span><span id="1-516">    <span class="k">def</span><span class="w"> </span><span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parameters</span><span class="p">):</span>
</span><span id="1-517">        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getitem</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parameters</span><span class="p">)</span>
</span><span id="1-518">
</span><span id="1-519">
</span><span id="1-520"><span class="k">class</span><span class="w"> </span><span class="nc">_LiteralSpecialForm</span><span class="p">(</span><span class="n">_SpecialForm</span><span class="p">,</span> <span class="n">_root</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
</span><span id="1-521">    <span class="k">def</span><span class="w"> </span><span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parameters</span><span class="p">):</span>
</span><span id="1-522">        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">parameters</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
</span><span id="1-523">            <span class="n">parameters</span> <span class="o">=</span> <span class="p">(</span><span class="n">parameters</span><span class="p">,)</span>
</span><span id="1-524">        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getitem</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">parameters</span><span class="p">)</span>
</span><span id="1-525">
</span><span id="1-526">
</span><span id="1-527"><span class="k">class</span><span class="w"> </span><span class="nc">_AnyMeta</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>
</span><span id="1-528">    <span class="k">def</span><span class="w"> </span><span class="fm">__instancecheck__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
</span><span id="1-529">        <span class="k">if</span> <span class="bp">self</span> <span class="ow">is</span> <span class="n">Any</span><span class="p">:</span>
</span><span id="1-530">            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;typing.Any cannot be used with isinstance()&quot;</span><span class="p">)</span>
</span><span id="1-531">        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__instancecheck__</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
</span><span id="1-532">
</span><span id="1-533">    <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span id="1-534">        <span class="k">if</span> <span class="bp">self</span> <span class="ow">is</span> <span class="n">Any</span><span class="p">:</span>
</span><span id="1-535">            <span class="k">return</span> <span class="s2">&quot;typing.Any&quot;</span>
</span><span id="1-536">        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__repr__</span><span class="p">()</span>  <span class="c1"># respect to subclasses</span>
</span><span id="1-537">
</span><span id="1-538">
</span><span id="1-539"><span class="k">class</span><span class="w"> </span><span class="nc">Any</span><span class="p">(</span><span class="n">metaclass</span><span class="o">=</span><span class="n">_AnyMeta</span><span class="p">):</span>
</span><span id="1-540"><span class="w">    </span><span class="sd">&quot;&quot;&quot;Special type indicating an unconstrained type.</span>
</span><span id="1-541">
</span><span id="1-542"><span class="sd">    - Any is compatible with every type.</span>
</span><span id="1-543"><span class="sd">    - Any assumed to have all methods.</span>
</span><span id="1-544"><span class="sd">    - All values assumed to be instances of Any.</span>
</span><span id="1-545">
</span><span id="1-546"><span class="sd">    Note that all the above statements are true from the point of view of</span>
</span><span id="1-547"><span class="sd">    static type checkers. At runtime, Any should not be used with instance</span>
</span><span id="1-548"><span class="sd">    checks.</span>
</span><span id="1-549"><span class="sd">    &quot;&quot;&quot;</span>
</span><span id="1-550">
</span><span id="1-551">    <span class="k">def</span><span class="w"> </span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
</span><span id="1-552">        <span class="k">if</span> <span class="bp">cls</span> <span class="ow">is</span> <span class="n">Any</span><span class="p">:</span>
</span><span id="1-553">            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Any cannot be instantiated&quot;</span><span class="p">)</span>
</span><span id="1-554">        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>
</span><span id="1-555">
</span><span id="1-556">
</span><span id="1-557"><span class="nd">@_SpecialForm</span>
</span><span id="1-558"><span class="k">def</span><span class="w"> </span><span class="nf">NoReturn</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parameters</span><span class="p">):</span>
</span><span id="1-559"><span class="w">    </span><span class="sd">&quot;&quot;&quot;Special type indicating functions that never return.</span>
</span><span id="1-560">
</span><span id="1-561"><span class="sd">    Example::</span>
</span><span id="1-562">
</span><span id="1-563"><span class="sd">        from typing import NoReturn</span>
</span><span id="1-564">
</span><span id="1-565"><span class="sd">        def stop() -&gt; NoReturn:</span>
</span><span id="1-566"><span class="sd">            raise Exception(&#39;no way&#39;)</span>
</span><span id="1-567">
</span><span id="1-568"><span class="sd">    NoReturn can also be used as a bottom type, a type that</span>
</span><span id="1-569"><span class="sd">    has no values. Starting in Python 3.11, the Never type should</span>
</span><span id="1-570"><span class="sd">    be used for this concept instead. Type checkers should treat the two</span>
</span><span id="1-571"><span class="sd">    equivalently.</span>
</span><span id="1-572"><span class="sd">    &quot;&quot;&quot;</span>
</span><span id="1-573">    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s2"> is not subscriptable&quot;</span><span class="p">)</span>
</span><span id="1-574">
</span><span id="1-575"><span class="c1"># This is semantically identical to NoReturn, but it is implemented</span>
</span><span id="1-576"><span class="c1"># separately so that type checkers can distinguish between the two</span>
</span><span id="1-577"><span class="c1"># if they want.</span>
</span><span id="1-578"><span class="nd">@_SpecialForm</span>
</span><span id="1-579"><span class="k">def</span><span class="w"> </span><span class="nf">Never</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parameters</span><span class="p">):</span>
</span><span id="1-580"><span class="w">    </span><span class="sd">&quot;&quot;&quot;The bottom type, a type that has no members.</span>
</span><span id="1-581">
</span><span id="1-582"><span class="sd">    This can be used to define a function that should never be</span>
</span><span id="1-583"><span class="sd">    called, or a function that never returns::</span>
</span><span id="1-584">
</span><span id="1-585"><span class="sd">        from typing import Never</span>
</span><span id="1-586">
</span><span id="1-587"><span class="sd">        def never_call_me(arg: Never) -&gt; None:</span>
</span><span id="1-588"><span class="sd">            pass</span>
</span><span id="1-589">
</span><span id="1-590"><span class="sd">        def int_or_str(arg: int | str) -&gt; None:</span>
</span><span id="1-591"><span class="sd">            never_call_me(arg)  # type checker error</span>
</span><span id="1-592"><span class="sd">            match arg:</span>
</span><span id="1-593"><span class="sd">                case int():</span>
</span><span id="1-594"><span class="sd">                    print(&quot;It&#39;s an int&quot;)</span>
</span><span id="1-595"><span class="sd">                case str():</span>
</span><span id="1-596"><span class="sd">                    print(&quot;It&#39;s a str&quot;)</span>
</span><span id="1-597"><span class="sd">                case _:</span>
</span><span id="1-598"><span class="sd">                    never_call_me(arg)  # OK, arg is of type Never</span>
</span><span id="1-599"><span class="sd">    &quot;&quot;&quot;</span>
</span><span id="1-600">    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s2"> is not subscriptable&quot;</span><span class="p">)</span>
</span><span id="1-601">
</span><span id="1-602">
</span><span id="1-603"><span class="nd">@_SpecialForm</span>
</span><span id="1-604"><span class="k">def</span><span class="w"> </span><span class="nf">Self</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parameters</span><span class="p">):</span>
</span><span id="1-605"><span class="w">    </span><span class="sd">&quot;&quot;&quot;Used to spell the type of &quot;self&quot; in classes.</span>
</span><span id="1-606">
</span><span id="1-607"><span class="sd">    Example::</span>
</span><span id="1-608">
</span><span id="1-609"><span class="sd">        from typing import Self</span>
</span><span id="1-610">
</span><span id="1-611"><span class="sd">        class Foo:</span>
</span><span id="1-612"><span class="sd">            def return_self(self) -&gt; Self:</span>
</span><span id="1-613"><span class="sd">                ...</span>
</span><span id="1-614"><span class="sd">                return self</span>
</span><span id="1-615">
</span><span id="1-616"><span class="sd">    This is especially useful for:</span>
</span><span id="1-617"><span class="sd">        - classmethods that are used as alternative constructors</span>
</span><span id="1-618"><span class="sd">        - annotating an `__enter__` method which returns self</span>
</span><span id="1-619"><span class="sd">    &quot;&quot;&quot;</span>
</span><span id="1-620">    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s2"> is not subscriptable&quot;</span><span class="p">)</span>
</span><span id="1-621">
</span><span id="1-622">
</span><span id="1-623"><span class="nd">@_SpecialForm</span>
</span><span id="1-624"><span class="k">def</span><span class="w"> </span><span class="nf">LiteralString</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parameters</span><span class="p">):</span>
</span><span id="1-625"><span class="w">    </span><span class="sd">&quot;&quot;&quot;Represents an arbitrary literal string.</span>
</span><span id="1-626">
</span><span id="1-627"><span class="sd">    Example::</span>
</span><span id="1-628">
</span><span id="1-629"><span class="sd">        from typing import LiteralString</span>
</span><span id="1-630">
</span><span id="1-631"><span class="sd">        def run_query(sql: LiteralString) -&gt; None:</span>
</span><span id="1-632"><span class="sd">            ...</span>
</span><span id="1-633">
</span><span id="1-634"><span class="sd">        def caller(arbitrary_string: str, literal_string: LiteralString) -&gt; None:</span>
</span><span id="1-635"><span class="sd">            run_query(&quot;SELECT * FROM students&quot;)  # OK</span>
</span><span id="1-636"><span class="sd">            run_query(literal_string)  # OK</span>
</span><span id="1-637"><span class="sd">            run_query(&quot;SELECT * FROM &quot; + literal_string)  # OK</span>
</span><span id="1-638"><span class="sd">            run_query(arbitrary_string)  # type checker error</span>
</span><span id="1-639"><span class="sd">            run_query(  # type checker error</span>
</span><span id="1-640"><span class="sd">                f&quot;SELECT * FROM students WHERE name = {arbitrary_string}&quot;</span>
</span><span id="1-641"><span class="sd">            )</span>
</span><span id="1-642">
</span><span id="1-643"><span class="sd">    Only string literals and other LiteralStrings are compatible</span>
</span><span id="1-644"><span class="sd">    with LiteralString. This provides a tool to help prevent</span>
</span><span id="1-645"><span class="sd">    security issues such as SQL injection.</span>
</span><span id="1-646"><span class="sd">    &quot;&quot;&quot;</span>
</span><span id="1-647">    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s2"> is not subscriptable&quot;</span><span class="p">)</span>
</span><span id="1-648">
</span><span id="1-649">
</span><span id="1-650"><span class="nd">@_SpecialForm</span>
</span><span id="1-651"><span class="k">def</span><span class="w"> </span><span class="nf">ClassVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parameters</span><span class="p">):</span>
</span><span id="1-652"><span class="w">    </span><span class="sd">&quot;&quot;&quot;Special type construct to mark class variables.</span>
</span><span id="1-653">
</span><span id="1-654"><span class="sd">    An annotation wrapped in ClassVar indicates that a given</span>
</span><span id="1-655"><span class="sd">    attribute is intended to be used as a class variable and</span>
</span><span id="1-656"><span class="sd">    should not be set on instances of that class.</span>
</span><span id="1-657">
</span><span id="1-658"><span class="sd">    Usage::</span>
</span><span id="1-659">
</span><span id="1-660"><span class="sd">        class Starship:</span>
</span><span id="1-661"><span class="sd">            stats: ClassVar[dict[str, int]] = {} # class variable</span>
</span><span id="1-662"><span class="sd">            damage: int = 10                     # instance variable</span>
</span><span id="1-663">
</span><span id="1-664"><span class="sd">    ClassVar accepts only types and cannot be further subscribed.</span>
</span><span id="1-665">
</span><span id="1-666"><span class="sd">    Note that ClassVar is not a class itself, and should not</span>
</span><span id="1-667"><span class="sd">    be used with isinstance() or issubclass().</span>
</span><span id="1-668"><span class="sd">    &quot;&quot;&quot;</span>
</span><span id="1-669">    <span class="n">item</span> <span class="o">=</span> <span class="n">_type_check</span><span class="p">(</span><span class="n">parameters</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s1"> accepts only single type.&#39;</span><span class="p">)</span>
</span><span id="1-670">    <span class="k">return</span> <span class="n">_GenericAlias</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="p">(</span><span class="n">item</span><span class="p">,))</span>
</span><span id="1-671">
</span><span id="1-672"><span class="nd">@_SpecialForm</span>
</span><span id="1-673"><span class="k">def</span><span class="w"> </span><span class="nf">Final</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parameters</span><span class="p">):</span>
</span><span id="1-674"><span class="w">    </span><span class="sd">&quot;&quot;&quot;Special typing construct to indicate final names to type checkers.</span>
</span><span id="1-675">
</span><span id="1-676"><span class="sd">    A final name cannot be re-assigned or overridden in a subclass.</span>
</span><span id="1-677">
</span><span id="1-678"><span class="sd">    For example::</span>
</span><span id="1-679">
</span><span id="1-680"><span class="sd">        MAX_SIZE: Final = 9000</span>
</span><span id="1-681"><span class="sd">        MAX_SIZE += 1  # Error reported by type checker</span>
</span><span id="1-682">
</span><span id="1-683"><span class="sd">        class Connection:</span>
</span><span id="1-684"><span class="sd">            TIMEOUT: Final[int] = 10</span>
</span><span id="1-685">
</span><span id="1-686"><span class="sd">        class FastConnector(Connection):</span>
</span><span id="1-687"><span class="sd">            TIMEOUT = 1  # Error reported by type checker</span>
</span><span id="1-688">
</span><span id="1-689"><span class="sd">    There is no runtime checking of these properties.</span>
</span><span id="1-690"><span class="sd">    &quot;&quot;&quot;</span>
</span><span id="1-691">    <span class="n">item</span> <span class="o">=</span> <span class="n">_type_check</span><span class="p">(</span><span class="n">parameters</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s1"> accepts only single type.&#39;</span><span class="p">)</span>
</span><span id="1-692">    <span class="k">return</span> <span class="n">_GenericAlias</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="p">(</span><span class="n">item</span><span class="p">,))</span>
</span><span id="1-693">
</span><span id="1-694"><span class="nd">@_SpecialForm</span>
</span><span id="1-695"><span class="k">def</span><span class="w"> </span><span class="nf">Union</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parameters</span><span class="p">):</span>
</span><span id="1-696"><span class="w">    </span><span class="sd">&quot;&quot;&quot;Union type; Union[X, Y] means either X or Y.</span>
</span><span id="1-697">
</span><span id="1-698"><span class="sd">    On Python 3.10 and higher, the | operator</span>
</span><span id="1-699"><span class="sd">    can also be used to denote unions;</span>
</span><span id="1-700"><span class="sd">    X | Y means the same thing to the type checker as Union[X, Y].</span>
</span><span id="1-701">
</span><span id="1-702"><span class="sd">    To define a union, use e.g. Union[int, str]. Details:</span>
</span><span id="1-703"><span class="sd">    - The arguments must be types and there must be at least one.</span>
</span><span id="1-704"><span class="sd">    - None as an argument is a special case and is replaced by</span>
</span><span id="1-705"><span class="sd">      type(None).</span>
</span><span id="1-706"><span class="sd">    - Unions of unions are flattened, e.g.::</span>
</span><span id="1-707">
</span><span id="1-708"><span class="sd">        assert Union[Union[int, str], float] == Union[int, str, float]</span>
</span><span id="1-709">
</span><span id="1-710"><span class="sd">    - Unions of a single argument vanish, e.g.::</span>
</span><span id="1-711">
</span><span id="1-712"><span class="sd">        assert Union[int] == int  # The constructor actually returns int</span>
</span><span id="1-713">
</span><span id="1-714"><span class="sd">    - Redundant arguments are skipped, e.g.::</span>
</span><span id="1-715">
</span><span id="1-716"><span class="sd">        assert Union[int, str, int] == Union[int, str]</span>
</span><span id="1-717">
</span><span id="1-718"><span class="sd">    - When comparing unions, the argument order is ignored, e.g.::</span>
</span><span id="1-719">
</span><span id="1-720"><span class="sd">        assert Union[int, str] == Union[str, int]</span>
</span><span id="1-721">
</span><span id="1-722"><span class="sd">    - You cannot subclass or instantiate a union.</span>
</span><span id="1-723"><span class="sd">    - You can use Optional[X] as a shorthand for Union[X, None].</span>
</span><span id="1-724"><span class="sd">    &quot;&quot;&quot;</span>
</span><span id="1-725">    <span class="k">if</span> <span class="n">parameters</span> <span class="o">==</span> <span class="p">():</span>
</span><span id="1-726">        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Cannot take a Union of no types.&quot;</span><span class="p">)</span>
</span><span id="1-727">    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">parameters</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
</span><span id="1-728">        <span class="n">parameters</span> <span class="o">=</span> <span class="p">(</span><span class="n">parameters</span><span class="p">,)</span>
</span><span id="1-729">    <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Union[arg, ...]: each arg must be a type.&quot;</span>
</span><span id="1-730">    <span class="n">parameters</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">_type_check</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">parameters</span><span class="p">)</span>
</span><span id="1-731">    <span class="n">parameters</span> <span class="o">=</span> <span class="n">_remove_dups_flatten</span><span class="p">(</span><span class="n">parameters</span><span class="p">)</span>
</span><span id="1-732">    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">parameters</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
</span><span id="1-733">        <span class="k">return</span> <span class="n">parameters</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</span><span id="1-734">    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">parameters</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="nb">type</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span> <span class="ow">in</span> <span class="n">parameters</span><span class="p">:</span>
</span><span id="1-735">        <span class="k">return</span> <span class="n">_UnionGenericAlias</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parameters</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;Optional&quot;</span><span class="p">)</span>
</span><span id="1-736">    <span class="k">return</span> <span class="n">_UnionGenericAlias</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parameters</span><span class="p">)</span>
</span><span id="1-737">
</span><span id="1-738"><span class="k">def</span><span class="w"> </span><span class="nf">_make_union</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">):</span>
</span><span id="1-739"><span class="w">    </span><span class="sd">&quot;&quot;&quot;Used from the C implementation of TypeVar.</span>
</span><span id="1-740">
</span><span id="1-741"><span class="sd">    TypeVar.__or__ calls this instead of returning types.UnionType</span>
</span><span id="1-742"><span class="sd">    because we want to allow unions between TypeVars and strings</span>
</span><span id="1-743"><span class="sd">    (forward references).</span>
</span><span id="1-744"><span class="sd">    &quot;&quot;&quot;</span>
</span><span id="1-745">    <span class="k">return</span> <span class="n">Union</span><span class="p">[</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">]</span>
</span><span id="1-746">
</span><span id="1-747"><span class="nd">@_SpecialForm</span>
</span><span id="1-748"><span class="k">def</span><span class="w"> </span><span class="nf">Optional</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parameters</span><span class="p">):</span>
</span><span id="1-749"><span class="w">    </span><span class="sd">&quot;&quot;&quot;Optional[X] is equivalent to Union[X, None].&quot;&quot;&quot;</span>
</span><span id="1-750">    <span class="n">arg</span> <span class="o">=</span> <span class="n">_type_check</span><span class="p">(</span><span class="n">parameters</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s2"> requires a single type.&quot;</span><span class="p">)</span>
</span><span id="1-751">    <span class="k">return</span> <span class="n">Union</span><span class="p">[</span><span class="n">arg</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span>
</span><span id="1-752">
</span><span id="1-753"><span class="nd">@_LiteralSpecialForm</span>
</span><span id="1-754"><span class="nd">@_tp_cache</span><span class="p">(</span><span class="n">typed</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</span><span id="1-755"><span class="k">def</span><span class="w"> </span><span class="nf">Literal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">parameters</span><span class="p">):</span>
</span><span id="1-756"><span class="w">    </span><span class="sd">&quot;&quot;&quot;Special typing form to define literal types (a.k.a. value types).</span>
</span><span id="1-757">
</span><span id="1-758"><span class="sd">    This form can be used to indicate to type checkers that the corresponding</span>
</span><span id="1-759"><span class="sd">    variable or function parameter has a value equivalent to the provided</span>
</span><span id="1-760"><span class="sd">    literal (or one of several literals)::</span>
</span><span id="1-761">
</span><span id="1-762"><span class="sd">        def validate_simple(data: Any) -&gt; Literal[True]:  # always returns True</span>
</span><span id="1-763"><span class="sd">            ...</span>
</span><span id="1-764">
</span><span id="1-765"><span class="sd">        MODE = Literal[&#39;r&#39;, &#39;rb&#39;, &#39;w&#39;, &#39;wb&#39;]</span>
</span><span id="1-766"><span class="sd">        def open_helper(file: str, mode: MODE) -&gt; str:</span>
</span><span id="1-767"><span class="sd">            ...</span>
</span><span id="1-768">
</span><span id="1-769"><span class="sd">        open_helper(&#39;/some/path&#39;, &#39;r&#39;)  # Passes type check</span>
</span><span id="1-770"><span class="sd">        open_helper(&#39;/other/path&#39;, &#39;typo&#39;)  # Error in type checker</span>
</span><span id="1-771">
</span><span id="1-772"><span class="sd">    Literal[...] cannot be subclassed. At runtime, an arbitrary value</span>
</span><span id="1-773"><span class="sd">    is allowed as type argument to Literal[...], but type checkers may</span>
</span><span id="1-774"><span class="sd">    impose restrictions.</span>
</span><span id="1-775"><span class="sd">    &quot;&quot;&quot;</span>
</span><span id="1-776">    <span class="c1"># There is no &#39;_type_check&#39; call because arguments to Literal[...] are</span>
</span><span id="1-777">    <span class="c1"># values, not types.</span>
</span><span id="1-778">    <span class="n">parameters</span> <span class="o">=</span> <span class="n">_flatten_literal_params</span><span class="p">(</span><span class="n">parameters</span><span class="p">)</span>
</span><span id="1-779">
</span><span id="1-780">    <span class="k">try</span><span class="p">:</span>
</span><span id="1-781">        <span class="n">parameters</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">p</span> <span class="k">for</span> <span class="n">p</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">_deduplicate</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">_value_and_type_iter</span><span class="p">(</span><span class="n">parameters</span><span class="p">))))</span>
</span><span id="1-782">    <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>  <span class="c1"># unhashable parameters</span>
</span><span id="1-783">        <span class="k">pass</span>
</span><span id="1-784">
</span><span id="1-785">    <span class="k">return</span> <span class="n">_LiteralGenericAlias</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parameters</span><span class="p">)</span>
</span><span id="1-786">
</span><span id="1-787">
</span><span id="1-788"><span class="nd">@_SpecialForm</span>
</span><span id="1-789"><span class="k">def</span><span class="w"> </span><span class="nf">TypeAlias</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parameters</span><span class="p">):</span>
</span><span id="1-790"><span class="w">    </span><span class="sd">&quot;&quot;&quot;Special form for marking type aliases.</span>
</span><span id="1-791">
</span><span id="1-792"><span class="sd">    Use TypeAlias to indicate that an assignment should</span>
</span><span id="1-793"><span class="sd">    be recognized as a proper type alias definition by type</span>
</span><span id="1-794"><span class="sd">    checkers.</span>
</span><span id="1-795">
</span><span id="1-796"><span class="sd">    For example::</span>
</span><span id="1-797">
</span><span id="1-798"><span class="sd">        Predicate: TypeAlias = Callable[..., bool]</span>
</span><span id="1-799">
</span><span id="1-800"><span class="sd">    It&#39;s invalid when used anywhere except as in the example above.</span>
</span><span id="1-801"><span class="sd">    &quot;&quot;&quot;</span>
</span><span id="1-802">    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s2"> is not subscriptable&quot;</span><span class="p">)</span>
</span><span id="1-803">
</span><span id="1-804">
</span><span id="1-805"><span class="nd">@_SpecialForm</span>
</span><span id="1-806"><span class="k">def</span><span class="w"> </span><span class="nf">Concatenate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parameters</span><span class="p">):</span>
</span><span id="1-807"><span class="w">    </span><span class="sd">&quot;&quot;&quot;Special form for annotating higher-order functions.</span>
</span><span id="1-808">
</span><span id="1-809"><span class="sd">    ``Concatenate`` can be used in conjunction with ``ParamSpec`` and</span>
</span><span id="1-810"><span class="sd">    ``Callable`` to represent a higher-order function which adds, removes or</span>
</span><span id="1-811"><span class="sd">    transforms the parameters of a callable.</span>
</span><span id="1-812">
</span><span id="1-813"><span class="sd">    For example::</span>
</span><span id="1-814">
</span><span id="1-815"><span class="sd">        Callable[Concatenate[int, P], int]</span>
</span><span id="1-816">
</span><span id="1-817"><span class="sd">    See PEP 612 for detailed information.</span>
</span><span id="1-818"><span class="sd">    &quot;&quot;&quot;</span>
</span><span id="1-819">    <span class="k">if</span> <span class="n">parameters</span> <span class="o">==</span> <span class="p">():</span>
</span><span id="1-820">        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Cannot take a Concatenate of no types.&quot;</span><span class="p">)</span>
</span><span id="1-821">    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">parameters</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
</span><span id="1-822">        <span class="n">parameters</span> <span class="o">=</span> <span class="p">(</span><span class="n">parameters</span><span class="p">,)</span>
</span><span id="1-823">    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">parameters</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="o">...</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">parameters</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">ParamSpec</span><span class="p">)):</span>
</span><span id="1-824">        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;The last parameter to Concatenate should be a &quot;</span>
</span><span id="1-825">                        <span class="s2">&quot;ParamSpec variable or ellipsis.&quot;</span><span class="p">)</span>
</span><span id="1-826">    <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Concatenate[arg, ...]: each arg must be a type.&quot;</span>
</span><span id="1-827">    <span class="n">parameters</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">_type_check</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">parameters</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span> <span class="n">parameters</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
</span><span id="1-828">    <span class="k">return</span> <span class="n">_ConcatenateGenericAlias</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parameters</span><span class="p">)</span>
</span><span id="1-829">
</span><span id="1-830">
</span><span id="1-831"><span class="nd">@_SpecialForm</span>
</span><span id="1-832"><span class="k">def</span><span class="w"> </span><span class="nf">TypeGuard</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parameters</span><span class="p">):</span>
</span><span id="1-833"><span class="w">    </span><span class="sd">&quot;&quot;&quot;Special typing construct for marking user-defined type guard functions.</span>
</span><span id="1-834">
</span><span id="1-835"><span class="sd">    ``TypeGuard`` can be used to annotate the return type of a user-defined</span>
</span><span id="1-836"><span class="sd">    type guard function.  ``TypeGuard`` only accepts a single type argument.</span>
</span><span id="1-837"><span class="sd">    At runtime, functions marked this way should return a boolean.</span>
</span><span id="1-838">
</span><span id="1-839"><span class="sd">    ``TypeGuard`` aims to benefit *type narrowing* -- a technique used by static</span>
</span><span id="1-840"><span class="sd">    type checkers to determine a more precise type of an expression within a</span>
</span><span id="1-841"><span class="sd">    program&#39;s code flow.  Usually type narrowing is done by analyzing</span>
</span><span id="1-842"><span class="sd">    conditional code flow and applying the narrowing to a block of code.  The</span>
</span><span id="1-843"><span class="sd">    conditional expression here is sometimes referred to as a &quot;type guard&quot;.</span>
</span><span id="1-844">
</span><span id="1-845"><span class="sd">    Sometimes it would be convenient to use a user-defined boolean function</span>
</span><span id="1-846"><span class="sd">    as a type guard.  Such a function should use ``TypeGuard[...]`` as its</span>
</span><span id="1-847"><span class="sd">    return type to alert static type checkers to this intention.</span>
</span><span id="1-848">
</span><span id="1-849"><span class="sd">    Using  ``-&gt; TypeGuard`` tells the static type checker that for a given</span>
</span><span id="1-850"><span class="sd">    function:</span>
</span><span id="1-851">
</span><span id="1-852"><span class="sd">    1. The return value is a boolean.</span>
</span><span id="1-853"><span class="sd">    2. If the return value is ``True``, the type of its argument</span>
</span><span id="1-854"><span class="sd">       is the type inside ``TypeGuard``.</span>
</span><span id="1-855">
</span><span id="1-856"><span class="sd">    For example::</span>
</span><span id="1-857">
</span><span id="1-858"><span class="sd">         def is_str_list(val: list[object]) -&gt; TypeGuard[list[str]]:</span>
</span><span id="1-859"><span class="sd">             &#39;&#39;&#39;Determines whether all objects in the list are strings&#39;&#39;&#39;</span>
</span><span id="1-860"><span class="sd">             return all(isinstance(x, str) for x in val)</span>
</span><span id="1-861">
</span><span id="1-862"><span class="sd">         def func1(val: list[object]):</span>
</span><span id="1-863"><span class="sd">             if is_str_list(val):</span>
</span><span id="1-864"><span class="sd">                 # Type of ``val`` is narrowed to ``list[str]``.</span>
</span><span id="1-865"><span class="sd">                 print(&quot; &quot;.join(val))</span>
</span><span id="1-866"><span class="sd">             else:</span>
</span><span id="1-867"><span class="sd">                 # Type of ``val`` remains as ``list[object]``.</span>
</span><span id="1-868"><span class="sd">                 print(&quot;Not a list of strings!&quot;)</span>
</span><span id="1-869">
</span><span id="1-870"><span class="sd">    Strict type narrowing is not enforced -- ``TypeB`` need not be a narrower</span>
</span><span id="1-871"><span class="sd">    form of ``TypeA`` (it can even be a wider form) and this may lead to</span>
</span><span id="1-872"><span class="sd">    type-unsafe results.  The main reason is to allow for things like</span>
</span><span id="1-873"><span class="sd">    narrowing ``list[object]`` to ``list[str]`` even though the latter is not</span>
</span><span id="1-874"><span class="sd">    a subtype of the former, since ``list`` is invariant.  The responsibility of</span>
</span><span id="1-875"><span class="sd">    writing type-safe type guards is left to the user.</span>
</span><span id="1-876">
</span><span id="1-877"><span class="sd">    ``TypeGuard`` also works with type variables.  For more information, see</span>
</span><span id="1-878"><span class="sd">    PEP 647 (User-Defined Type Guards).</span>
</span><span id="1-879"><span class="sd">    &quot;&quot;&quot;</span>
</span><span id="1-880">    <span class="n">item</span> <span class="o">=</span> <span class="n">_type_check</span><span class="p">(</span><span class="n">parameters</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s1"> accepts only single type.&#39;</span><span class="p">)</span>
</span><span id="1-881">    <span class="k">return</span> <span class="n">_GenericAlias</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="p">(</span><span class="n">item</span><span class="p">,))</span>
</span><span id="1-882">
</span><span id="1-883">
</span><span id="1-884"><span class="k">class</span><span class="w"> </span><span class="nc">ForwardRef</span><span class="p">(</span><span class="n">_Final</span><span class="p">,</span> <span class="n">_root</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
</span><span id="1-885"><span class="w">    </span><span class="sd">&quot;&quot;&quot;Internal wrapper to hold a forward reference.&quot;&quot;&quot;</span>
</span><span id="1-886">
</span><span id="1-887">    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;__forward_arg__&#39;</span><span class="p">,</span> <span class="s1">&#39;__forward_code__&#39;</span><span class="p">,</span>
</span><span id="1-888">                 <span class="s1">&#39;__forward_evaluated__&#39;</span><span class="p">,</span> <span class="s1">&#39;__forward_value__&#39;</span><span class="p">,</span>
</span><span id="1-889">                 <span class="s1">&#39;__forward_is_argument__&#39;</span><span class="p">,</span> <span class="s1">&#39;__forward_is_class__&#39;</span><span class="p">,</span>
</span><span id="1-890">                 <span class="s1">&#39;__forward_module__&#39;</span><span class="p">)</span>
</span><span id="1-891">
</span><span id="1-892">    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="n">is_argument</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">module</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">is_class</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
</span><span id="1-893">        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
</span><span id="1-894">            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Forward reference must be a string -- got </span><span class="si">{</span><span class="n">arg</span><span class="si">!r}</span><span class="s2">&quot;</span><span class="p">)</span>
</span><span id="1-895">
</span><span id="1-896">        <span class="c1"># If we do `def f(*args: *Ts)`, then we&#39;ll have `arg = &#39;*Ts&#39;`.</span>
</span><span id="1-897">        <span class="c1"># Unfortunately, this isn&#39;t a valid expression on its own, so we</span>
</span><span id="1-898">        <span class="c1"># do the unpacking manually.</span>
</span><span id="1-899">        <span class="k">if</span> <span class="n">arg</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;*&#39;</span><span class="p">):</span>
</span><span id="1-900">            <span class="n">arg_to_compile</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;(</span><span class="si">{</span><span class="n">arg</span><span class="si">}</span><span class="s1">,)[0]&#39;</span>  <span class="c1"># E.g. (*Ts,)[0] or (*tuple[int, int],)[0]</span>
</span><span id="1-901">        <span class="k">else</span><span class="p">:</span>
</span><span id="1-902">            <span class="n">arg_to_compile</span> <span class="o">=</span> <span class="n">arg</span>
</span><span id="1-903">        <span class="k">try</span><span class="p">:</span>
</span><span id="1-904">            <span class="n">code</span> <span class="o">=</span> <span class="nb">compile</span><span class="p">(</span><span class="n">arg_to_compile</span><span class="p">,</span> <span class="s1">&#39;&lt;string&gt;&#39;</span><span class="p">,</span> <span class="s1">&#39;eval&#39;</span><span class="p">)</span>
</span><span id="1-905">        <span class="k">except</span> <span class="ne">SyntaxError</span><span class="p">:</span>
</span><span id="1-906">            <span class="k">raise</span> <span class="ne">SyntaxError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Forward reference must be an expression -- got </span><span class="si">{</span><span class="n">arg</span><span class="si">!r}</span><span class="s2">&quot;</span><span class="p">)</span>
</span><span id="1-907">
</span><span id="1-908">        <span class="bp">self</span><span class="o">.</span><span class="n">__forward_arg__</span> <span class="o">=</span> <span class="n">arg</span>
</span><span id="1-909">        <span class="bp">self</span><span class="o">.</span><span class="n">__forward_code__</span> <span class="o">=</span> <span class="n">code</span>
</span><span id="1-910">        <span class="bp">self</span><span class="o">.</span><span class="n">__forward_evaluated__</span> <span class="o">=</span> <span class="kc">False</span>
</span><span id="1-911">        <span class="bp">self</span><span class="o">.</span><span class="n">__forward_value__</span> <span class="o">=</span> <span class="kc">None</span>
</span><span id="1-912">        <span class="bp">self</span><span class="o">.</span><span class="n">__forward_is_argument__</span> <span class="o">=</span> <span class="n">is_argument</span>
</span><span id="1-913">        <span class="bp">self</span><span class="o">.</span><span class="n">__forward_is_class__</span> <span class="o">=</span> <span class="n">is_class</span>
</span><span id="1-914">        <span class="bp">self</span><span class="o">.</span><span class="n">__forward_module__</span> <span class="o">=</span> <span class="n">module</span>
</span><span id="1-915">
</span><span id="1-916">    <span class="k">def</span><span class="w"> </span><span class="nf">_evaluate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">globalns</span><span class="p">,</span> <span class="n">localns</span><span class="p">,</span> <span class="n">type_params</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">recursive_guard</span><span class="p">):</span>
</span><span id="1-917">        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__forward_arg__</span> <span class="ow">in</span> <span class="n">recursive_guard</span><span class="p">:</span>
</span><span id="1-918">            <span class="k">return</span> <span class="bp">self</span>
</span><span id="1-919">        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">__forward_evaluated__</span> <span class="ow">or</span> <span class="n">localns</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">globalns</span><span class="p">:</span>
</span><span id="1-920">            <span class="k">if</span> <span class="n">globalns</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">localns</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
</span><span id="1-921">                <span class="n">globalns</span> <span class="o">=</span> <span class="n">localns</span> <span class="o">=</span> <span class="p">{}</span>
</span><span id="1-922">            <span class="k">elif</span> <span class="n">globalns</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
</span><span id="1-923">                <span class="n">globalns</span> <span class="o">=</span> <span class="n">localns</span>
</span><span id="1-924">            <span class="k">elif</span> <span class="n">localns</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
</span><span id="1-925">                <span class="n">localns</span> <span class="o">=</span> <span class="n">globalns</span>
</span><span id="1-926">            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__forward_module__</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
</span><span id="1-927">                <span class="n">globalns</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span>
</span><span id="1-928">                    <span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__forward_module__</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span> <span class="s1">&#39;__dict__&#39;</span><span class="p">,</span> <span class="n">globalns</span>
</span><span id="1-929">                <span class="p">)</span>
</span><span id="1-930">
</span><span id="1-931">            <span class="c1"># type parameters require some special handling,</span>
</span><span id="1-932">            <span class="c1"># as they exist in their own scope</span>
</span><span id="1-933">            <span class="c1"># but `eval()` does not have a dedicated parameter for that scope.</span>
</span><span id="1-934">            <span class="c1"># For classes, names in type parameter scopes should override</span>
</span><span id="1-935">            <span class="c1"># names in the global scope (which here are called `localns`!),</span>
</span><span id="1-936">            <span class="c1"># but should in turn be overridden by names in the class scope</span>
</span><span id="1-937">            <span class="c1"># (which here are called `globalns`!)</span>
</span><span id="1-938">            <span class="k">if</span> <span class="n">type_params</span><span class="p">:</span>
</span><span id="1-939">                <span class="n">globalns</span><span class="p">,</span> <span class="n">localns</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">globalns</span><span class="p">),</span> <span class="nb">dict</span><span class="p">(</span><span class="n">localns</span><span class="p">)</span>
</span><span id="1-940">                <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="n">type_params</span><span class="p">:</span>
</span><span id="1-941">                    <span class="n">param_name</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="vm">__name__</span>
</span><span id="1-942">                    <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">__forward_is_class__</span> <span class="ow">or</span> <span class="n">param_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">globalns</span><span class="p">:</span>
</span><span id="1-943">                        <span class="n">globalns</span><span class="p">[</span><span class="n">param_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">param</span>
</span><span id="1-944">                        <span class="n">localns</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">param_name</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
</span><span id="1-945">
</span><span id="1-946">            <span class="n">type_</span> <span class="o">=</span> <span class="n">_type_check</span><span class="p">(</span>
</span><span id="1-947">                <span class="nb">eval</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__forward_code__</span><span class="p">,</span> <span class="n">globalns</span><span class="p">,</span> <span class="n">localns</span><span class="p">),</span>
</span><span id="1-948">                <span class="s2">&quot;Forward references must evaluate to types.&quot;</span><span class="p">,</span>
</span><span id="1-949">                <span class="n">is_argument</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__forward_is_argument__</span><span class="p">,</span>
</span><span id="1-950">                <span class="n">allow_special_forms</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__forward_is_class__</span><span class="p">,</span>
</span><span id="1-951">            <span class="p">)</span>
</span><span id="1-952">            <span class="bp">self</span><span class="o">.</span><span class="n">__forward_value__</span> <span class="o">=</span> <span class="n">_eval_type</span><span class="p">(</span>
</span><span id="1-953">                <span class="n">type_</span><span class="p">,</span>
</span><span id="1-954">                <span class="n">globalns</span><span class="p">,</span>
</span><span id="1-955">                <span class="n">localns</span><span class="p">,</span>
</span><span id="1-956">                <span class="n">type_params</span><span class="p">,</span>
</span><span id="1-957">                <span class="n">recursive_guard</span><span class="o">=</span><span class="p">(</span><span class="n">recursive_guard</span> <span class="o">|</span> <span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">__forward_arg__</span><span class="p">}),</span>
</span><span id="1-958">            <span class="p">)</span>
</span><span id="1-959">            <span class="bp">self</span><span class="o">.</span><span class="n">__forward_evaluated__</span> <span class="o">=</span> <span class="kc">True</span>
</span><span id="1-960">        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__forward_value__</span>
</span><span id="1-961">
</span><span id="1-962">    <span class="k">def</span><span class="w"> </span><span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
</span><span id="1-963">        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">ForwardRef</span><span class="p">):</span>
</span><span id="1-964">            <span class="k">return</span> <span class="bp">NotImplemented</span>
</span><span id="1-965">        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__forward_evaluated__</span> <span class="ow">and</span> <span class="n">other</span><span class="o">.</span><span class="n">__forward_evaluated__</span><span class="p">:</span>
</span><span id="1-966">            <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__forward_arg__</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">__forward_arg__</span> <span class="ow">and</span>
</span><span id="1-967">                    <span class="bp">self</span><span class="o">.</span><span class="n">__forward_value__</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">__forward_value__</span><span class="p">)</span>
</span><span id="1-968">        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__forward_arg__</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">__forward_arg__</span> <span class="ow">and</span>
</span><span id="1-969">                <span class="bp">self</span><span class="o">.</span><span class="n">__forward_module__</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">__forward_module__</span><span class="p">)</span>
</span><span id="1-970">
</span><span id="1-971">    <span class="k">def</span><span class="w"> </span><span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span id="1-972">        <span class="k">return</span> <span class="nb">hash</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">__forward_arg__</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__forward_module__</span><span class="p">))</span>
</span><span id="1-973">
</span><span id="1-974">    <span class="k">def</span><span class="w"> </span><span class="fm">__or__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
</span><span id="1-975">        <span class="k">return</span> <span class="n">Union</span><span class="p">[</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">]</span>
</span><span id="1-976">
</span><span id="1-977">    <span class="k">def</span><span class="w"> </span><span class="fm">__ror__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
</span><span id="1-978">        <span class="k">return</span> <span class="n">Union</span><span class="p">[</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="p">]</span>
</span><span id="1-979">
</span><span id="1-980">    <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span id="1-981">        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__forward_module__</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
</span><span id="1-982">            <span class="n">module_repr</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
</span><span id="1-983">        <span class="k">else</span><span class="p">:</span>
</span><span id="1-984">            <span class="n">module_repr</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;, module=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">__forward_module__</span><span class="si">!r}</span><span class="s1">&#39;</span>
</span><span id="1-985">        <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;ForwardRef(</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">__forward_arg__</span><span class="si">!r}{</span><span class="n">module_repr</span><span class="si">}</span><span class="s1">)&#39;</span>
</span><span id="1-986">
</span><span id="1-987">
</span><span id="1-988"><span class="k">def</span><span class="w"> </span><span class="nf">_is_unpacked_typevartuple</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
</span><span id="1-989">    <span class="k">return</span> <span class="p">((</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">type</span><span class="p">))</span> <span class="ow">and</span>
</span><span id="1-990">            <span class="nb">getattr</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="s1">&#39;__typing_is_unpacked_typevartuple__&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">))</span>
</span><span id="1-991">
</span><span id="1-992">
</span><span id="1-993"><span class="k">def</span><span class="w"> </span><span class="nf">_is_typevar_like</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
</span><span id="1-994">    <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="n">TypeVar</span><span class="p">,</span> <span class="n">ParamSpec</span><span class="p">))</span> <span class="ow">or</span> <span class="n">_is_unpacked_typevartuple</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</span><span id="1-995">
</span><span id="1-996">
</span><span id="1-997"><span class="k">class</span><span class="w"> </span><span class="nc">_PickleUsingNameMixin</span><span class="p">:</span>
</span><span id="1-998"><span class="w">    </span><span class="sd">&quot;&quot;&quot;Mixin enabling pickling based on self.__name__.&quot;&quot;&quot;</span>
</span><span id="1-999">
</span><span id="1-1000">    <span class="k">def</span><span class="w"> </span><span class="nf">__reduce__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span id="1-1001">        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__name__</span>
</span><span id="1-1002">
</span><span id="1-1003">
</span><span id="1-1004"><span class="k">def</span><span class="w"> </span><span class="nf">_typevar_subst</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg</span><span class="p">):</span>
</span><span id="1-1005">    <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Parameters to generic types must be types.&quot;</span>
</span><span id="1-1006">    <span class="n">arg</span> <span class="o">=</span> <span class="n">_type_check</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">is_argument</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</span><span id="1-1007">    <span class="k">if</span> <span class="p">((</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">_GenericAlias</span><span class="p">)</span> <span class="ow">and</span> <span class="n">arg</span><span class="o">.</span><span class="n">__origin__</span> <span class="ow">is</span> <span class="n">Unpack</span><span class="p">)</span> <span class="ow">or</span>
</span><span id="1-1008">        <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">GenericAlias</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="s1">&#39;__unpacked__&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">))):</span>
</span><span id="1-1009">        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">arg</span><span class="si">}</span><span class="s2"> is not valid as type argument&quot;</span><span class="p">)</span>
</span><span id="1-1010">    <span class="k">return</span> <span class="n">arg</span>
</span><span id="1-1011">
</span><span id="1-1012">
</span><span id="1-1013"><span class="k">def</span><span class="w"> </span><span class="nf">_typevartuple_prepare_subst</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alias</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
</span><span id="1-1014">    <span class="n">params</span> <span class="o">=</span> <span class="n">alias</span><span class="o">.</span><span class="n">__parameters__</span>
</span><span id="1-1015">    <span class="n">typevartuple_index</span> <span class="o">=</span> <span class="n">params</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</span><span id="1-1016">    <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="n">params</span><span class="p">[</span><span class="n">typevartuple_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:]:</span>
</span><span id="1-1017">        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">param</span><span class="p">,</span> <span class="n">TypeVarTuple</span><span class="p">):</span>
</span><span id="1-1018">            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;More than one TypeVarTuple parameter in </span><span class="si">{</span><span class="n">alias</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</span><span id="1-1019">
</span><span id="1-1020">    <span class="n">alen</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
</span><span id="1-1021">    <span class="n">plen</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
</span><span id="1-1022">    <span class="n">left</span> <span class="o">=</span> <span class="n">typevartuple_index</span>
</span><span id="1-1023">    <span class="n">right</span> <span class="o">=</span> <span class="n">plen</span> <span class="o">-</span> <span class="n">typevartuple_index</span> <span class="o">-</span> <span class="mi">1</span>
</span><span id="1-1024">    <span class="n">var_tuple_index</span> <span class="o">=</span> <span class="kc">None</span>
</span><span id="1-1025">    <span class="n">fillarg</span> <span class="o">=</span> <span class="kc">None</span>
</span><span id="1-1026">    <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">arg</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
</span><span id="1-1027">        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="nb">type</span><span class="p">):</span>
</span><span id="1-1028">            <span class="n">subargs</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="s1">&#39;__typing_unpacked_tuple_args__&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
</span><span id="1-1029">            <span class="k">if</span> <span class="n">subargs</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">subargs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">subargs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="o">...</span><span class="p">:</span>
</span><span id="1-1030">                <span class="k">if</span> <span class="n">var_tuple_index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
</span><span id="1-1031">                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;More than one unpacked arbitrary-length tuple argument&quot;</span><span class="p">)</span>
</span><span id="1-1032">                <span class="n">var_tuple_index</span> <span class="o">=</span> <span class="n">k</span>
</span><span id="1-1033">                <span class="n">fillarg</span> <span class="o">=</span> <span class="n">subargs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</span><span id="1-1034">    <span class="k">if</span> <span class="n">var_tuple_index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
</span><span id="1-1035">        <span class="n">left</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">var_tuple_index</span><span class="p">)</span>
</span><span id="1-1036">        <span class="n">right</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">alen</span> <span class="o">-</span> <span class="n">var_tuple_index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
</span><span id="1-1037">    <span class="k">elif</span> <span class="n">left</span> <span class="o">+</span> <span class="n">right</span> <span class="o">&gt;</span> <span class="n">alen</span><span class="p">:</span>
</span><span id="1-1038">        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Too few arguments for </span><span class="si">{</span><span class="n">alias</span><span class="si">}</span><span class="s2">;&quot;</span>
</span><span id="1-1039">                        <span class="sa">f</span><span class="s2">&quot; actual </span><span class="si">{</span><span class="n">alen</span><span class="si">}</span><span class="s2">, expected at least </span><span class="si">{</span><span class="n">plen</span><span class="o">-</span><span class="mi">1</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</span><span id="1-1040">
</span><span id="1-1041">    <span class="k">return</span> <span class="p">(</span>
</span><span id="1-1042">        <span class="o">*</span><span class="n">args</span><span class="p">[:</span><span class="n">left</span><span class="p">],</span>
</span><span id="1-1043">        <span class="o">*</span><span class="p">([</span><span class="n">fillarg</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">typevartuple_index</span> <span class="o">-</span> <span class="n">left</span><span class="p">)),</span>
</span><span id="1-1044">        <span class="nb">tuple</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="n">left</span><span class="p">:</span> <span class="n">alen</span> <span class="o">-</span> <span class="n">right</span><span class="p">]),</span>
</span><span id="1-1045">        <span class="o">*</span><span class="p">([</span><span class="n">fillarg</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">plen</span> <span class="o">-</span> <span class="n">right</span> <span class="o">-</span> <span class="n">left</span> <span class="o">-</span> <span class="n">typevartuple_index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)),</span>
</span><span id="1-1046">        <span class="o">*</span><span class="n">args</span><span class="p">[</span><span class="n">alen</span> <span class="o">-</span> <span class="n">right</span><span class="p">:],</span>
</span><span id="1-1047">    <span class="p">)</span>
</span><span id="1-1048">
</span><span id="1-1049">
</span><span id="1-1050"><span class="k">def</span><span class="w"> </span><span class="nf">_paramspec_subst</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg</span><span class="p">):</span>
</span><span id="1-1051">    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
</span><span id="1-1052">        <span class="n">arg</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">_type_check</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="s2">&quot;Expected a type.&quot;</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">arg</span><span class="p">)</span>
</span><span id="1-1053">    <span class="k">elif</span> <span class="ow">not</span> <span class="n">_is_param_expr</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span>
</span><span id="1-1054">        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Expected a list of types, an ellipsis, &quot;</span>
</span><span id="1-1055">                        <span class="sa">f</span><span class="s2">&quot;ParamSpec, or Concatenate. Got </span><span class="si">{</span><span class="n">arg</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</span><span id="1-1056">    <span class="k">return</span> <span class="n">arg</span>
</span><span id="1-1057">
</span><span id="1-1058">
</span><span id="1-1059"><span class="k">def</span><span class="w"> </span><span class="nf">_paramspec_prepare_subst</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alias</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
</span><span id="1-1060">    <span class="n">params</span> <span class="o">=</span> <span class="n">alias</span><span class="o">.</span><span class="n">__parameters__</span>
</span><span id="1-1061">    <span class="n">i</span> <span class="o">=</span> <span class="n">params</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</span><span id="1-1062">    <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
</span><span id="1-1063">        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Too few arguments for </span><span class="si">{</span><span class="n">alias</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</span><span id="1-1064">    <span class="c1"># Special case where Z[[int, str, bool]] == Z[int, str, bool] in PEP 612.</span>
</span><span id="1-1065">    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">params</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">_is_param_expr</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
</span><span id="1-1066">        <span class="k">assert</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span>
</span><span id="1-1067">        <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="n">args</span><span class="p">,)</span>
</span><span id="1-1068">    <span class="c1"># Convert lists to tuples to help other libraries cache the results.</span>
</span><span id="1-1069">    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="nb">list</span><span class="p">):</span>
</span><span id="1-1070">        <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">[:</span><span class="n">i</span><span class="p">],</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span> <span class="o">*</span><span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">:])</span>
</span><span id="1-1071">    <span class="k">return</span> <span class="n">args</span>
</span><span id="1-1072">
</span><span id="1-1073">
</span><span id="1-1074"><span class="nd">@_tp_cache</span>
</span><span id="1-1075"><span class="k">def</span><span class="w"> </span><span class="nf">_generic_class_getitem</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
</span><span id="1-1076"><span class="w">    </span><span class="sd">&quot;&quot;&quot;Parameterizes a generic class.</span>
</span><span id="1-1077">
</span><span id="1-1078"><span class="sd">    At least, parameterizing a generic class is the *main* thing this method</span>
</span><span id="1-1079"><span class="sd">    does. For example, for some generic class `Foo`, this is called when we</span>
</span><span id="1-1080"><span class="sd">    do `Foo[int]` - there, with `cls=Foo` and `params=int`.</span>
</span><span id="1-1081">
</span><span id="1-1082"><span class="sd">    However, note that this method is also called when defining generic</span>
</span><span id="1-1083"><span class="sd">    classes in the first place with `class Foo(Generic[T]): ...`.</span>
</span><span id="1-1084"><span class="sd">    &quot;&quot;&quot;</span>
</span><span id="1-1085">    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
</span><span id="1-1086">        <span class="n">params</span> <span class="o">=</span> <span class="p">(</span><span class="n">params</span><span class="p">,)</span>
</span><span id="1-1087">
</span><span id="1-1088">    <span class="n">params</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">_type_convert</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">params</span><span class="p">)</span>
</span><span id="1-1089">    <span class="n">is_generic_or_protocol</span> <span class="o">=</span> <span class="bp">cls</span> <span class="ow">in</span> <span class="p">(</span><span class="n">Generic</span><span class="p">,</span> <span class="n">Protocol</span><span class="p">)</span>
</span><span id="1-1090">
</span><span id="1-1091">    <span class="k">if</span> <span class="n">is_generic_or_protocol</span><span class="p">:</span>
</span><span id="1-1092">        <span class="c1"># Generic and Protocol can only be subscripted with unique type variables.</span>
</span><span id="1-1093">        <span class="k">if</span> <span class="ow">not</span> <span class="n">params</span><span class="p">:</span>
</span><span id="1-1094">            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
</span><span id="1-1095">                <span class="sa">f</span><span class="s2">&quot;Parameter list to </span><span class="si">{</span><span class="bp">cls</span><span class="o">.</span><span class="vm">__qualname__</span><span class="si">}</span><span class="s2">[...] cannot be empty&quot;</span>
</span><span id="1-1096">            <span class="p">)</span>
</span><span id="1-1097">        <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">_is_typevar_like</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">params</span><span class="p">):</span>
</span><span id="1-1098">            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
</span><span id="1-1099">                <span class="sa">f</span><span class="s2">&quot;Parameters to </span><span class="si">{</span><span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">[...] must all be type variables &quot;</span>
</span><span id="1-1100">                <span class="sa">f</span><span class="s2">&quot;or parameter specification variables.&quot;</span><span class="p">)</span>
</span><span id="1-1101">        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">params</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">params</span><span class="p">):</span>
</span><span id="1-1102">            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
</span><span id="1-1103">                <span class="sa">f</span><span class="s2">&quot;Parameters to </span><span class="si">{</span><span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">[...] must all be unique&quot;</span><span class="p">)</span>
</span><span id="1-1104">    <span class="k">else</span><span class="p">:</span>
</span><span id="1-1105">        <span class="c1"># Subscripting a regular Generic subclass.</span>
</span><span id="1-1106">        <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="n">__parameters__</span><span class="p">:</span>
</span><span id="1-1107">            <span class="n">prepare</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">param</span><span class="p">,</span> <span class="s1">&#39;__typing_prepare_subst__&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
</span><span id="1-1108">            <span class="k">if</span> <span class="n">prepare</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
</span><span id="1-1109">                <span class="n">params</span> <span class="o">=</span> <span class="n">prepare</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>
</span><span id="1-1110">        <span class="n">_check_generic</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="n">__parameters__</span><span class="p">))</span>
</span><span id="1-1111">
</span><span id="1-1112">        <span class="n">new_args</span> <span class="o">=</span> <span class="p">[]</span>
</span><span id="1-1113">        <span class="k">for</span> <span class="n">param</span><span class="p">,</span> <span class="n">new_arg</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="n">__parameters__</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
</span><span id="1-1114">            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">param</span><span class="p">,</span> <span class="n">TypeVarTuple</span><span class="p">):</span>
</span><span id="1-1115">                <span class="n">new_args</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">new_arg</span><span class="p">)</span>
</span><span id="1-1116">            <span class="k">else</span><span class="p">:</span>
</span><span id="1-1117">                <span class="n">new_args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_arg</span><span class="p">)</span>
</span><span id="1-1118">        <span class="n">params</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">new_args</span><span class="p">)</span>
</span><span id="1-1119">
</span><span id="1-1120">    <span class="k">return</span> <span class="n">_GenericAlias</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>
</span><span id="1-1121">
</span><span id="1-1122">
</span><span id="1-1123"><span class="k">def</span><span class="w"> </span><span class="nf">_generic_init_subclass</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
</span><span id="1-1124">    <span class="nb">super</span><span class="p">(</span><span class="n">Generic</span><span class="p">,</span> <span class="bp">cls</span><span class="p">)</span><span class="o">.</span><span class="n">__init_subclass__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</span><span id="1-1125">    <span class="n">tvars</span> <span class="o">=</span> <span class="p">[]</span>
</span><span id="1-1126">    <span class="k">if</span> <span class="s1">&#39;__orig_bases__&#39;</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">:</span>
</span><span id="1-1127">        <span class="n">error</span> <span class="o">=</span> <span class="n">Generic</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="n">__orig_bases__</span>
</span><span id="1-1128">    <span class="k">else</span><span class="p">:</span>
</span><span id="1-1129">        <span class="n">error</span> <span class="o">=</span> <span class="p">(</span><span class="n">Generic</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="vm">__bases__</span> <span class="ow">and</span>
</span><span id="1-1130">                    <span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">!=</span> <span class="s1">&#39;Protocol&#39;</span> <span class="ow">and</span>
</span><span id="1-1131">                    <span class="nb">type</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span> <span class="o">!=</span> <span class="n">_TypedDictMeta</span><span class="p">)</span>
</span><span id="1-1132">    <span class="k">if</span> <span class="n">error</span><span class="p">:</span>
</span><span id="1-1133">        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Cannot inherit from plain Generic&quot;</span><span class="p">)</span>
</span><span id="1-1134">    <span class="k">if</span> <span class="s1">&#39;__orig_bases__&#39;</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">:</span>
</span><span id="1-1135">        <span class="n">tvars</span> <span class="o">=</span> <span class="n">_collect_parameters</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="n">__orig_bases__</span><span class="p">)</span>
</span><span id="1-1136">        <span class="c1"># Look for Generic[T1, ..., Tn].</span>
</span><span id="1-1137">        <span class="c1"># If found, tvars must be a subset of it.</span>
</span><span id="1-1138">        <span class="c1"># If not found, tvars is it.</span>
</span><span id="1-1139">        <span class="c1"># Also check for and reject plain Generic,</span>
</span><span id="1-1140">        <span class="c1"># and reject multiple Generic[...].</span>
</span><span id="1-1141">        <span class="n">gvars</span> <span class="o">=</span> <span class="kc">None</span>
</span><span id="1-1142">        <span class="k">for</span> <span class="n">base</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="n">__orig_bases__</span><span class="p">:</span>
</span><span id="1-1143">            <span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">_GenericAlias</span><span class="p">)</span> <span class="ow">and</span>
</span><span id="1-1144">                    <span class="n">base</span><span class="o">.</span><span class="n">__origin__</span> <span class="ow">is</span> <span class="n">Generic</span><span class="p">):</span>
</span><span id="1-1145">                <span class="k">if</span> <span class="n">gvars</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
</span><span id="1-1146">                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
</span><span id="1-1147">                        <span class="s2">&quot;Cannot inherit from Generic[...] multiple times.&quot;</span><span class="p">)</span>
</span><span id="1-1148">                <span class="n">gvars</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="n">__parameters__</span>
</span><span id="1-1149">        <span class="k">if</span> <span class="n">gvars</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
</span><span id="1-1150">            <span class="n">tvarset</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">tvars</span><span class="p">)</span>
</span><span id="1-1151">            <span class="n">gvarset</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">gvars</span><span class="p">)</span>
</span><span id="1-1152">            <span class="k">if</span> <span class="ow">not</span> <span class="n">tvarset</span> <span class="o">&lt;=</span> <span class="n">gvarset</span><span class="p">:</span>
</span><span id="1-1153">                <span class="n">s_vars</span> <span class="o">=</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">tvars</span> <span class="k">if</span> <span class="n">t</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">gvarset</span><span class="p">)</span>
</span><span id="1-1154">                <span class="n">s_args</span> <span class="o">=</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">g</span><span class="p">)</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">gvars</span><span class="p">)</span>
</span><span id="1-1155">                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Some type variables (</span><span class="si">{</span><span class="n">s_vars</span><span class="si">}</span><span class="s2">) are&quot;</span>
</span><span id="1-1156">                                <span class="sa">f</span><span class="s2">&quot; not listed in Generic[</span><span class="si">{</span><span class="n">s_args</span><span class="si">}</span><span class="s2">]&quot;</span><span class="p">)</span>
</span><span id="1-1157">            <span class="n">tvars</span> <span class="o">=</span> <span class="n">gvars</span>
</span><span id="1-1158">    <span class="bp">cls</span><span class="o">.</span><span class="n">__parameters__</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">tvars</span><span class="p">)</span>
</span><span id="1-1159">
</span><span id="1-1160">
</span><span id="1-1161"><span class="k">def</span><span class="w"> </span><span class="nf">_is_dunder</span><span class="p">(</span><span class="n">attr</span><span class="p">):</span>
</span><span id="1-1162">    <span class="k">return</span> <span class="n">attr</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;__&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">attr</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;__&#39;</span><span class="p">)</span>
</span><span id="1-1163">
</span><span id="1-1164"><span class="k">class</span><span class="w"> </span><span class="nc">_BaseGenericAlias</span><span class="p">(</span><span class="n">_Final</span><span class="p">,</span> <span class="n">_root</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
</span><span id="1-1165"><span class="w">    </span><span class="sd">&quot;&quot;&quot;The central part of the internal API.</span>
</span><span id="1-1166">
</span><span id="1-1167"><span class="sd">    This represents a generic version of type &#39;origin&#39; with type arguments &#39;params&#39;.</span>
</span><span id="1-1168"><span class="sd">    There are two kind of these aliases: user defined and special. The special ones</span>
</span><span id="1-1169"><span class="sd">    are wrappers around builtin collections and ABCs in collections.abc. These must</span>
</span><span id="1-1170"><span class="sd">    have &#39;name&#39; always set. If &#39;inst&#39; is False, then the alias can&#39;t be instantiated;</span>
</span><span id="1-1171"><span class="sd">    this is used by e.g. typing.List and typing.Dict.</span>
</span><span id="1-1172"><span class="sd">    &quot;&quot;&quot;</span>
</span><span id="1-1173">
</span><span id="1-1174">    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">origin</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">inst</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
</span><span id="1-1175">        <span class="bp">self</span><span class="o">.</span><span class="n">_inst</span> <span class="o">=</span> <span class="n">inst</span>
</span><span id="1-1176">        <span class="bp">self</span><span class="o">.</span><span class="n">_name</span> <span class="o">=</span> <span class="n">name</span>
</span><span id="1-1177">        <span class="bp">self</span><span class="o">.</span><span class="n">__origin__</span> <span class="o">=</span> <span class="n">origin</span>
</span><span id="1-1178">        <span class="bp">self</span><span class="o">.</span><span class="vm">__slots__</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># This is not documented.</span>
</span><span id="1-1179">
</span><span id="1-1180">    <span class="k">def</span><span class="w"> </span><span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
</span><span id="1-1181">        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inst</span><span class="p">:</span>
</span><span id="1-1182">            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Type </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_name</span><span class="si">}</span><span class="s2"> cannot be instantiated; &quot;</span>
</span><span id="1-1183">                            <span class="sa">f</span><span class="s2">&quot;use </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">__origin__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">() instead&quot;</span><span class="p">)</span>
</span><span id="1-1184">        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__origin__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</span><span id="1-1185">        <span class="k">try</span><span class="p">:</span>
</span><span id="1-1186">            <span class="n">result</span><span class="o">.</span><span class="n">__orig_class__</span> <span class="o">=</span> <span class="bp">self</span>
</span><span id="1-1187">        <span class="c1"># Some objects raise TypeError (or something even more exotic)</span>
</span><span id="1-1188">        <span class="c1"># if you try to set attributes on them; we guard against that here</span>
</span><span id="1-1189">        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
</span><span id="1-1190">            <span class="k">pass</span>
</span><span id="1-1191">        <span class="k">return</span> <span class="n">result</span>
</span><span id="1-1192">
</span><span id="1-1193">    <span class="k">def</span><span class="w"> </span><span class="nf">__mro_entries__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bases</span><span class="p">):</span>
</span><span id="1-1194">        <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
</span><span id="1-1195">        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__origin__</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">bases</span><span class="p">:</span>
</span><span id="1-1196">            <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__origin__</span><span class="p">)</span>
</span><span id="1-1197">        <span class="n">i</span> <span class="o">=</span> <span class="n">bases</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</span><span id="1-1198">        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">bases</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">:]:</span>
</span><span id="1-1199">            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">_BaseGenericAlias</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">Generic</span><span class="p">):</span>
</span><span id="1-1200">                <span class="k">break</span>
</span><span id="1-1201">        <span class="k">else</span><span class="p">:</span>
</span><span id="1-1202">            <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Generic</span><span class="p">)</span>
</span><span id="1-1203">        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>
</span><span id="1-1204">
</span><span id="1-1205">    <span class="k">def</span><span class="w"> </span><span class="fm">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">):</span>
</span><span id="1-1206">        <span class="k">if</span> <span class="n">attr</span> <span class="ow">in</span> <span class="p">{</span><span class="s1">&#39;__name__&#39;</span><span class="p">,</span> <span class="s1">&#39;__qualname__&#39;</span><span class="p">}:</span>
</span><span id="1-1207">            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">__origin__</span><span class="o">.</span><span class="vm">__name__</span>
</span><span id="1-1208">
</span><span id="1-1209">        <span class="c1"># We are careful for copy and pickle.</span>
</span><span id="1-1210">        <span class="c1"># Also for simplicity we don&#39;t relay any dunder names</span>
</span><span id="1-1211">        <span class="k">if</span> <span class="s1">&#39;__origin__&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">_is_dunder</span><span class="p">(</span><span class="n">attr</span><span class="p">):</span>
</span><span id="1-1212">            <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__origin__</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span>
</span><span id="1-1213">        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="n">attr</span><span class="p">)</span>
</span><span id="1-1214">
</span><span id="1-1215">    <span class="k">def</span><span class="w"> </span><span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
</span><span id="1-1216">        <span class="k">if</span> <span class="n">_is_dunder</span><span class="p">(</span><span class="n">attr</span><span class="p">)</span> <span class="ow">or</span> <span class="n">attr</span> <span class="ow">in</span> <span class="p">{</span><span class="s1">&#39;_name&#39;</span><span class="p">,</span> <span class="s1">&#39;_inst&#39;</span><span class="p">,</span> <span class="s1">&#39;_nparams&#39;</span><span class="p">}:</span>
</span><span id="1-1217">            <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="n">attr</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
</span><span id="1-1218">        <span class="k">else</span><span class="p">:</span>
</span><span id="1-1219">            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__origin__</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
</span><span id="1-1220">
</span><span id="1-1221">    <span class="k">def</span><span class="w"> </span><span class="fm">__instancecheck__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
</span><span id="1-1222">        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__subclasscheck__</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">obj</span><span class="p">))</span>
</span><span id="1-1223">
</span><span id="1-1224">    <span class="k">def</span><span class="w"> </span><span class="fm">__subclasscheck__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">cls</span><span class="p">):</span>
</span><span id="1-1225">        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Subscripted generics cannot be used with&quot;</span>
</span><span id="1-1226">                        <span class="s2">&quot; class and instance checks&quot;</span><span class="p">)</span>
</span><span id="1-1227">
</span><span id="1-1228">    <span class="k">def</span><span class="w"> </span><span class="fm">__dir__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span id="1-1229">        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__dir__</span><span class="p">()</span>
</span><span id="1-1230">                <span class="o">+</span> <span class="p">[</span><span class="n">attr</span> <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="nb">dir</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__origin__</span><span class="p">)</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">_is_dunder</span><span class="p">(</span><span class="n">attr</span><span class="p">)]))</span>
</span><span id="1-1231">
</span><span id="1-1232">
</span><span id="1-1233"><span class="c1"># Special typing constructs Union, Optional, Generic, Callable and Tuple</span>
</span><span id="1-1234"><span class="c1"># use three special attributes for internal bookkeeping of generic types:</span>
</span><span id="1-1235"><span class="c1"># * __parameters__ is a tuple of unique free type parameters of a generic</span>
</span><span id="1-1236"><span class="c1">#   type, for example, Dict[T, T].__parameters__ == (T,);</span>
</span><span id="1-1237"><span class="c1"># * __origin__ keeps a reference to a type that was subscripted,</span>
</span><span id="1-1238"><span class="c1">#   e.g., Union[T, int].__origin__ == Union, or the non-generic version of</span>
</span><span id="1-1239"><span class="c1">#   the type.</span>
</span><span id="1-1240"><span class="c1"># * __args__ is a tuple of all arguments used in subscripting,</span>
</span><span id="1-1241"><span class="c1">#   e.g., Dict[T, int].__args__ == (T, int).</span>
</span><span id="1-1242">
</span><span id="1-1243">
</span><span id="1-1244"><span class="k">class</span><span class="w"> </span><span class="nc">_GenericAlias</span><span class="p">(</span><span class="n">_BaseGenericAlias</span><span class="p">,</span> <span class="n">_root</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
</span><span id="1-1245">    <span class="c1"># The type of parameterized generics.</span>
</span><span id="1-1246">    <span class="c1">#</span>
</span><span id="1-1247">    <span class="c1"># That is, for example, `type(List[int])` is `_GenericAlias`.</span>
</span><span id="1-1248">    <span class="c1">#</span>
</span><span id="1-1249">    <span class="c1"># Objects which are instances of this class include:</span>
</span><span id="1-1250">    <span class="c1"># * Parameterized container types, e.g. `Tuple[int]`, `List[int]`.</span>
</span><span id="1-1251">    <span class="c1">#  * Note that native container types, e.g. `tuple`, `list`, use</span>
</span><span id="1-1252">    <span class="c1">#    `types.GenericAlias` instead.</span>
</span><span id="1-1253">    <span class="c1"># * Parameterized classes:</span>
</span><span id="1-1254">    <span class="c1">#     class C[T]: pass</span>
</span><span id="1-1255">    <span class="c1">#     # C[int] is a _GenericAlias</span>
</span><span id="1-1256">    <span class="c1"># * `Callable` aliases, generic `Callable` aliases, and</span>
</span><span id="1-1257">    <span class="c1">#   parameterized `Callable` aliases:</span>
</span><span id="1-1258">    <span class="c1">#     T = TypeVar(&#39;T&#39;)</span>
</span><span id="1-1259">    <span class="c1">#     # _CallableGenericAlias inherits from _GenericAlias.</span>
</span><span id="1-1260">    <span class="c1">#     A = Callable[[], None]  # _CallableGenericAlias</span>
</span><span id="1-1261">    <span class="c1">#     B = Callable[[T], None]  # _CallableGenericAlias</span>
</span><span id="1-1262">    <span class="c1">#     C = B[int]  # _CallableGenericAlias</span>
</span><span id="1-1263">    <span class="c1"># * Parameterized `Final`, `ClassVar` and `TypeGuard`:</span>
</span><span id="1-1264">    <span class="c1">#     # All _GenericAlias</span>
</span><span id="1-1265">    <span class="c1">#     Final[int]</span>
</span><span id="1-1266">    <span class="c1">#     ClassVar[float]</span>
</span><span id="1-1267">    <span class="c1">#     TypeVar[bool]</span>
</span><span id="1-1268">
</span><span id="1-1269">    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">origin</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">inst</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
</span><span id="1-1270">        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">origin</span><span class="p">,</span> <span class="n">inst</span><span class="o">=</span><span class="n">inst</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>
</span><span id="1-1271">        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
</span><span id="1-1272">            <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="n">args</span><span class="p">,)</span>
</span><span id="1-1273">        <span class="bp">self</span><span class="o">.</span><span class="n">__args__</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="o">...</span> <span class="k">if</span> <span class="n">a</span> <span class="ow">is</span> <span class="n">_TypingEllipsis</span> <span class="k">else</span>
</span><span id="1-1274">                              <span class="n">a</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">args</span><span class="p">)</span>
</span><span id="1-1275">        <span class="bp">self</span><span class="o">.</span><span class="n">__parameters__</span> <span class="o">=</span> <span class="n">_collect_parameters</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
</span><span id="1-1276">        <span class="k">if</span> <span class="ow">not</span> <span class="n">name</span><span class="p">:</span>
</span><span id="1-1277">            <span class="bp">self</span><span class="o">.</span><span class="vm">__module__</span> <span class="o">=</span> <span class="n">origin</span><span class="o">.</span><span class="vm">__module__</span>
</span><span id="1-1278">
</span><span id="1-1279">    <span class="k">def</span><span class="w"> </span><span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
</span><span id="1-1280">        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">_GenericAlias</span><span class="p">):</span>
</span><span id="1-1281">            <span class="k">return</span> <span class="bp">NotImplemented</span>
</span><span id="1-1282">        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__origin__</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">__origin__</span>
</span><span id="1-1283">                <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">__args__</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">__args__</span><span class="p">)</span>
</span><span id="1-1284">
</span><span id="1-1285">    <span class="k">def</span><span class="w"> </span><span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span id="1-1286">        <span class="k">return</span> <span class="nb">hash</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">__origin__</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__args__</span><span class="p">))</span>
</span><span id="1-1287">
</span><span id="1-1288">    <span class="k">def</span><span class="w"> </span><span class="fm">__or__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">right</span><span class="p">):</span>
</span><span id="1-1289">        <span class="k">return</span> <span class="n">Union</span><span class="p">[</span><span class="bp">self</span><span class="p">,</span> <span class="n">right</span><span class="p">]</span>
</span><span id="1-1290">
</span><span id="1-1291">    <span class="k">def</span><span class="w"> </span><span class="fm">__ror__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">left</span><span class="p">):</span>
</span><span id="1-1292">        <span class="k">return</span> <span class="n">Union</span><span class="p">[</span><span class="n">left</span><span class="p">,</span> <span class="bp">self</span><span class="p">]</span>
</span><span id="1-1293">
</span><span id="1-1294">    <span class="nd">@_tp_cache</span>
</span><span id="1-1295">    <span class="k">def</span><span class="w"> </span><span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
</span><span id="1-1296">        <span class="c1"># Parameterizes an already-parameterized object.</span>
</span><span id="1-1297">        <span class="c1">#</span>
</span><span id="1-1298">        <span class="c1"># For example, we arrive here doing something like:</span>
</span><span id="1-1299">        <span class="c1">#   T1 = TypeVar(&#39;T1&#39;)</span>
</span><span id="1-1300">        <span class="c1">#   T2 = TypeVar(&#39;T2&#39;)</span>
</span><span id="1-1301">        <span class="c1">#   T3 = TypeVar(&#39;T3&#39;)</span>
</span><span id="1-1302">        <span class="c1">#   class A(Generic[T1]): pass</span>
</span><span id="1-1303">        <span class="c1">#   B = A[T2]  # B is a _GenericAlias</span>
</span><span id="1-1304">        <span class="c1">#   C = B[T3]  # Invokes _GenericAlias.__getitem__</span>
</span><span id="1-1305">        <span class="c1">#</span>
</span><span id="1-1306">        <span class="c1"># We also arrive here when parameterizing a generic `Callable` alias:</span>
</span><span id="1-1307">        <span class="c1">#   T = TypeVar(&#39;T&#39;)</span>
</span><span id="1-1308">        <span class="c1">#   C = Callable[[T], None]</span>
</span><span id="1-1309">        <span class="c1">#   C[int]  # Invokes _GenericAlias.__getitem__</span>
</span><span id="1-1310">
</span><span id="1-1311">        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__origin__</span> <span class="ow">in</span> <span class="p">(</span><span class="n">Generic</span><span class="p">,</span> <span class="n">Protocol</span><span class="p">):</span>
</span><span id="1-1312">            <span class="c1"># Can&#39;t subscript Generic[...] or Protocol[...].</span>
</span><span id="1-1313">            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Cannot subscript already-subscripted </span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</span><span id="1-1314">        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">__parameters__</span><span class="p">:</span>
</span><span id="1-1315">            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s2"> is not a generic class&quot;</span><span class="p">)</span>
</span><span id="1-1316">
</span><span id="1-1317">        <span class="c1"># Preprocess `args`.</span>
</span><span id="1-1318">        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
</span><span id="1-1319">            <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="n">args</span><span class="p">,)</span>
</span><span id="1-1320">        <span class="n">args</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">_type_convert</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">args</span><span class="p">)</span>
</span><span id="1-1321">        <span class="n">args</span> <span class="o">=</span> <span class="n">_unpack_args</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
</span><span id="1-1322">        <span class="n">new_args</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_determine_new_args</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
</span><span id="1-1323">        <span class="n">r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy_with</span><span class="p">(</span><span class="n">new_args</span><span class="p">)</span>
</span><span id="1-1324">        <span class="k">return</span> <span class="n">r</span>
</span><span id="1-1325">
</span><span id="1-1326">    <span class="k">def</span><span class="w"> </span><span class="nf">_determine_new_args</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
</span><span id="1-1327">        <span class="c1"># Determines new __args__ for __getitem__.</span>
</span><span id="1-1328">        <span class="c1">#</span>
</span><span id="1-1329">        <span class="c1"># For example, suppose we had:</span>
</span><span id="1-1330">        <span class="c1">#   T1 = TypeVar(&#39;T1&#39;)</span>
</span><span id="1-1331">        <span class="c1">#   T2 = TypeVar(&#39;T2&#39;)</span>
</span><span id="1-1332">        <span class="c1">#   class A(Generic[T1, T2]): pass</span>
</span><span id="1-1333">        <span class="c1">#   T3 = TypeVar(&#39;T3&#39;)</span>
</span><span id="1-1334">        <span class="c1">#   B = A[int, T3]</span>
</span><span id="1-1335">        <span class="c1">#   C = B[str]</span>
</span><span id="1-1336">        <span class="c1"># `B.__args__` is `(int, T3)`, so `C.__args__` should be `(int, str)`.</span>
</span><span id="1-1337">        <span class="c1"># Unfortunately, this is harder than it looks, because if `T3` is</span>
</span><span id="1-1338">        <span class="c1"># anything more exotic than a plain `TypeVar`, we need to consider</span>
</span><span id="1-1339">        <span class="c1"># edge cases.</span>
</span><span id="1-1340">
</span><span id="1-1341">        <span class="n">params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__parameters__</span>
</span><span id="1-1342">        <span class="c1"># In the example above, this would be {T3: str}</span>
</span><span id="1-1343">        <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="n">params</span><span class="p">:</span>
</span><span id="1-1344">            <span class="n">prepare</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">param</span><span class="p">,</span> <span class="s1">&#39;__typing_prepare_subst__&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
</span><span id="1-1345">            <span class="k">if</span> <span class="n">prepare</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
</span><span id="1-1346">                <span class="n">args</span> <span class="o">=</span> <span class="n">prepare</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span>
</span><span id="1-1347">        <span class="n">alen</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
</span><span id="1-1348">        <span class="n">plen</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
</span><span id="1-1349">        <span class="k">if</span> <span class="n">alen</span> <span class="o">!=</span> <span class="n">plen</span><span class="p">:</span>
</span><span id="1-1350">            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Too </span><span class="si">{</span><span class="s1">&#39;many&#39;</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">alen</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">plen</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="s1">&#39;few&#39;</span><span class="si">}</span><span class="s2"> arguments for </span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s2">;&quot;</span>
</span><span id="1-1351">                            <span class="sa">f</span><span class="s2">&quot; actual </span><span class="si">{</span><span class="n">alen</span><span class="si">}</span><span class="s2">, expected </span><span class="si">{</span><span class="n">plen</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</span><span id="1-1352">        <span class="n">new_arg_by_param</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">args</span><span class="p">))</span>
</span><span id="1-1353">        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_make_substitution</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__args__</span><span class="p">,</span> <span class="n">new_arg_by_param</span><span class="p">))</span>
</span><span id="1-1354">
</span><span id="1-1355">    <span class="k">def</span><span class="w"> </span><span class="nf">_make_substitution</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">new_arg_by_param</span><span class="p">):</span>
</span><span id="1-1356"><span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a list of new type arguments.&quot;&quot;&quot;</span>
</span><span id="1-1357">        <span class="n">new_args</span> <span class="o">=</span> <span class="p">[]</span>
</span><span id="1-1358">        <span class="k">for</span> <span class="n">old_arg</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
</span><span id="1-1359">            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">old_arg</span><span class="p">,</span> <span class="nb">type</span><span class="p">):</span>
</span><span id="1-1360">                <span class="n">new_args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">old_arg</span><span class="p">)</span>
</span><span id="1-1361">                <span class="k">continue</span>
</span><span id="1-1362">
</span><span id="1-1363">            <span class="n">substfunc</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">old_arg</span><span class="p">,</span> <span class="s1">&#39;__typing_subst__&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
</span><span id="1-1364">            <span class="k">if</span> <span class="n">substfunc</span><span class="p">:</span>
</span><span id="1-1365">                <span class="n">new_arg</span> <span class="o">=</span> <span class="n">substfunc</span><span class="p">(</span><span class="n">new_arg_by_param</span><span class="p">[</span><span class="n">old_arg</span><span class="p">])</span>
</span><span id="1-1366">            <span class="k">else</span><span class="p">:</span>
</span><span id="1-1367">                <span class="n">subparams</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">old_arg</span><span class="p">,</span> <span class="s1">&#39;__parameters__&#39;</span><span class="p">,</span> <span class="p">())</span>
</span><span id="1-1368">                <span class="k">if</span> <span class="ow">not</span> <span class="n">subparams</span><span class="p">:</span>
</span><span id="1-1369">                    <span class="n">new_arg</span> <span class="o">=</span> <span class="n">old_arg</span>
</span><span id="1-1370">                <span class="k">else</span><span class="p">:</span>
</span><span id="1-1371">                    <span class="n">subargs</span> <span class="o">=</span> <span class="p">[]</span>
</span><span id="1-1372">                    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">subparams</span><span class="p">:</span>
</span><span id="1-1373">                        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">TypeVarTuple</span><span class="p">):</span>
</span><span id="1-1374">                            <span class="n">subargs</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">new_arg_by_param</span><span class="p">[</span><span class="n">x</span><span class="p">])</span>
</span><span id="1-1375">                        <span class="k">else</span><span class="p">:</span>
</span><span id="1-1376">                            <span class="n">subargs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_arg_by_param</span><span class="p">[</span><span class="n">x</span><span class="p">])</span>
</span><span id="1-1377">                    <span class="n">new_arg</span> <span class="o">=</span> <span class="n">old_arg</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">subargs</span><span class="p">)]</span>
</span><span id="1-1378">
</span><span id="1-1379">            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__origin__</span> <span class="o">==</span> <span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">Callable</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">new_arg</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
</span><span id="1-1380">                <span class="c1"># Consider the following `Callable`.</span>
</span><span id="1-1381">                <span class="c1">#   C = Callable[[int], str]</span>
</span><span id="1-1382">                <span class="c1"># Here, `C.__args__` should be (int, str) - NOT ([int], str).</span>
</span><span id="1-1383">                <span class="c1"># That means that if we had something like...</span>
</span><span id="1-1384">                <span class="c1">#   P = ParamSpec(&#39;P&#39;)</span>
</span><span id="1-1385">                <span class="c1">#   T = TypeVar(&#39;T&#39;)</span>
</span><span id="1-1386">                <span class="c1">#   C = Callable[P, T]</span>
</span><span id="1-1387">                <span class="c1">#   D = C[[int, str], float]</span>
</span><span id="1-1388">                <span class="c1"># ...we need to be careful; `new_args` should end up as</span>
</span><span id="1-1389">                <span class="c1"># `(int, str, float)` rather than `([int, str], float)`.</span>
</span><span id="1-1390">                <span class="n">new_args</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">new_arg</span><span class="p">)</span>
</span><span id="1-1391">            <span class="k">elif</span> <span class="n">_is_unpacked_typevartuple</span><span class="p">(</span><span class="n">old_arg</span><span class="p">):</span>
</span><span id="1-1392">                <span class="c1"># Consider the following `_GenericAlias`, `B`:</span>
</span><span id="1-1393">                <span class="c1">#   class A(Generic[*Ts]): ...</span>
</span><span id="1-1394">                <span class="c1">#   B = A[T, *Ts]</span>
</span><span id="1-1395">                <span class="c1"># If we then do:</span>
</span><span id="1-1396">                <span class="c1">#   B[float, int, str]</span>
</span><span id="1-1397">                <span class="c1"># The `new_arg` corresponding to `T` will be `float`, and the</span>
</span><span id="1-1398">                <span class="c1"># `new_arg` corresponding to `*Ts` will be `(int, str)`. We</span>
</span><span id="1-1399">                <span class="c1"># should join all these types together in a flat list</span>
</span><span id="1-1400">                <span class="c1"># `(float, int, str)` - so again, we should `extend`.</span>
</span><span id="1-1401">                <span class="n">new_args</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">new_arg</span><span class="p">)</span>
</span><span id="1-1402">            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">old_arg</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
</span><span id="1-1403">                <span class="c1"># Corner case:</span>
</span><span id="1-1404">                <span class="c1">#    P = ParamSpec(&#39;P&#39;)</span>
</span><span id="1-1405">                <span class="c1">#    T = TypeVar(&#39;T&#39;)</span>
</span><span id="1-1406">                <span class="c1">#    class Base(Generic[P]): ...</span>
</span><span id="1-1407">                <span class="c1"># Can be substituted like this:</span>
</span><span id="1-1408">                <span class="c1">#    X = Base[[int, T]]</span>
</span><span id="1-1409">                <span class="c1"># In this case, `old_arg` will be a tuple:</span>
</span><span id="1-1410">                <span class="n">new_args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
</span><span id="1-1411">                    <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_make_substitution</span><span class="p">(</span><span class="n">old_arg</span><span class="p">,</span> <span class="n">new_arg_by_param</span><span class="p">)),</span>
</span><span id="1-1412">                <span class="p">)</span>
</span><span id="1-1413">            <span class="k">else</span><span class="p">:</span>
</span><span id="1-1414">                <span class="n">new_args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_arg</span><span class="p">)</span>
</span><span id="1-1415">        <span class="k">return</span> <span class="n">new_args</span>
</span><span id="1-1416">
</span><span id="1-1417">    <span class="k">def</span><span class="w"> </span><span class="nf">copy_with</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
</span><span id="1-1418">        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__origin__</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_name</span><span class="p">,</span> <span class="n">inst</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_inst</span><span class="p">)</span>
</span><span id="1-1419">
</span><span id="1-1420">    <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span id="1-1421">        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name</span><span class="p">:</span>
</span><span id="1-1422">            <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;typing.&#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name</span>
</span><span id="1-1423">        <span class="k">else</span><span class="p">:</span>
</span><span id="1-1424">            <span class="n">name</span> <span class="o">=</span> <span class="n">_type_repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__origin__</span><span class="p">)</span>
</span><span id="1-1425">        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__args__</span><span class="p">:</span>
</span><span id="1-1426">            <span class="n">args</span> <span class="o">=</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">_type_repr</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__args__</span><span class="p">])</span>
</span><span id="1-1427">        <span class="k">else</span><span class="p">:</span>
</span><span id="1-1428">            <span class="c1"># To ensure the repr is eval-able.</span>
</span><span id="1-1429">            <span class="n">args</span> <span class="o">=</span> <span class="s2">&quot;()&quot;</span>
</span><span id="1-1430">        <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s1">[</span><span class="si">{</span><span class="n">args</span><span class="si">}</span><span class="s1">]&#39;</span>
</span><span id="1-1431">
</span><span id="1-1432">    <span class="k">def</span><span class="w"> </span><span class="nf">__reduce__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span id="1-1433">        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name</span><span class="p">:</span>
</span><span id="1-1434">            <span class="n">origin</span> <span class="o">=</span> <span class="nb">globals</span><span class="p">()[</span><span class="bp">self</span><span class="o">.</span><span class="n">_name</span><span class="p">]</span>
</span><span id="1-1435">        <span class="k">else</span><span class="p">:</span>
</span><span id="1-1436">            <span class="n">origin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__origin__</span>
</span><span id="1-1437">        <span class="n">args</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__args__</span><span class="p">)</span>
</span><span id="1-1438">        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">tuple</span><span class="p">):</span>
</span><span id="1-1439">            <span class="n">args</span><span class="p">,</span> <span class="o">=</span> <span class="n">args</span>
</span><span id="1-1440">        <span class="k">return</span> <span class="n">operator</span><span class="o">.</span><span class="n">getitem</span><span class="p">,</span> <span class="p">(</span><span class="n">origin</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span>
</span><span id="1-1441">
</span><span id="1-1442">    <span class="k">def</span><span class="w"> </span><span class="nf">__mro_entries__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bases</span><span class="p">):</span>
</span><span id="1-1443">        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__origin__</span><span class="p">,</span> <span class="n">_SpecialForm</span><span class="p">):</span>
</span><span id="1-1444">            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Cannot subclass </span><span class="si">{</span><span class="bp">self</span><span class="si">!r}</span><span class="s2">&quot;</span><span class="p">)</span>
</span><span id="1-1445">
</span><span id="1-1446">        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name</span><span class="p">:</span>  <span class="c1"># generic version of an ABC or built-in class</span>
</span><span id="1-1447">            <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__mro_entries__</span><span class="p">(</span><span class="n">bases</span><span class="p">)</span>
</span><span id="1-1448">        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__origin__</span> <span class="ow">is</span> <span class="n">Generic</span><span class="p">:</span>
</span><span id="1-1449">            <span class="k">if</span> <span class="n">Protocol</span> <span class="ow">in</span> <span class="n">bases</span><span class="p">:</span>
</span><span id="1-1450">                <span class="k">return</span> <span class="p">()</span>
</span><span id="1-1451">            <span class="n">i</span> <span class="o">=</span> <span class="n">bases</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</span><span id="1-1452">            <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">bases</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">:]:</span>
</span><span id="1-1453">                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">_BaseGenericAlias</span><span class="p">)</span> <span class="ow">and</span> <span class="n">b</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">self</span><span class="p">:</span>
</span><span id="1-1454">                    <span class="k">return</span> <span class="p">()</span>
</span><span id="1-1455">        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__origin__</span><span class="p">,)</span>
</span><span id="1-1456">
</span><span id="1-1457">    <span class="k">def</span><span class="w"> </span><span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span id="1-1458">        <span class="k">yield</span> <span class="n">Unpack</span><span class="p">[</span><span class="bp">self</span><span class="p">]</span>
</span><span id="1-1459">
</span><span id="1-1460">
</span><span id="1-1461"><span class="c1"># _nparams is the number of accepted parameters, e.g. 0 for Hashable,</span>
</span><span id="1-1462"><span class="c1"># 1 for List and 2 for Dict.  It may be -1 if variable number of</span>
</span><span id="1-1463"><span class="c1"># parameters are accepted (needs custom __getitem__).</span>
</span><span id="1-1464">
</span><span id="1-1465"><span class="k">class</span><span class="w"> </span><span class="nc">_SpecialGenericAlias</span><span class="p">(</span><span class="n">_NotIterable</span><span class="p">,</span> <span class="n">_BaseGenericAlias</span><span class="p">,</span> <span class="n">_root</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
</span><span id="1-1466">    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">origin</span><span class="p">,</span> <span class="n">nparams</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">inst</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
</span><span id="1-1467">        <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
</span><span id="1-1468">            <span class="n">name</span> <span class="o">=</span> <span class="n">origin</span><span class="o">.</span><span class="vm">__name__</span>
</span><span id="1-1469">        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">origin</span><span class="p">,</span> <span class="n">inst</span><span class="o">=</span><span class="n">inst</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>
</span><span id="1-1470">        <span class="bp">self</span><span class="o">.</span><span class="n">_nparams</span> <span class="o">=</span> <span class="n">nparams</span>
</span><span id="1-1471">        <span class="k">if</span> <span class="n">origin</span><span class="o">.</span><span class="vm">__module__</span> <span class="o">==</span> <span class="s1">&#39;builtins&#39;</span><span class="p">:</span>
</span><span id="1-1472">            <span class="bp">self</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;A generic version of </span><span class="si">{</span><span class="n">origin</span><span class="o">.</span><span class="vm">__qualname__</span><span class="si">}</span><span class="s1">.&#39;</span>
</span><span id="1-1473">        <span class="k">else</span><span class="p">:</span>
</span><span id="1-1474">            <span class="bp">self</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;A generic version of </span><span class="si">{</span><span class="n">origin</span><span class="o">.</span><span class="vm">__module__</span><span class="si">}</span><span class="s1">.</span><span class="si">{</span><span class="n">origin</span><span class="o">.</span><span class="vm">__qualname__</span><span class="si">}</span><span class="s1">.&#39;</span>
</span><span id="1-1475">
</span><span id="1-1476">    <span class="nd">@_tp_cache</span>
</span><span id="1-1477">    <span class="k">def</span><span class="w"> </span><span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
</span><span id="1-1478">        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
</span><span id="1-1479">            <span class="n">params</span> <span class="o">=</span> <span class="p">(</span><span class="n">params</span><span class="p">,)</span>
</span><span id="1-1480">        <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Parameters to generic types must be types.&quot;</span>
</span><span id="1-1481">        <span class="n">params</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">_type_check</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">params</span><span class="p">)</span>
</span><span id="1-1482">        <span class="n">_check_generic</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nparams</span><span class="p">)</span>
</span><span id="1-1483">        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy_with</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
</span><span id="1-1484">
</span><span id="1-1485">    <span class="k">def</span><span class="w"> </span><span class="nf">copy_with</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
</span><span id="1-1486">        <span class="k">return</span> <span class="n">_GenericAlias</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__origin__</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span>
</span><span id="1-1487">                             <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_name</span><span class="p">,</span> <span class="n">inst</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_inst</span><span class="p">)</span>
</span><span id="1-1488">
</span><span id="1-1489">    <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span id="1-1490">        <span class="k">return</span> <span class="s1">&#39;typing.&#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name</span>
</span><span id="1-1491">
</span><span id="1-1492">    <span class="k">def</span><span class="w"> </span><span class="fm">__subclasscheck__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">cls</span><span class="p">):</span>
</span><span id="1-1493">        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">_SpecialGenericAlias</span><span class="p">):</span>
</span><span id="1-1494">            <span class="k">return</span> <span class="nb">issubclass</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="n">__origin__</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__origin__</span><span class="p">)</span>
</span><span id="1-1495">        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">_GenericAlias</span><span class="p">):</span>
</span><span id="1-1496">            <span class="k">return</span> <span class="nb">issubclass</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__origin__</span><span class="p">)</span>
</span><span id="1-1497">        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__subclasscheck__</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>
</span><span id="1-1498">
</span><span id="1-1499">    <span class="k">def</span><span class="w"> </span><span class="nf">__reduce__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span id="1-1500">        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name</span>
</span><span id="1-1501">
</span><span id="1-1502">    <span class="k">def</span><span class="w"> </span><span class="fm">__or__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">right</span><span class="p">):</span>
</span><span id="1-1503">        <span class="k">return</span> <span class="n">Union</span><span class="p">[</span><span class="bp">self</span><span class="p">,</span> <span class="n">right</span><span class="p">]</span>
</span><span id="1-1504">
</span><span id="1-1505">    <span class="k">def</span><span class="w"> </span><span class="fm">__ror__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">left</span><span class="p">):</span>
</span><span id="1-1506">        <span class="k">return</span> <span class="n">Union</span><span class="p">[</span><span class="n">left</span><span class="p">,</span> <span class="bp">self</span><span class="p">]</span>
</span><span id="1-1507">
</span><span id="1-1508">
</span><span id="1-1509"><span class="k">class</span><span class="w"> </span><span class="nc">_DeprecatedGenericAlias</span><span class="p">(</span><span class="n">_SpecialGenericAlias</span><span class="p">,</span> <span class="n">_root</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
</span><span id="1-1510">    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
</span><span id="1-1511">        <span class="bp">self</span><span class="p">,</span> <span class="n">origin</span><span class="p">,</span> <span class="n">nparams</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">removal_version</span><span class="p">,</span> <span class="n">inst</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span>
</span><span id="1-1512">    <span class="p">):</span>
</span><span id="1-1513">        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">origin</span><span class="p">,</span> <span class="n">nparams</span><span class="p">,</span> <span class="n">inst</span><span class="o">=</span><span class="n">inst</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>
</span><span id="1-1514">        <span class="bp">self</span><span class="o">.</span><span class="n">_removal_version</span> <span class="o">=</span> <span class="n">removal_version</span>
</span><span id="1-1515">
</span><span id="1-1516">    <span class="k">def</span><span class="w"> </span><span class="fm">__instancecheck__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inst</span><span class="p">):</span>
</span><span id="1-1517">        <span class="kn">import</span><span class="w"> </span><span class="nn">warnings</span>
</span><span id="1-1518">        <span class="n">warnings</span><span class="o">.</span><span class="n">_deprecated</span><span class="p">(</span>
</span><span id="1-1519">            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__module__</span><span class="si">}</span><span class="s2">.</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">remove</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_removal_version</span>
</span><span id="1-1520">        <span class="p">)</span>
</span><span id="1-1521">        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__instancecheck__</span><span class="p">(</span><span class="n">inst</span><span class="p">)</span>
</span><span id="1-1522">
</span><span id="1-1523">
</span><span id="1-1524"><span class="k">class</span><span class="w"> </span><span class="nc">_CallableGenericAlias</span><span class="p">(</span><span class="n">_NotIterable</span><span class="p">,</span> <span class="n">_GenericAlias</span><span class="p">,</span> <span class="n">_root</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
</span><span id="1-1525">    <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span id="1-1526">        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name</span> <span class="o">==</span> <span class="s1">&#39;Callable&#39;</span>
</span><span id="1-1527">        <span class="n">args</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__args__</span>
</span><span id="1-1528">        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">_is_param_expr</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
</span><span id="1-1529">            <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__repr__</span><span class="p">()</span>
</span><span id="1-1530">        <span class="k">return</span> <span class="p">(</span><span class="sa">f</span><span class="s1">&#39;typing.Callable&#39;</span>
</span><span id="1-1531">                <span class="sa">f</span><span class="s1">&#39;[[</span><span class="si">{</span><span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">_type_repr</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">args</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span><span class="si">}</span><span class="s1">], &#39;</span>
</span><span id="1-1532">                <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">_type_repr</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="si">}</span><span class="s1">]&#39;</span><span class="p">)</span>
</span><span id="1-1533">
</span><span id="1-1534">    <span class="k">def</span><span class="w"> </span><span class="nf">__reduce__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span id="1-1535">        <span class="n">args</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__args__</span>
</span><span id="1-1536">        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">_is_param_expr</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">])):</span>
</span><span id="1-1537">            <span class="n">args</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">args</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span> <span class="n">args</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</span><span id="1-1538">        <span class="k">return</span> <span class="n">operator</span><span class="o">.</span><span class="n">getitem</span><span class="p">,</span> <span class="p">(</span><span class="n">Callable</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span>
</span><span id="1-1539">
</span><span id="1-1540">
</span><span id="1-1541"><span class="k">class</span><span class="w"> </span><span class="nc">_CallableType</span><span class="p">(</span><span class="n">_SpecialGenericAlias</span><span class="p">,</span> <span class="n">_root</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
</span><span id="1-1542">    <span class="k">def</span><span class="w"> </span><span class="nf">copy_with</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
</span><span id="1-1543">        <span class="k">return</span> <span class="n">_CallableGenericAlias</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__origin__</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span>
</span><span id="1-1544">                                     <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_name</span><span class="p">,</span> <span class="n">inst</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_inst</span><span class="p">)</span>
</span><span id="1-1545">
</span><span id="1-1546">    <span class="k">def</span><span class="w"> </span><span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
</span><span id="1-1547">        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">params</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
</span><span id="1-1548">            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Callable must be used as &quot;</span>
</span><span id="1-1549">                            <span class="s2">&quot;Callable[[arg, ...], result].&quot;</span><span class="p">)</span>
</span><span id="1-1550">        <span class="n">args</span><span class="p">,</span> <span class="n">result</span> <span class="o">=</span> <span class="n">params</span>
</span><span id="1-1551">        <span class="c1"># This relaxes what args can be on purpose to allow things like</span>
</span><span id="1-1552">        <span class="c1"># PEP 612 ParamSpec.  Responsibility for whether a user is using</span>
</span><span id="1-1553">        <span class="c1"># Callable[...] properly is deferred to static type checkers.</span>
</span><span id="1-1554">        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
</span><span id="1-1555">            <span class="n">params</span> <span class="o">=</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">args</span><span class="p">),</span> <span class="n">result</span><span class="p">)</span>
</span><span id="1-1556">        <span class="k">else</span><span class="p">:</span>
</span><span id="1-1557">            <span class="n">params</span> <span class="o">=</span> <span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span>
</span><span id="1-1558">        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__getitem_inner__</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
</span><span id="1-1559">
</span><span id="1-1560">    <span class="nd">@_tp_cache</span>
</span><span id="1-1561">    <span class="k">def</span><span class="w"> </span><span class="nf">__getitem_inner__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
</span><span id="1-1562">        <span class="n">args</span><span class="p">,</span> <span class="n">result</span> <span class="o">=</span> <span class="n">params</span>
</span><span id="1-1563">        <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Callable[args, result]: result must be a type.&quot;</span>
</span><span id="1-1564">        <span class="n">result</span> <span class="o">=</span> <span class="n">_type_check</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span>
</span><span id="1-1565">        <span class="k">if</span> <span class="n">args</span> <span class="ow">is</span> <span class="bp">Ellipsis</span><span class="p">:</span>
</span><span id="1-1566">            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy_with</span><span class="p">((</span><span class="n">_TypingEllipsis</span><span class="p">,</span> <span class="n">result</span><span class="p">))</span>
</span><span id="1-1567">        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
</span><span id="1-1568">            <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="n">args</span><span class="p">,)</span>
</span><span id="1-1569">        <span class="n">args</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">_type_convert</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">args</span><span class="p">)</span>
</span><span id="1-1570">        <span class="n">params</span> <span class="o">=</span> <span class="n">args</span> <span class="o">+</span> <span class="p">(</span><span class="n">result</span><span class="p">,)</span>
</span><span id="1-1571">        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy_with</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
</span><span id="1-1572">
</span><span id="1-1573">
</span><span id="1-1574"><span class="k">class</span><span class="w"> </span><span class="nc">_TupleType</span><span class="p">(</span><span class="n">_SpecialGenericAlias</span><span class="p">,</span> <span class="n">_root</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
</span><span id="1-1575">    <span class="nd">@_tp_cache</span>
</span><span id="1-1576">    <span class="k">def</span><span class="w"> </span><span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
</span><span id="1-1577">        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
</span><span id="1-1578">            <span class="n">params</span> <span class="o">=</span> <span class="p">(</span><span class="n">params</span><span class="p">,)</span>
</span><span id="1-1579">        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">params</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">params</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="o">...</span><span class="p">:</span>
</span><span id="1-1580">            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Tuple[t, ...]: t must be a type.&quot;</span>
</span><span id="1-1581">            <span class="n">params</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">_type_check</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">params</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
</span><span id="1-1582">            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy_with</span><span class="p">((</span><span class="o">*</span><span class="n">params</span><span class="p">,</span> <span class="n">_TypingEllipsis</span><span class="p">))</span>
</span><span id="1-1583">        <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Tuple[t0, t1, ...]: each t must be a type.&quot;</span>
</span><span id="1-1584">        <span class="n">params</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">_type_check</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">params</span><span class="p">)</span>
</span><span id="1-1585">        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy_with</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
</span><span id="1-1586">
</span><span id="1-1587">
</span><span id="1-1588"><span class="k">class</span><span class="w"> </span><span class="nc">_UnionGenericAlias</span><span class="p">(</span><span class="n">_NotIterable</span><span class="p">,</span> <span class="n">_GenericAlias</span><span class="p">,</span> <span class="n">_root</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
</span><span id="1-1589">    <span class="k">def</span><span class="w"> </span><span class="nf">copy_with</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
</span><span id="1-1590">        <span class="k">return</span> <span class="n">Union</span><span class="p">[</span><span class="n">params</span><span class="p">]</span>
</span><span id="1-1591">
</span><span id="1-1592">    <span class="k">def</span><span class="w"> </span><span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
</span><span id="1-1593">        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="p">(</span><span class="n">_UnionGenericAlias</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">UnionType</span><span class="p">)):</span>
</span><span id="1-1594">            <span class="k">return</span> <span class="bp">NotImplemented</span>
</span><span id="1-1595">        <span class="k">try</span><span class="p">:</span>  <span class="c1"># fast path</span>
</span><span id="1-1596">            <span class="k">return</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__args__</span><span class="p">)</span> <span class="o">==</span> <span class="nb">set</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">__args__</span><span class="p">)</span>
</span><span id="1-1597">        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>  <span class="c1"># not hashable, slow path</span>
</span><span id="1-1598">            <span class="k">return</span> <span class="n">_compare_args_orderless</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__args__</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">__args__</span><span class="p">)</span>
</span><span id="1-1599">
</span><span id="1-1600">    <span class="k">def</span><span class="w"> </span><span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span id="1-1601">        <span class="k">return</span> <span class="nb">hash</span><span class="p">(</span><span class="nb">frozenset</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__args__</span><span class="p">))</span>
</span><span id="1-1602">
</span><span id="1-1603">    <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span id="1-1604">        <span class="n">args</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__args__</span>
</span><span id="1-1605">        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
</span><span id="1-1606">            <span class="k">if</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="nb">type</span><span class="p">(</span><span class="kc">None</span><span class="p">):</span>
</span><span id="1-1607">                <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;typing.Optional[</span><span class="si">{</span><span class="n">_type_repr</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="si">}</span><span class="s1">]&#39;</span>
</span><span id="1-1608">            <span class="k">elif</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="nb">type</span><span class="p">(</span><span class="kc">None</span><span class="p">):</span>
</span><span id="1-1609">                <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;typing.Optional[</span><span class="si">{</span><span class="n">_type_repr</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="si">}</span><span class="s1">]&#39;</span>
</span><span id="1-1610">        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__repr__</span><span class="p">()</span>
</span><span id="1-1611">
</span><span id="1-1612">    <span class="k">def</span><span class="w"> </span><span class="fm">__instancecheck__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
</span><span id="1-1613">        <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__args__</span><span class="p">:</span>
</span><span id="1-1614">            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">arg</span><span class="p">):</span>
</span><span id="1-1615">                <span class="k">return</span> <span class="kc">True</span>
</span><span id="1-1616">        <span class="k">return</span> <span class="kc">False</span>
</span><span id="1-1617">
</span><span id="1-1618">    <span class="k">def</span><span class="w"> </span><span class="fm">__subclasscheck__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">cls</span><span class="p">):</span>
</span><span id="1-1619">        <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__args__</span><span class="p">:</span>
</span><span id="1-1620">            <span class="k">if</span> <span class="nb">issubclass</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">arg</span><span class="p">):</span>
</span><span id="1-1621">                <span class="k">return</span> <span class="kc">True</span>
</span><span id="1-1622">        <span class="k">return</span> <span class="kc">False</span>
</span><span id="1-1623">
</span><span id="1-1624">    <span class="k">def</span><span class="w"> </span><span class="nf">__reduce__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span id="1-1625">        <span class="n">func</span><span class="p">,</span> <span class="p">(</span><span class="n">origin</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__reduce__</span><span class="p">()</span>
</span><span id="1-1626">        <span class="k">return</span> <span class="n">func</span><span class="p">,</span> <span class="p">(</span><span class="n">Union</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span>
</span><span id="1-1627">
</span><span id="1-1628">
</span><span id="1-1629"><span class="k">def</span><span class="w"> </span><span class="nf">_value_and_type_iter</span><span class="p">(</span><span class="n">parameters</span><span class="p">):</span>
</span><span id="1-1630">    <span class="k">return</span> <span class="p">((</span><span class="n">p</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">parameters</span><span class="p">)</span>
</span><span id="1-1631">
</span><span id="1-1632">
</span><span id="1-1633"><span class="k">class</span><span class="w"> </span><span class="nc">_LiteralGenericAlias</span><span class="p">(</span><span class="n">_GenericAlias</span><span class="p">,</span> <span class="n">_root</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
</span><span id="1-1634">    <span class="k">def</span><span class="w"> </span><span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
</span><span id="1-1635">        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">_LiteralGenericAlias</span><span class="p">):</span>
</span><span id="1-1636">            <span class="k">return</span> <span class="bp">NotImplemented</span>
</span><span id="1-1637">
</span><span id="1-1638">        <span class="k">return</span> <span class="nb">set</span><span class="p">(</span><span class="n">_value_and_type_iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__args__</span><span class="p">))</span> <span class="o">==</span> <span class="nb">set</span><span class="p">(</span><span class="n">_value_and_type_iter</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">__args__</span><span class="p">))</span>
</span><span id="1-1639">
</span><span id="1-1640">    <span class="k">def</span><span class="w"> </span><span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span id="1-1641">        <span class="k">return</span> <span class="nb">hash</span><span class="p">(</span><span class="nb">frozenset</span><span class="p">(</span><span class="n">_value_and_type_iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__args__</span><span class="p">)))</span>
</span><span id="1-1642">
</span><span id="1-1643">
</span><span id="1-1644"><span class="k">class</span><span class="w"> </span><span class="nc">_ConcatenateGenericAlias</span><span class="p">(</span><span class="n">_GenericAlias</span><span class="p">,</span> <span class="n">_root</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
</span><span id="1-1645">    <span class="k">def</span><span class="w"> </span><span class="nf">copy_with</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
</span><span id="1-1646">        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
</span><span id="1-1647">            <span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="n">params</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="o">*</span><span class="n">params</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
</span><span id="1-1648">        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">_ConcatenateGenericAlias</span><span class="p">):</span>
</span><span id="1-1649">            <span class="n">params</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">params</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="o">*</span><span class="n">params</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">__args__</span><span class="p">)</span>
</span><span id="1-1650">        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">copy_with</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
</span><span id="1-1651">
</span><span id="1-1652">
</span><span id="1-1653"><span class="nd">@_SpecialForm</span>
</span><span id="1-1654"><span class="k">def</span><span class="w"> </span><span class="nf">Unpack</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parameters</span><span class="p">):</span>
</span><span id="1-1655"><span class="w">    </span><span class="sd">&quot;&quot;&quot;Type unpack operator.</span>
</span><span id="1-1656">
</span><span id="1-1657"><span class="sd">    The type unpack operator takes the child types from some container type,</span>
</span><span id="1-1658"><span class="sd">    such as `tuple[int, str]` or a `TypeVarTuple`, and &#39;pulls them out&#39;.</span>
</span><span id="1-1659">
</span><span id="1-1660"><span class="sd">    For example::</span>
</span><span id="1-1661">
</span><span id="1-1662"><span class="sd">        # For some generic class `Foo`:</span>
</span><span id="1-1663"><span class="sd">        Foo[Unpack[tuple[int, str]]]  # Equivalent to Foo[int, str]</span>
</span><span id="1-1664">
</span><span id="1-1665"><span class="sd">        Ts = TypeVarTuple(&#39;Ts&#39;)</span>
</span><span id="1-1666"><span class="sd">        # Specifies that `Bar` is generic in an arbitrary number of types.</span>
</span><span id="1-1667"><span class="sd">        # (Think of `Ts` as a tuple of an arbitrary number of individual</span>
</span><span id="1-1668"><span class="sd">        #  `TypeVar`s, which the `Unpack` is &#39;pulling out&#39; directly into the</span>
</span><span id="1-1669"><span class="sd">        #  `Generic[]`.)</span>
</span><span id="1-1670"><span class="sd">        class Bar(Generic[Unpack[Ts]]): ...</span>
</span><span id="1-1671"><span class="sd">        Bar[int]  # Valid</span>
</span><span id="1-1672"><span class="sd">        Bar[int, str]  # Also valid</span>
</span><span id="1-1673">
</span><span id="1-1674"><span class="sd">    From Python 3.11, this can also be done using the `*` operator::</span>
</span><span id="1-1675">
</span><span id="1-1676"><span class="sd">        Foo[*tuple[int, str]]</span>
</span><span id="1-1677"><span class="sd">        class Bar(Generic[*Ts]): ...</span>
</span><span id="1-1678">
</span><span id="1-1679"><span class="sd">    And from Python 3.12, it can be done using built-in syntax for generics::</span>
</span><span id="1-1680">
</span><span id="1-1681"><span class="sd">        Foo[*tuple[int, str]]</span>
</span><span id="1-1682"><span class="sd">        class Bar[*Ts]: ...</span>
</span><span id="1-1683">
</span><span id="1-1684"><span class="sd">    The operator can also be used along with a `TypedDict` to annotate</span>
</span><span id="1-1685"><span class="sd">    `**kwargs` in a function signature::</span>
</span><span id="1-1686">
</span><span id="1-1687"><span class="sd">        class Movie(TypedDict):</span>
</span><span id="1-1688"><span class="sd">            name: str</span>
</span><span id="1-1689"><span class="sd">            year: int</span>
</span><span id="1-1690">
</span><span id="1-1691"><span class="sd">        # This function expects two keyword arguments - *name* of type `str` and</span>
</span><span id="1-1692"><span class="sd">        # *year* of type `int`.</span>
</span><span id="1-1693"><span class="sd">        def foo(**kwargs: Unpack[Movie]): ...</span>
</span><span id="1-1694">
</span><span id="1-1695"><span class="sd">    Note that there is only some runtime checking of this operator. Not</span>
</span><span id="1-1696"><span class="sd">    everything the runtime allows may be accepted by static type checkers.</span>
</span><span id="1-1697">
</span><span id="1-1698"><span class="sd">    For more information, see PEPs 646 and 692.</span>
</span><span id="1-1699"><span class="sd">    &quot;&quot;&quot;</span>
</span><span id="1-1700">    <span class="n">item</span> <span class="o">=</span> <span class="n">_type_check</span><span class="p">(</span><span class="n">parameters</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s1"> accepts only single type.&#39;</span><span class="p">)</span>
</span><span id="1-1701">    <span class="k">return</span> <span class="n">_UnpackGenericAlias</span><span class="p">(</span><span class="n">origin</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">item</span><span class="p">,))</span>
</span><span id="1-1702">
</span><span id="1-1703">
</span><span id="1-1704"><span class="k">class</span><span class="w"> </span><span class="nc">_UnpackGenericAlias</span><span class="p">(</span><span class="n">_GenericAlias</span><span class="p">,</span> <span class="n">_root</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
</span><span id="1-1705">    <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span id="1-1706">        <span class="c1"># `Unpack` only takes one argument, so __args__ should contain only</span>
</span><span id="1-1707">        <span class="c1"># a single item.</span>
</span><span id="1-1708">        <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;typing.Unpack[</span><span class="si">{</span><span class="n">_type_repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__args__</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="si">}</span><span class="s1">]&#39;</span>
</span><span id="1-1709">
</span><span id="1-1710">    <span class="k">def</span><span class="w"> </span><span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
</span><span id="1-1711">        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__typing_is_unpacked_typevartuple__</span><span class="p">:</span>
</span><span id="1-1712">            <span class="k">return</span> <span class="n">args</span>
</span><span id="1-1713">        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
</span><span id="1-1714">
</span><span id="1-1715">    <span class="nd">@property</span>
</span><span id="1-1716">    <span class="k">def</span><span class="w"> </span><span class="nf">__typing_unpacked_tuple_args__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span id="1-1717">        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">__origin__</span> <span class="ow">is</span> <span class="n">Unpack</span>
</span><span id="1-1718">        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__args__</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
</span><span id="1-1719">        <span class="n">arg</span><span class="p">,</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__args__</span>
</span><span id="1-1720">        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="p">(</span><span class="n">_GenericAlias</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">GenericAlias</span><span class="p">)):</span>
</span><span id="1-1721">            <span class="k">if</span> <span class="n">arg</span><span class="o">.</span><span class="n">__origin__</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">tuple</span><span class="p">:</span>
</span><span id="1-1722">                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Unpack[...] must be used with a tuple type&quot;</span><span class="p">)</span>
</span><span id="1-1723">            <span class="k">return</span> <span class="n">arg</span><span class="o">.</span><span class="n">__args__</span>
</span><span id="1-1724">        <span class="k">return</span> <span class="kc">None</span>
</span><span id="1-1725">
</span><span id="1-1726">    <span class="nd">@property</span>
</span><span id="1-1727">    <span class="k">def</span><span class="w"> </span><span class="nf">__typing_is_unpacked_typevartuple__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span id="1-1728">        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">__origin__</span> <span class="ow">is</span> <span class="n">Unpack</span>
</span><span id="1-1729">        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__args__</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
</span><span id="1-1730">        <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__args__</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">TypeVarTuple</span><span class="p">)</span>
</span><span id="1-1731">
</span><span id="1-1732">
</span><span id="1-1733"><span class="k">class</span><span class="w"> </span><span class="nc">_TypingEllipsis</span><span class="p">:</span>
</span><span id="1-1734"><span class="w">    </span><span class="sd">&quot;&quot;&quot;Internal placeholder for ... (ellipsis).&quot;&quot;&quot;</span>
</span><span id="1-1735">
</span><span id="1-1736">
</span><span id="1-1737"><span class="n">_TYPING_INTERNALS</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">({</span>
</span><span id="1-1738">    <span class="s1">&#39;__parameters__&#39;</span><span class="p">,</span> <span class="s1">&#39;__orig_bases__&#39;</span><span class="p">,</span>  <span class="s1">&#39;__orig_class__&#39;</span><span class="p">,</span>
</span><span id="1-1739">    <span class="s1">&#39;_is_protocol&#39;</span><span class="p">,</span> <span class="s1">&#39;_is_runtime_protocol&#39;</span><span class="p">,</span> <span class="s1">&#39;__protocol_attrs__&#39;</span><span class="p">,</span>
</span><span id="1-1740">    <span class="s1">&#39;__non_callable_proto_members__&#39;</span><span class="p">,</span> <span class="s1">&#39;__type_params__&#39;</span><span class="p">,</span>
</span><span id="1-1741"><span class="p">})</span>
</span><span id="1-1742">
</span><span id="1-1743"><span class="n">_SPECIAL_NAMES</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">({</span>
</span><span id="1-1744">    <span class="s1">&#39;__abstractmethods__&#39;</span><span class="p">,</span> <span class="s1">&#39;__annotations__&#39;</span><span class="p">,</span> <span class="s1">&#39;__dict__&#39;</span><span class="p">,</span> <span class="s1">&#39;__doc__&#39;</span><span class="p">,</span>
</span><span id="1-1745">    <span class="s1">&#39;__init__&#39;</span><span class="p">,</span> <span class="s1">&#39;__module__&#39;</span><span class="p">,</span> <span class="s1">&#39;__new__&#39;</span><span class="p">,</span> <span class="s1">&#39;__slots__&#39;</span><span class="p">,</span>
</span><span id="1-1746">    <span class="s1">&#39;__subclasshook__&#39;</span><span class="p">,</span> <span class="s1">&#39;__weakref__&#39;</span><span class="p">,</span> <span class="s1">&#39;__class_getitem__&#39;</span>
</span><span id="1-1747"><span class="p">})</span>
</span><span id="1-1748">
</span><span id="1-1749"><span class="c1"># These special attributes will be not collected as protocol members.</span>
</span><span id="1-1750"><span class="n">EXCLUDED_ATTRIBUTES</span> <span class="o">=</span> <span class="n">_TYPING_INTERNALS</span> <span class="o">|</span> <span class="n">_SPECIAL_NAMES</span> <span class="o">|</span> <span class="p">{</span><span class="s1">&#39;_MutableMapping__marker&#39;</span><span class="p">}</span>
</span><span id="1-1751">
</span><span id="1-1752">
</span><span id="1-1753"><span class="k">def</span><span class="w"> </span><span class="nf">_get_protocol_attrs</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
</span><span id="1-1754"><span class="w">    </span><span class="sd">&quot;&quot;&quot;Collect protocol members from a protocol class objects.</span>
</span><span id="1-1755">
</span><span id="1-1756"><span class="sd">    This includes names actually defined in the class dictionary, as well</span>
</span><span id="1-1757"><span class="sd">    as names that appear in annotations. Special names (above) are skipped.</span>
</span><span id="1-1758"><span class="sd">    &quot;&quot;&quot;</span>
</span><span id="1-1759">    <span class="n">attrs</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
</span><span id="1-1760">    <span class="k">for</span> <span class="n">base</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="vm">__mro__</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>  <span class="c1"># without object</span>
</span><span id="1-1761">        <span class="k">if</span> <span class="n">base</span><span class="o">.</span><span class="vm">__name__</span> <span class="ow">in</span> <span class="p">{</span><span class="s1">&#39;Protocol&#39;</span><span class="p">,</span> <span class="s1">&#39;Generic&#39;</span><span class="p">}:</span>
</span><span id="1-1762">            <span class="k">continue</span>
</span><span id="1-1763">        <span class="n">annotations</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="s1">&#39;__annotations__&#39;</span><span class="p">,</span> <span class="p">{})</span>
</span><span id="1-1764">        <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="p">(</span><span class="o">*</span><span class="n">base</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">,</span> <span class="o">*</span><span class="n">annotations</span><span class="p">):</span>
</span><span id="1-1765">            <span class="k">if</span> <span class="ow">not</span> <span class="n">attr</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;_abc_&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">attr</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">EXCLUDED_ATTRIBUTES</span><span class="p">:</span>
</span><span id="1-1766">                <span class="n">attrs</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">attr</span><span class="p">)</span>
</span><span id="1-1767">    <span class="k">return</span> <span class="n">attrs</span>
</span><span id="1-1768">
</span><span id="1-1769">
</span><span id="1-1770"><span class="k">def</span><span class="w"> </span><span class="nf">_no_init_or_replace_init</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
</span><span id="1-1771">    <span class="bp">cls</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</span><span id="1-1772">
</span><span id="1-1773">    <span class="k">if</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_is_protocol</span><span class="p">:</span>
</span><span id="1-1774">        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Protocols cannot be instantiated&#39;</span><span class="p">)</span>
</span><span id="1-1775">
</span><span id="1-1776">    <span class="c1"># Already using a custom `__init__`. No need to calculate correct</span>
</span><span id="1-1777">    <span class="c1"># `__init__` to call. This can lead to RecursionError. See bpo-45121.</span>
</span><span id="1-1778">    <span class="k">if</span> <span class="bp">cls</span><span class="o">.</span><span class="fm">__init__</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">_no_init_or_replace_init</span><span class="p">:</span>
</span><span id="1-1779">        <span class="k">return</span>
</span><span id="1-1780">
</span><span id="1-1781">    <span class="c1"># Initially, `__init__` of a protocol subclass is set to `_no_init_or_replace_init`.</span>
</span><span id="1-1782">    <span class="c1"># The first instantiation of the subclass will call `_no_init_or_replace_init` which</span>
</span><span id="1-1783">    <span class="c1"># searches for a proper new `__init__` in the MRO. The new `__init__`</span>
</span><span id="1-1784">    <span class="c1"># replaces the subclass&#39; old `__init__` (ie `_no_init_or_replace_init`). Subsequent</span>
</span><span id="1-1785">    <span class="c1"># instantiation of the protocol subclass will thus use the new</span>
</span><span id="1-1786">    <span class="c1"># `__init__` and no longer call `_no_init_or_replace_init`.</span>
</span><span id="1-1787">    <span class="k">for</span> <span class="n">base</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="vm">__mro__</span><span class="p">:</span>
</span><span id="1-1788">        <span class="n">init</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;__init__&#39;</span><span class="p">,</span> <span class="n">_no_init_or_replace_init</span><span class="p">)</span>
</span><span id="1-1789">        <span class="k">if</span> <span class="n">init</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">_no_init_or_replace_init</span><span class="p">:</span>
</span><span id="1-1790">            <span class="bp">cls</span><span class="o">.</span><span class="fm">__init__</span> <span class="o">=</span> <span class="n">init</span>
</span><span id="1-1791">            <span class="k">break</span>
</span><span id="1-1792">    <span class="k">else</span><span class="p">:</span>
</span><span id="1-1793">        <span class="c1"># should not happen</span>
</span><span id="1-1794">        <span class="bp">cls</span><span class="o">.</span><span class="fm">__init__</span> <span class="o">=</span> <span class="nb">object</span><span class="o">.</span><span class="fm">__init__</span>
</span><span id="1-1795">
</span><span id="1-1796">    <span class="bp">cls</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</span><span id="1-1797">
</span><span id="1-1798">
</span><span id="1-1799"><span class="k">def</span><span class="w"> </span><span class="nf">_caller</span><span class="p">(</span><span class="n">depth</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="s1">&#39;__main__&#39;</span><span class="p">):</span>
</span><span id="1-1800">    <span class="k">try</span><span class="p">:</span>
</span><span id="1-1801">        <span class="k">return</span> <span class="n">sys</span><span class="o">.</span><span class="n">_getframemodulename</span><span class="p">(</span><span class="n">depth</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">or</span> <span class="n">default</span>
</span><span id="1-1802">    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>  <span class="c1"># For platforms without _getframemodulename()</span>
</span><span id="1-1803">        <span class="k">pass</span>
</span><span id="1-1804">    <span class="k">try</span><span class="p">:</span>
</span><span id="1-1805">        <span class="k">return</span> <span class="n">sys</span><span class="o">.</span><span class="n">_getframe</span><span class="p">(</span><span class="n">depth</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">f_globals</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;__name__&#39;</span><span class="p">,</span> <span class="n">default</span><span class="p">)</span>
</span><span id="1-1806">    <span class="k">except</span> <span class="p">(</span><span class="ne">AttributeError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">):</span>  <span class="c1"># For platforms without _getframe()</span>
</span><span id="1-1807">        <span class="k">pass</span>
</span><span id="1-1808">    <span class="k">return</span> <span class="kc">None</span>
</span><span id="1-1809">
</span><span id="1-1810"><span class="k">def</span><span class="w"> </span><span class="nf">_allow_reckless_class_checks</span><span class="p">(</span><span class="n">depth</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
</span><span id="1-1811"><span class="w">    </span><span class="sd">&quot;&quot;&quot;Allow instance and class checks for special stdlib modules.</span>
</span><span id="1-1812">
</span><span id="1-1813"><span class="sd">    The abc and functools modules indiscriminately call isinstance() and</span>
</span><span id="1-1814"><span class="sd">    issubclass() on the whole MRO of a user class, which may contain protocols.</span>
</span><span id="1-1815"><span class="sd">    &quot;&quot;&quot;</span>
</span><span id="1-1816">    <span class="k">return</span> <span class="n">_caller</span><span class="p">(</span><span class="n">depth</span><span class="p">)</span> <span class="ow">in</span> <span class="p">{</span><span class="s1">&#39;abc&#39;</span><span class="p">,</span> <span class="s1">&#39;functools&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">}</span>
</span><span id="1-1817">
</span><span id="1-1818">
</span><span id="1-1819"><span class="n">_PROTO_ALLOWLIST</span> <span class="o">=</span> <span class="p">{</span>
</span><span id="1-1820">    <span class="s1">&#39;collections.abc&#39;</span><span class="p">:</span> <span class="p">[</span>
</span><span id="1-1821">        <span class="s1">&#39;Callable&#39;</span><span class="p">,</span> <span class="s1">&#39;Awaitable&#39;</span><span class="p">,</span> <span class="s1">&#39;Iterable&#39;</span><span class="p">,</span> <span class="s1">&#39;Iterator&#39;</span><span class="p">,</span> <span class="s1">&#39;AsyncIterable&#39;</span><span class="p">,</span>
</span><span id="1-1822">        <span class="s1">&#39;AsyncIterator&#39;</span><span class="p">,</span> <span class="s1">&#39;Hashable&#39;</span><span class="p">,</span> <span class="s1">&#39;Sized&#39;</span><span class="p">,</span> <span class="s1">&#39;Container&#39;</span><span class="p">,</span> <span class="s1">&#39;Collection&#39;</span><span class="p">,</span>
</span><span id="1-1823">        <span class="s1">&#39;Reversible&#39;</span><span class="p">,</span> <span class="s1">&#39;Buffer&#39;</span><span class="p">,</span>
</span><span id="1-1824">    <span class="p">],</span>
</span><span id="1-1825">    <span class="s1">&#39;contextlib&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;AbstractContextManager&#39;</span><span class="p">,</span> <span class="s1">&#39;AbstractAsyncContextManager&#39;</span><span class="p">],</span>
</span><span id="1-1826"><span class="p">}</span>
</span><span id="1-1827">
</span><span id="1-1828">
</span><span id="1-1829"><span class="nd">@functools</span><span class="o">.</span><span class="n">cache</span>
</span><span id="1-1830"><span class="k">def</span><span class="w"> </span><span class="nf">_lazy_load_getattr_static</span><span class="p">():</span>
</span><span id="1-1831">    <span class="c1"># Import getattr_static lazily so as not to slow down the import of typing.py</span>
</span><span id="1-1832">    <span class="c1"># Cache the result so we don&#39;t slow down _ProtocolMeta.__instancecheck__ unnecessarily</span>
</span><span id="1-1833">    <span class="kn">from</span><span class="w"> </span><span class="nn">inspect</span><span class="w"> </span><span class="kn">import</span> <span class="n">getattr_static</span>
</span><span id="1-1834">    <span class="k">return</span> <span class="n">getattr_static</span>
</span><span id="1-1835">
</span><span id="1-1836">
</span><span id="1-1837"><span class="n">_cleanups</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_lazy_load_getattr_static</span><span class="o">.</span><span class="n">cache_clear</span><span class="p">)</span>
</span><span id="1-1838">
</span><span id="1-1839"><span class="k">def</span><span class="w"> </span><span class="nf">_pickle_psargs</span><span class="p">(</span><span class="n">psargs</span><span class="p">):</span>
</span><span id="1-1840">    <span class="k">return</span> <span class="n">ParamSpecArgs</span><span class="p">,</span> <span class="p">(</span><span class="n">psargs</span><span class="o">.</span><span class="n">__origin__</span><span class="p">,)</span>
</span><span id="1-1841">
</span><span id="1-1842"><span class="n">copyreg</span><span class="o">.</span><span class="n">pickle</span><span class="p">(</span><span class="n">ParamSpecArgs</span><span class="p">,</span> <span class="n">_pickle_psargs</span><span class="p">)</span>
</span><span id="1-1843">
</span><span id="1-1844"><span class="k">def</span><span class="w"> </span><span class="nf">_pickle_pskwargs</span><span class="p">(</span><span class="n">pskwargs</span><span class="p">):</span>
</span><span id="1-1845">    <span class="k">return</span> <span class="n">ParamSpecKwargs</span><span class="p">,</span> <span class="p">(</span><span class="n">pskwargs</span><span class="o">.</span><span class="n">__origin__</span><span class="p">,)</span>
</span><span id="1-1846">
</span><span id="1-1847"><span class="n">copyreg</span><span class="o">.</span><span class="n">pickle</span><span class="p">(</span><span class="n">ParamSpecKwargs</span><span class="p">,</span> <span class="n">_pickle_pskwargs</span><span class="p">)</span>
</span><span id="1-1848">
</span><span id="1-1849"><span class="k">del</span> <span class="n">_pickle_psargs</span><span class="p">,</span> <span class="n">_pickle_pskwargs</span>
</span><span id="1-1850">
</span><span id="1-1851">
</span><span id="1-1852"><span class="k">class</span><span class="w"> </span><span class="nc">_ProtocolMeta</span><span class="p">(</span><span class="n">ABCMeta</span><span class="p">):</span>
</span><span id="1-1853">    <span class="c1"># This metaclass is somewhat unfortunate,</span>
</span><span id="1-1854">    <span class="c1"># but is necessary for several reasons...</span>
</span><span id="1-1855">    <span class="k">def</span><span class="w"> </span><span class="fm">__new__</span><span class="p">(</span><span class="n">mcls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">namespace</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
</span><span id="1-1856">        <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;Protocol&quot;</span> <span class="ow">and</span> <span class="n">bases</span> <span class="o">==</span> <span class="p">(</span><span class="n">Generic</span><span class="p">,):</span>
</span><span id="1-1857">            <span class="k">pass</span>
</span><span id="1-1858">        <span class="k">elif</span> <span class="n">Protocol</span> <span class="ow">in</span> <span class="n">bases</span><span class="p">:</span>
</span><span id="1-1859">            <span class="k">for</span> <span class="n">base</span> <span class="ow">in</span> <span class="n">bases</span><span class="p">:</span>
</span><span id="1-1860">                <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span>
</span><span id="1-1861">                    <span class="n">base</span> <span class="ow">in</span> <span class="p">{</span><span class="nb">object</span><span class="p">,</span> <span class="n">Generic</span><span class="p">}</span>
</span><span id="1-1862">                    <span class="ow">or</span> <span class="n">base</span><span class="o">.</span><span class="vm">__name__</span> <span class="ow">in</span> <span class="n">_PROTO_ALLOWLIST</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">base</span><span class="o">.</span><span class="vm">__module__</span><span class="p">,</span> <span class="p">[])</span>
</span><span id="1-1863">                    <span class="ow">or</span> <span class="p">(</span>
</span><span id="1-1864">                        <span class="nb">issubclass</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">Generic</span><span class="p">)</span>
</span><span id="1-1865">                        <span class="ow">and</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="s2">&quot;_is_protocol&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
</span><span id="1-1866">                    <span class="p">)</span>
</span><span id="1-1867">                <span class="p">):</span>
</span><span id="1-1868">                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
</span><span id="1-1869">                        <span class="sa">f</span><span class="s2">&quot;Protocols can only inherit from other protocols, &quot;</span>
</span><span id="1-1870">                        <span class="sa">f</span><span class="s2">&quot;got </span><span class="si">{</span><span class="n">base</span><span class="si">!r}</span><span class="s2">&quot;</span>
</span><span id="1-1871">                    <span class="p">)</span>
</span><span id="1-1872">        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="n">mcls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">namespace</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</span><span id="1-1873">
</span><span id="1-1874">    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
</span><span id="1-1875">        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</span><span id="1-1876">        <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="s2">&quot;_is_protocol&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
</span><span id="1-1877">            <span class="bp">cls</span><span class="o">.</span><span class="n">__protocol_attrs__</span> <span class="o">=</span> <span class="n">_get_protocol_attrs</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>
</span><span id="1-1878">
</span><span id="1-1879">    <span class="k">def</span><span class="w"> </span><span class="fm">__subclasscheck__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
</span><span id="1-1880">        <span class="k">if</span> <span class="bp">cls</span> <span class="ow">is</span> <span class="n">Protocol</span><span class="p">:</span>
</span><span id="1-1881">            <span class="k">return</span> <span class="nb">type</span><span class="o">.</span><span class="fm">__subclasscheck__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
</span><span id="1-1882">        <span class="k">if</span> <span class="p">(</span>
</span><span id="1-1883">            <span class="nb">getattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="s1">&#39;_is_protocol&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
</span><span id="1-1884">            <span class="ow">and</span> <span class="ow">not</span> <span class="n">_allow_reckless_class_checks</span><span class="p">()</span>
</span><span id="1-1885">        <span class="p">):</span>
</span><span id="1-1886">            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="nb">type</span><span class="p">):</span>
</span><span id="1-1887">                <span class="c1"># Same error message as for issubclass(1, int).</span>
</span><span id="1-1888">                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;issubclass() arg 1 must be a class&#39;</span><span class="p">)</span>
</span><span id="1-1889">            <span class="k">if</span> <span class="ow">not</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="s1">&#39;_is_runtime_protocol&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
</span><span id="1-1890">                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
</span><span id="1-1891">                    <span class="s2">&quot;Instance and class checks can only be used with &quot;</span>
</span><span id="1-1892">                    <span class="s2">&quot;@runtime_checkable protocols&quot;</span>
</span><span id="1-1893">                <span class="p">)</span>
</span><span id="1-1894">            <span class="k">if</span> <span class="p">(</span>
</span><span id="1-1895">                <span class="c1"># this attribute is set by @runtime_checkable:</span>
</span><span id="1-1896">                <span class="bp">cls</span><span class="o">.</span><span class="n">__non_callable_proto_members__</span>
</span><span id="1-1897">                <span class="ow">and</span> <span class="bp">cls</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;__subclasshook__&quot;</span><span class="p">)</span> <span class="ow">is</span> <span class="n">_proto_hook</span>
</span><span id="1-1898">            <span class="p">):</span>
</span><span id="1-1899">                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
</span><span id="1-1900">                    <span class="s2">&quot;Protocols with non-method members don&#39;t support issubclass()&quot;</span>
</span><span id="1-1901">                <span class="p">)</span>
</span><span id="1-1902">        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__subclasscheck__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
</span><span id="1-1903">
</span><span id="1-1904">    <span class="k">def</span><span class="w"> </span><span class="fm">__instancecheck__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">instance</span><span class="p">):</span>
</span><span id="1-1905">        <span class="c1"># We need this method for situations where attributes are</span>
</span><span id="1-1906">        <span class="c1"># assigned in __init__.</span>
</span><span id="1-1907">        <span class="k">if</span> <span class="bp">cls</span> <span class="ow">is</span> <span class="n">Protocol</span><span class="p">:</span>
</span><span id="1-1908">            <span class="k">return</span> <span class="nb">type</span><span class="o">.</span><span class="fm">__instancecheck__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">instance</span><span class="p">)</span>
</span><span id="1-1909">        <span class="k">if</span> <span class="ow">not</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="s2">&quot;_is_protocol&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
</span><span id="1-1910">            <span class="c1"># i.e., it&#39;s a concrete subclass of a protocol</span>
</span><span id="1-1911">            <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__instancecheck__</span><span class="p">(</span><span class="n">instance</span><span class="p">)</span>
</span><span id="1-1912">
</span><span id="1-1913">        <span class="k">if</span> <span class="p">(</span>
</span><span id="1-1914">            <span class="ow">not</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="s1">&#39;_is_runtime_protocol&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span> <span class="ow">and</span>
</span><span id="1-1915">            <span class="ow">not</span> <span class="n">_allow_reckless_class_checks</span><span class="p">()</span>
</span><span id="1-1916">        <span class="p">):</span>
</span><span id="1-1917">            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Instance and class checks can only be used with&quot;</span>
</span><span id="1-1918">                            <span class="s2">&quot; @runtime_checkable protocols&quot;</span><span class="p">)</span>
</span><span id="1-1919">
</span><span id="1-1920">        <span class="k">if</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__instancecheck__</span><span class="p">(</span><span class="n">instance</span><span class="p">):</span>
</span><span id="1-1921">            <span class="k">return</span> <span class="kc">True</span>
</span><span id="1-1922">
</span><span id="1-1923">        <span class="n">getattr_static</span> <span class="o">=</span> <span class="n">_lazy_load_getattr_static</span><span class="p">()</span>
</span><span id="1-1924">        <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="n">__protocol_attrs__</span><span class="p">:</span>
</span><span id="1-1925">            <span class="k">try</span><span class="p">:</span>
</span><span id="1-1926">                <span class="n">val</span> <span class="o">=</span> <span class="n">getattr_static</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span>
</span><span id="1-1927">            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
</span><span id="1-1928">                <span class="k">break</span>
</span><span id="1-1929">            <span class="c1"># this attribute is set by @runtime_checkable:</span>
</span><span id="1-1930">            <span class="k">if</span> <span class="n">val</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">attr</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="n">__non_callable_proto_members__</span><span class="p">:</span>
</span><span id="1-1931">                <span class="k">break</span>
</span><span id="1-1932">        <span class="k">else</span><span class="p">:</span>
</span><span id="1-1933">            <span class="k">return</span> <span class="kc">True</span>
</span><span id="1-1934">
</span><span id="1-1935">        <span class="k">return</span> <span class="kc">False</span>
</span><span id="1-1936">
</span><span id="1-1937">
</span><span id="1-1938"><span class="nd">@classmethod</span>
</span><span id="1-1939"><span class="k">def</span><span class="w"> </span><span class="nf">_proto_hook</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
</span><span id="1-1940">    <span class="k">if</span> <span class="ow">not</span> <span class="bp">cls</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;_is_protocol&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
</span><span id="1-1941">        <span class="k">return</span> <span class="bp">NotImplemented</span>
</span><span id="1-1942">
</span><span id="1-1943">    <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="n">__protocol_attrs__</span><span class="p">:</span>
</span><span id="1-1944">        <span class="k">for</span> <span class="n">base</span> <span class="ow">in</span> <span class="n">other</span><span class="o">.</span><span class="vm">__mro__</span><span class="p">:</span>
</span><span id="1-1945">            <span class="c1"># Check if the members appears in the class dictionary...</span>
</span><span id="1-1946">            <span class="k">if</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">base</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">:</span>
</span><span id="1-1947">                <span class="k">if</span> <span class="n">base</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="n">attr</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
</span><span id="1-1948">                    <span class="k">return</span> <span class="bp">NotImplemented</span>
</span><span id="1-1949">                <span class="k">break</span>
</span><span id="1-1950">
</span><span id="1-1951">            <span class="c1"># ...or in annotations, if it is a sub-protocol.</span>
</span><span id="1-1952">            <span class="n">annotations</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="s1">&#39;__annotations__&#39;</span><span class="p">,</span> <span class="p">{})</span>
</span><span id="1-1953">            <span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">annotations</span><span class="p">,</span> <span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">Mapping</span><span class="p">)</span> <span class="ow">and</span>
</span><span id="1-1954">                    <span class="n">attr</span> <span class="ow">in</span> <span class="n">annotations</span> <span class="ow">and</span>
</span><span id="1-1955">                    <span class="nb">issubclass</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Generic</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="s1">&#39;_is_protocol&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)):</span>
</span><span id="1-1956">                <span class="k">break</span>
</span><span id="1-1957">        <span class="k">else</span><span class="p">:</span>
</span><span id="1-1958">            <span class="k">return</span> <span class="bp">NotImplemented</span>
</span><span id="1-1959">    <span class="k">return</span> <span class="kc">True</span>
</span><span id="1-1960">
</span><span id="1-1961">
</span><span id="1-1962"><span class="k">class</span><span class="w"> </span><span class="nc">Protocol</span><span class="p">(</span><span class="n">Generic</span><span class="p">,</span> <span class="n">metaclass</span><span class="o">=</span><span class="n">_ProtocolMeta</span><span class="p">):</span>
</span><span id="1-1963"><span class="w">    </span><span class="sd">&quot;&quot;&quot;Base class for protocol classes.</span>
</span><span id="1-1964">
</span><span id="1-1965"><span class="sd">    Protocol classes are defined as::</span>
</span><span id="1-1966">
</span><span id="1-1967"><span class="sd">        class Proto(Protocol):</span>
</span><span id="1-1968"><span class="sd">            def meth(self) -&gt; int:</span>
</span><span id="1-1969"><span class="sd">                ...</span>
</span><span id="1-1970">
</span><span id="1-1971"><span class="sd">    Such classes are primarily used with static type checkers that recognize</span>
</span><span id="1-1972"><span class="sd">    structural subtyping (static duck-typing).</span>
</span><span id="1-1973">
</span><span id="1-1974"><span class="sd">    For example::</span>
</span><span id="1-1975">
</span><span id="1-1976"><span class="sd">        class C:</span>
</span><span id="1-1977"><span class="sd">            def meth(self) -&gt; int:</span>
</span><span id="1-1978"><span class="sd">                return 0</span>
</span><span id="1-1979">
</span><span id="1-1980"><span class="sd">        def func(x: Proto) -&gt; int:</span>
</span><span id="1-1981"><span class="sd">            return x.meth()</span>
</span><span id="1-1982">
</span><span id="1-1983"><span class="sd">        func(C())  # Passes static type check</span>
</span><span id="1-1984">
</span><span id="1-1985"><span class="sd">    See PEP 544 for details. Protocol classes decorated with</span>
</span><span id="1-1986"><span class="sd">    @typing.runtime_checkable act as simple-minded runtime protocols that check</span>
</span><span id="1-1987"><span class="sd">    only the presence of given attributes, ignoring their type signatures.</span>
</span><span id="1-1988"><span class="sd">    Protocol classes can be generic, they are defined as::</span>
</span><span id="1-1989">
</span><span id="1-1990"><span class="sd">        class GenProto[T](Protocol):</span>
</span><span id="1-1991"><span class="sd">            def meth(self) -&gt; T:</span>
</span><span id="1-1992"><span class="sd">                ...</span>
</span><span id="1-1993"><span class="sd">    &quot;&quot;&quot;</span>
</span><span id="1-1994">
</span><span id="1-1995">    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">()</span>
</span><span id="1-1996">    <span class="n">_is_protocol</span> <span class="o">=</span> <span class="kc">True</span>
</span><span id="1-1997">    <span class="n">_is_runtime_protocol</span> <span class="o">=</span> <span class="kc">False</span>
</span><span id="1-1998">
</span><span id="1-1999">    <span class="k">def</span><span class="w"> </span><span class="nf">__init_subclass__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
</span><span id="1-2000">        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__init_subclass__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</span><span id="1-2001">
</span><span id="1-2002">        <span class="c1"># Determine if this is a protocol or a concrete subclass.</span>
</span><span id="1-2003">        <span class="k">if</span> <span class="ow">not</span> <span class="bp">cls</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;_is_protocol&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
</span><span id="1-2004">            <span class="bp">cls</span><span class="o">.</span><span class="n">_is_protocol</span> <span class="o">=</span> <span class="nb">any</span><span class="p">(</span><span class="n">b</span> <span class="ow">is</span> <span class="n">Protocol</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="vm">__bases__</span><span class="p">)</span>
</span><span id="1-2005">
</span><span id="1-2006">        <span class="c1"># Set (or override) the protocol subclass hook.</span>
</span><span id="1-2007">        <span class="k">if</span> <span class="s1">&#39;__subclasshook__&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">:</span>
</span><span id="1-2008">            <span class="bp">cls</span><span class="o">.</span><span class="n">__subclasshook__</span> <span class="o">=</span> <span class="n">_proto_hook</span>
</span><span id="1-2009">
</span><span id="1-2010">        <span class="c1"># Prohibit instantiation for protocol classes</span>
</span><span id="1-2011">        <span class="k">if</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_is_protocol</span> <span class="ow">and</span> <span class="bp">cls</span><span class="o">.</span><span class="fm">__init__</span> <span class="ow">is</span> <span class="n">Protocol</span><span class="o">.</span><span class="fm">__init__</span><span class="p">:</span>
</span><span id="1-2012">            <span class="bp">cls</span><span class="o">.</span><span class="fm">__init__</span> <span class="o">=</span> <span class="n">_no_init_or_replace_init</span>
</span><span id="1-2013">
</span><span id="1-2014">
</span><span id="1-2015"><span class="k">class</span><span class="w"> </span><span class="nc">_AnnotatedAlias</span><span class="p">(</span><span class="n">_NotIterable</span><span class="p">,</span> <span class="n">_GenericAlias</span><span class="p">,</span> <span class="n">_root</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
</span><span id="1-2016"><span class="w">    </span><span class="sd">&quot;&quot;&quot;Runtime representation of an annotated type.</span>
</span><span id="1-2017">
</span><span id="1-2018"><span class="sd">    At its core &#39;Annotated[t, dec1, dec2, ...]&#39; is an alias for the type &#39;t&#39;</span>
</span><span id="1-2019"><span class="sd">    with extra annotations. The alias behaves like a normal typing alias.</span>
</span><span id="1-2020"><span class="sd">    Instantiating is the same as instantiating the underlying type; binding</span>
</span><span id="1-2021"><span class="sd">    it to types is also the same.</span>
</span><span id="1-2022">
</span><span id="1-2023"><span class="sd">    The metadata itself is stored in a &#39;__metadata__&#39; attribute as a tuple.</span>
</span><span id="1-2024"><span class="sd">    &quot;&quot;&quot;</span>
</span><span id="1-2025">
</span><span id="1-2026">    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">origin</span><span class="p">,</span> <span class="n">metadata</span><span class="p">):</span>
</span><span id="1-2027">        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">origin</span><span class="p">,</span> <span class="n">_AnnotatedAlias</span><span class="p">):</span>
</span><span id="1-2028">            <span class="n">metadata</span> <span class="o">=</span> <span class="n">origin</span><span class="o">.</span><span class="n">__metadata__</span> <span class="o">+</span> <span class="n">metadata</span>
</span><span id="1-2029">            <span class="n">origin</span> <span class="o">=</span> <span class="n">origin</span><span class="o">.</span><span class="n">__origin__</span>
</span><span id="1-2030">        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">origin</span><span class="p">,</span> <span class="n">origin</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;Annotated&#39;</span><span class="p">)</span>
</span><span id="1-2031">        <span class="bp">self</span><span class="o">.</span><span class="n">__metadata__</span> <span class="o">=</span> <span class="n">metadata</span>
</span><span id="1-2032">
</span><span id="1-2033">    <span class="k">def</span><span class="w"> </span><span class="nf">copy_with</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
</span><span id="1-2034">        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">params</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
</span><span id="1-2035">        <span class="n">new_type</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</span><span id="1-2036">        <span class="k">return</span> <span class="n">_AnnotatedAlias</span><span class="p">(</span><span class="n">new_type</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__metadata__</span><span class="p">)</span>
</span><span id="1-2037">
</span><span id="1-2038">    <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span id="1-2039">        <span class="k">return</span> <span class="s2">&quot;typing.Annotated[</span><span class="si">{}</span><span class="s2">, </span><span class="si">{}</span><span class="s2">]&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
</span><span id="1-2040">            <span class="n">_type_repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__origin__</span><span class="p">),</span>
</span><span id="1-2041">            <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__metadata__</span><span class="p">)</span>
</span><span id="1-2042">        <span class="p">)</span>
</span><span id="1-2043">
</span><span id="1-2044">    <span class="k">def</span><span class="w"> </span><span class="nf">__reduce__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span id="1-2045">        <span class="k">return</span> <span class="n">operator</span><span class="o">.</span><span class="n">getitem</span><span class="p">,</span> <span class="p">(</span>
</span><span id="1-2046">            <span class="n">Annotated</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__origin__</span><span class="p">,)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">__metadata__</span>
</span><span id="1-2047">        <span class="p">)</span>
</span><span id="1-2048">
</span><span id="1-2049">    <span class="k">def</span><span class="w"> </span><span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
</span><span id="1-2050">        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">_AnnotatedAlias</span><span class="p">):</span>
</span><span id="1-2051">            <span class="k">return</span> <span class="bp">NotImplemented</span>
</span><span id="1-2052">        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__origin__</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">__origin__</span>
</span><span id="1-2053">                <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">__metadata__</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">__metadata__</span><span class="p">)</span>
</span><span id="1-2054">
</span><span id="1-2055">    <span class="k">def</span><span class="w"> </span><span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span id="1-2056">        <span class="k">return</span> <span class="nb">hash</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">__origin__</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__metadata__</span><span class="p">))</span>
</span><span id="1-2057">
</span><span id="1-2058">    <span class="k">def</span><span class="w"> </span><span class="fm">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">):</span>
</span><span id="1-2059">        <span class="k">if</span> <span class="n">attr</span> <span class="ow">in</span> <span class="p">{</span><span class="s1">&#39;__name__&#39;</span><span class="p">,</span> <span class="s1">&#39;__qualname__&#39;</span><span class="p">}:</span>
</span><span id="1-2060">            <span class="k">return</span> <span class="s1">&#39;Annotated&#39;</span>
</span><span id="1-2061">        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__getattr__</span><span class="p">(</span><span class="n">attr</span><span class="p">)</span>
</span><span id="1-2062">
</span><span id="1-2063">    <span class="k">def</span><span class="w"> </span><span class="nf">__mro_entries__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bases</span><span class="p">):</span>
</span><span id="1-2064">        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__origin__</span><span class="p">,)</span>
</span><span id="1-2065">
</span><span id="1-2066">
</span><span id="1-2067"><span class="k">class</span><span class="w"> </span><span class="nc">Annotated</span><span class="p">:</span>
</span><span id="1-2068"><span class="w">    </span><span class="sd">&quot;&quot;&quot;Add context-specific metadata to a type.</span>
</span><span id="1-2069">
</span><span id="1-2070"><span class="sd">    Example: Annotated[int, runtime_check.Unsigned] indicates to the</span>
</span><span id="1-2071"><span class="sd">    hypothetical runtime_check module that this type is an unsigned int.</span>
</span><span id="1-2072"><span class="sd">    Every other consumer of this type can ignore this metadata and treat</span>
</span><span id="1-2073"><span class="sd">    this type as int.</span>
</span><span id="1-2074">
</span><span id="1-2075"><span class="sd">    The first argument to Annotated must be a valid type.</span>
</span><span id="1-2076">
</span><span id="1-2077"><span class="sd">    Details:</span>
</span><span id="1-2078">
</span><span id="1-2079"><span class="sd">    - It&#39;s an error to call `Annotated` with less than two arguments.</span>
</span><span id="1-2080"><span class="sd">    - Access the metadata via the ``__metadata__`` attribute::</span>
</span><span id="1-2081">
</span><span id="1-2082"><span class="sd">        assert Annotated[int, &#39;$&#39;].__metadata__ == (&#39;$&#39;,)</span>
</span><span id="1-2083">
</span><span id="1-2084"><span class="sd">    - Nested Annotated types are flattened::</span>
</span><span id="1-2085">
</span><span id="1-2086"><span class="sd">        assert Annotated[Annotated[T, Ann1, Ann2], Ann3] == Annotated[T, Ann1, Ann2, Ann3]</span>
</span><span id="1-2087">
</span><span id="1-2088"><span class="sd">    - Instantiating an annotated type is equivalent to instantiating the</span>
</span><span id="1-2089"><span class="sd">    underlying type::</span>
</span><span id="1-2090">
</span><span id="1-2091"><span class="sd">        assert Annotated[C, Ann1](5) == C(5)</span>
</span><span id="1-2092">
</span><span id="1-2093"><span class="sd">    - Annotated can be used as a generic type alias::</span>
</span><span id="1-2094">
</span><span id="1-2095"><span class="sd">        type Optimized[T] = Annotated[T, runtime.Optimize()]</span>
</span><span id="1-2096"><span class="sd">        # type checker will treat Optimized[int]</span>
</span><span id="1-2097"><span class="sd">        # as equivalent to Annotated[int, runtime.Optimize()]</span>
</span><span id="1-2098">
</span><span id="1-2099"><span class="sd">        type OptimizedList[T] = Annotated[list[T], runtime.Optimize()]</span>
</span><span id="1-2100"><span class="sd">        # type checker will treat OptimizedList[int]</span>
</span><span id="1-2101"><span class="sd">        # as equivalent to Annotated[list[int], runtime.Optimize()]</span>
</span><span id="1-2102">
</span><span id="1-2103"><span class="sd">    - Annotated cannot be used with an unpacked TypeVarTuple::</span>
</span><span id="1-2104">
</span><span id="1-2105"><span class="sd">        type Variadic[*Ts] = Annotated[*Ts, Ann1]  # NOT valid</span>
</span><span id="1-2106">
</span><span id="1-2107"><span class="sd">      This would be equivalent to::</span>
</span><span id="1-2108">
</span><span id="1-2109"><span class="sd">        Annotated[T1, T2, T3, ..., Ann1]</span>
</span><span id="1-2110">
</span><span id="1-2111"><span class="sd">      where T1, T2 etc. are TypeVars, which would be invalid, because</span>
</span><span id="1-2112"><span class="sd">      only one type should be passed to Annotated.</span>
</span><span id="1-2113"><span class="sd">    &quot;&quot;&quot;</span>
</span><span id="1-2114">
</span><span id="1-2115">    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">()</span>
</span><span id="1-2116">
</span><span id="1-2117">    <span class="k">def</span><span class="w"> </span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
</span><span id="1-2118">        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Type Annotated cannot be instantiated.&quot;</span><span class="p">)</span>
</span><span id="1-2119">
</span><span id="1-2120">    <span class="k">def</span><span class="w"> </span><span class="nf">__class_getitem__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
</span><span id="1-2121">        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
</span><span id="1-2122">            <span class="n">params</span> <span class="o">=</span> <span class="p">(</span><span class="n">params</span><span class="p">,)</span>
</span><span id="1-2123">        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_class_getitem_inner</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">params</span><span class="p">)</span>
</span><span id="1-2124">
</span><span id="1-2125">    <span class="nd">@_tp_cache</span><span class="p">(</span><span class="n">typed</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</span><span id="1-2126">    <span class="k">def</span><span class="w"> </span><span class="nf">_class_getitem_inner</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">params</span><span class="p">):</span>
</span><span id="1-2127">        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">params</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
</span><span id="1-2128">            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Annotated[...] should be used &quot;</span>
</span><span id="1-2129">                            <span class="s2">&quot;with at least two arguments (a type and an &quot;</span>
</span><span id="1-2130">                            <span class="s2">&quot;annotation).&quot;</span><span class="p">)</span>
</span><span id="1-2131">        <span class="k">if</span> <span class="n">_is_unpacked_typevartuple</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
</span><span id="1-2132">            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Annotated[...] should not be used with an &quot;</span>
</span><span id="1-2133">                            <span class="s2">&quot;unpacked TypeVarTuple&quot;</span><span class="p">)</span>
</span><span id="1-2134">        <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Annotated[t, ...]: t must be a type.&quot;</span>
</span><span id="1-2135">        <span class="n">origin</span> <span class="o">=</span> <span class="n">_type_check</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">msg</span><span class="p">,</span> <span class="n">allow_special_forms</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</span><span id="1-2136">        <span class="n">metadata</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
</span><span id="1-2137">        <span class="k">return</span> <span class="n">_AnnotatedAlias</span><span class="p">(</span><span class="n">origin</span><span class="p">,</span> <span class="n">metadata</span><span class="p">)</span>
</span><span id="1-2138">
</span><span id="1-2139">    <span class="k">def</span><span class="w"> </span><span class="nf">__init_subclass__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
</span><span id="1-2140">        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
</span><span id="1-2141">            <span class="s2">&quot;Cannot subclass </span><span class="si">{}</span><span class="s2">.Annotated&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="vm">__module__</span><span class="p">)</span>
</span><span id="1-2142">        <span class="p">)</span>
</span><span id="1-2143">
</span><span id="1-2144">
</span><span id="1-2145"><span class="k">def</span><span class="w"> </span><span class="nf">runtime_checkable</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
</span><span id="1-2146"><span class="w">    </span><span class="sd">&quot;&quot;&quot;Mark a protocol class as a runtime protocol.</span>
</span><span id="1-2147">
</span><span id="1-2148"><span class="sd">    Such protocol can be used with isinstance() and issubclass().</span>
</span><span id="1-2149"><span class="sd">    Raise TypeError if applied to a non-protocol class.</span>
</span><span id="1-2150"><span class="sd">    This allows a simple-minded structural check very similar to</span>
</span><span id="1-2151"><span class="sd">    one trick ponies in collections.abc such as Iterable.</span>
</span><span id="1-2152">
</span><span id="1-2153"><span class="sd">    For example::</span>
</span><span id="1-2154">
</span><span id="1-2155"><span class="sd">        @runtime_checkable</span>
</span><span id="1-2156"><span class="sd">        class Closable(Protocol):</span>
</span><span id="1-2157"><span class="sd">            def close(self): ...</span>
</span><span id="1-2158">
</span><span id="1-2159"><span class="sd">        assert isinstance(open(&#39;/some/file&#39;), Closable)</span>
</span><span id="1-2160">
</span><span id="1-2161"><span class="sd">    Warning: this will check only the presence of the required methods,</span>
</span><span id="1-2162"><span class="sd">    not their type signatures!</span>
</span><span id="1-2163"><span class="sd">    &quot;&quot;&quot;</span>
</span><span id="1-2164">    <span class="k">if</span> <span class="ow">not</span> <span class="nb">issubclass</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">Generic</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="s1">&#39;_is_protocol&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
</span><span id="1-2165">        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;@runtime_checkable can be only applied to protocol classes,&#39;</span>
</span><span id="1-2166">                        <span class="s1">&#39; got </span><span class="si">%r</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="bp">cls</span><span class="p">)</span>
</span><span id="1-2167">    <span class="bp">cls</span><span class="o">.</span><span class="n">_is_runtime_protocol</span> <span class="o">=</span> <span class="kc">True</span>
</span><span id="1-2168">    <span class="c1"># PEP 544 prohibits using issubclass()</span>
</span><span id="1-2169">    <span class="c1"># with protocols that have non-method members.</span>
</span><span id="1-2170">    <span class="c1"># See gh-113320 for why we compute this attribute here,</span>
</span><span id="1-2171">    <span class="c1"># rather than in `_ProtocolMeta.__init__`</span>
</span><span id="1-2172">    <span class="bp">cls</span><span class="o">.</span><span class="n">__non_callable_proto_members__</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
</span><span id="1-2173">    <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="n">__protocol_attrs__</span><span class="p">:</span>
</span><span id="1-2174">        <span class="k">try</span><span class="p">:</span>
</span><span id="1-2175">            <span class="n">is_callable</span> <span class="o">=</span> <span class="nb">callable</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>
</span><span id="1-2176">        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
</span><span id="1-2177">            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
</span><span id="1-2178">                <span class="sa">f</span><span class="s2">&quot;Failed to determine whether protocol member </span><span class="si">{</span><span class="n">attr</span><span class="si">!r}</span><span class="s2"> &quot;</span>
</span><span id="1-2179">                <span class="s2">&quot;is a method member&quot;</span>
</span><span id="1-2180">            <span class="p">)</span> <span class="kn">from</span><span class="w"> </span><span class="nn">e</span>
</span><span id="1-2181">        <span class="k">else</span><span class="p">:</span>
</span><span id="1-2182">            <span class="k">if</span> <span class="ow">not</span> <span class="n">is_callable</span><span class="p">:</span>
</span><span id="1-2183">                <span class="bp">cls</span><span class="o">.</span><span class="n">__non_callable_proto_members__</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">attr</span><span class="p">)</span>
</span><span id="1-2184">    <span class="k">return</span> <span class="bp">cls</span>
</span><span id="1-2185">
</span><span id="1-2186">
</span><span id="1-2187"><span class="k">def</span><span class="w"> </span><span class="nf">cast</span><span class="p">(</span><span class="n">typ</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
</span><span id="1-2188"><span class="w">    </span><span class="sd">&quot;&quot;&quot;Cast a value to a type.</span>
</span><span id="1-2189">
</span><span id="1-2190"><span class="sd">    This returns the value unchanged.  To the type checker this</span>
</span><span id="1-2191"><span class="sd">    signals that the return value has the designated type, but at</span>
</span><span id="1-2192"><span class="sd">    runtime we intentionally don&#39;t check anything (we want this</span>
</span><span id="1-2193"><span class="sd">    to be as fast as possible).</span>
</span><span id="1-2194"><span class="sd">    &quot;&quot;&quot;</span>
</span><span id="1-2195">    <span class="k">return</span> <span class="n">val</span>
</span><span id="1-2196">
</span><span id="1-2197">
</span><span id="1-2198"><span class="k">def</span><span class="w"> </span><span class="nf">assert_type</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">typ</span><span class="p">,</span> <span class="o">/</span><span class="p">):</span>
</span><span id="1-2199"><span class="w">    </span><span class="sd">&quot;&quot;&quot;Ask a static type checker to confirm that the value is of the given type.</span>
</span><span id="1-2200">
</span><span id="1-2201"><span class="sd">    At runtime this does nothing: it returns the first argument unchanged with no</span>
</span><span id="1-2202"><span class="sd">    checks or side effects, no matter the actual type of the argument.</span>
</span><span id="1-2203">
</span><span id="1-2204"><span class="sd">    When a static type checker encounters a call to assert_type(), it</span>
</span><span id="1-2205"><span class="sd">    emits an error if the value is not of the specified type::</span>
</span><span id="1-2206">
</span><span id="1-2207"><span class="sd">        def greet(name: str) -&gt; None:</span>
</span><span id="1-2208"><span class="sd">            assert_type(name, str)  # OK</span>
</span><span id="1-2209"><span class="sd">            assert_type(name, int)  # type checker error</span>
</span><span id="1-2210"><span class="sd">    &quot;&quot;&quot;</span>
</span><span id="1-2211">    <span class="k">return</span> <span class="n">val</span>
</span><span id="1-2212">
</span><span id="1-2213">
</span><span id="1-2214"><span class="n">_allowed_types</span> <span class="o">=</span> <span class="p">(</span><span class="n">types</span><span class="o">.</span><span class="n">FunctionType</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">BuiltinFunctionType</span><span class="p">,</span>
</span><span id="1-2215">                  <span class="n">types</span><span class="o">.</span><span class="n">MethodType</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">ModuleType</span><span class="p">,</span>
</span><span id="1-2216">                  <span class="n">WrapperDescriptorType</span><span class="p">,</span> <span class="n">MethodWrapperType</span><span class="p">,</span> <span class="n">MethodDescriptorType</span><span class="p">)</span>
</span><span id="1-2217">
</span><span id="1-2218">
</span><span id="1-2219"><span class="k">def</span><span class="w"> </span><span class="nf">get_type_hints</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">globalns</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">localns</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">include_extras</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
</span><span id="1-2220"><span class="w">    </span><span class="sd">&quot;&quot;&quot;Return type hints for an object.</span>
</span><span id="1-2221">
</span><span id="1-2222"><span class="sd">    This is often the same as obj.__annotations__, but it handles</span>
</span><span id="1-2223"><span class="sd">    forward references encoded as string literals and recursively replaces all</span>
</span><span id="1-2224"><span class="sd">    &#39;Annotated[T, ...]&#39; with &#39;T&#39; (unless &#39;include_extras=True&#39;).</span>
</span><span id="1-2225">
</span><span id="1-2226"><span class="sd">    The argument may be a module, class, method, or function. The annotations</span>
</span><span id="1-2227"><span class="sd">    are returned as a dictionary. For classes, annotations include also</span>
</span><span id="1-2228"><span class="sd">    inherited members.</span>
</span><span id="1-2229">
</span><span id="1-2230"><span class="sd">    TypeError is raised if the argument is not of a type that can contain</span>
</span><span id="1-2231"><span class="sd">    annotations, and an empty dictionary is returned if no annotations are</span>
</span><span id="1-2232"><span class="sd">    present.</span>
</span><span id="1-2233">
</span><span id="1-2234"><span class="sd">    BEWARE -- the behavior of globalns and localns is counterintuitive</span>
</span><span id="1-2235"><span class="sd">    (unless you are familiar with how eval() and exec() work).  The</span>
</span><span id="1-2236"><span class="sd">    search order is locals first, then globals.</span>
</span><span id="1-2237">
</span><span id="1-2238"><span class="sd">    - If no dict arguments are passed, an attempt is made to use the</span>
</span><span id="1-2239"><span class="sd">      globals from obj (or the respective module&#39;s globals for classes),</span>
</span><span id="1-2240"><span class="sd">      and these are also used as the locals.  If the object does not appear</span>
</span><span id="1-2241"><span class="sd">      to have globals, an empty dictionary is used.  For classes, the search</span>
</span><span id="1-2242"><span class="sd">      order is globals first then locals.</span>
</span><span id="1-2243">
</span><span id="1-2244"><span class="sd">    - If one dict argument is passed, it is used for both globals and</span>
</span><span id="1-2245"><span class="sd">      locals.</span>
</span><span id="1-2246">
</span><span id="1-2247"><span class="sd">    - If two dict arguments are passed, they specify globals and</span>
</span><span id="1-2248"><span class="sd">      locals, respectively.</span>
</span><span id="1-2249"><span class="sd">    &quot;&quot;&quot;</span>
</span><span id="1-2250">    <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s1">&#39;__no_type_check__&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">):</span>
</span><span id="1-2251">        <span class="k">return</span> <span class="p">{}</span>
</span><span id="1-2252">    <span class="c1"># Classes require a special treatment.</span>
</span><span id="1-2253">    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="nb">type</span><span class="p">):</span>
</span><span id="1-2254">        <span class="n">hints</span> <span class="o">=</span> <span class="p">{}</span>
</span><span id="1-2255">        <span class="k">for</span> <span class="n">base</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="vm">__mro__</span><span class="p">):</span>
</span><span id="1-2256">            <span class="k">if</span> <span class="n">globalns</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
</span><span id="1-2257">                <span class="n">base_globals</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">base</span><span class="o">.</span><span class="vm">__module__</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span> <span class="s1">&#39;__dict__&#39;</span><span class="p">,</span> <span class="p">{})</span>
</span><span id="1-2258">            <span class="k">else</span><span class="p">:</span>
</span><span id="1-2259">                <span class="n">base_globals</span> <span class="o">=</span> <span class="n">globalns</span>
</span><span id="1-2260">            <span class="n">ann</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;__annotations__&#39;</span><span class="p">,</span> <span class="p">{})</span>
</span><span id="1-2261">            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ann</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">GetSetDescriptorType</span><span class="p">):</span>
</span><span id="1-2262">                <span class="n">ann</span> <span class="o">=</span> <span class="p">{}</span>
</span><span id="1-2263">            <span class="n">base_locals</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">vars</span><span class="p">(</span><span class="n">base</span><span class="p">))</span> <span class="k">if</span> <span class="n">localns</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">localns</span>
</span><span id="1-2264">            <span class="k">if</span> <span class="n">localns</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">globalns</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
</span><span id="1-2265">                <span class="c1"># This is surprising, but required.  Before Python 3.10,</span>
</span><span id="1-2266">                <span class="c1"># get_type_hints only evaluated the globalns of</span>
</span><span id="1-2267">                <span class="c1"># a class.  To maintain backwards compatibility, we reverse</span>
</span><span id="1-2268">                <span class="c1"># the globalns and localns order so that eval() looks into</span>
</span><span id="1-2269">                <span class="c1"># *base_globals* first rather than *base_locals*.</span>
</span><span id="1-2270">                <span class="c1"># This only affects ForwardRefs.</span>
</span><span id="1-2271">                <span class="n">base_globals</span><span class="p">,</span> <span class="n">base_locals</span> <span class="o">=</span> <span class="n">base_locals</span><span class="p">,</span> <span class="n">base_globals</span>
</span><span id="1-2272">            <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">ann</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
</span><span id="1-2273">                <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
</span><span id="1-2274">                    <span class="n">value</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
</span><span id="1-2275">                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
</span><span id="1-2276">                    <span class="n">value</span> <span class="o">=</span> <span class="n">ForwardRef</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">is_argument</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">is_class</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</span><span id="1-2277">                <span class="n">value</span> <span class="o">=</span> <span class="n">_eval_type</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">base_globals</span><span class="p">,</span> <span class="n">base_locals</span><span class="p">,</span> <span class="n">base</span><span class="o">.</span><span class="n">__type_params__</span><span class="p">)</span>
</span><span id="1-2278">                <span class="n">hints</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
</span><span id="1-2279">        <span class="k">return</span> <span class="n">hints</span> <span class="k">if</span> <span class="n">include_extras</span> <span class="k">else</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">_strip_annotations</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">hints</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
</span><span id="1-2280">
</span><span id="1-2281">    <span class="k">if</span> <span class="n">globalns</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
</span><span id="1-2282">        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">ModuleType</span><span class="p">):</span>
</span><span id="1-2283">            <span class="n">globalns</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="vm">__dict__</span>
</span><span id="1-2284">        <span class="k">else</span><span class="p">:</span>
</span><span id="1-2285">            <span class="n">nsobj</span> <span class="o">=</span> <span class="n">obj</span>
</span><span id="1-2286">            <span class="c1"># Find globalns for the unwrapped object.</span>
</span><span id="1-2287">            <span class="k">while</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">nsobj</span><span class="p">,</span> <span class="s1">&#39;__wrapped__&#39;</span><span class="p">):</span>
</span><span id="1-2288">                <span class="n">nsobj</span> <span class="o">=</span> <span class="n">nsobj</span><span class="o">.</span><span class="n">__wrapped__</span>
</span><span id="1-2289">            <span class="n">globalns</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">nsobj</span><span class="p">,</span> <span class="s1">&#39;__globals__&#39;</span><span class="p">,</span> <span class="p">{})</span>
</span><span id="1-2290">        <span class="k">if</span> <span class="n">localns</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
</span><span id="1-2291">            <span class="n">localns</span> <span class="o">=</span> <span class="n">globalns</span>
</span><span id="1-2292">    <span class="k">elif</span> <span class="n">localns</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
</span><span id="1-2293">        <span class="n">localns</span> <span class="o">=</span> <span class="n">globalns</span>
</span><span id="1-2294">    <span class="n">hints</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s1">&#39;__annotations__&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
</span><span id="1-2295">    <span class="k">if</span> <span class="n">hints</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
</span><span id="1-2296">        <span class="c1"># Return empty annotations for something that _could_ have them.</span>
</span><span id="1-2297">        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">_allowed_types</span><span class="p">):</span>
</span><span id="1-2298">            <span class="k">return</span> <span class="p">{}</span>
</span><span id="1-2299">        <span class="k">else</span><span class="p">:</span>
</span><span id="1-2300">            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{!r}</span><span class="s1"> is not a module, class, method, &#39;</span>
</span><span id="1-2301">                            <span class="s1">&#39;or function.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">obj</span><span class="p">))</span>
</span><span id="1-2302">    <span class="n">hints</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">hints</span><span class="p">)</span>
</span><span id="1-2303">    <span class="n">type_params</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s2">&quot;__type_params__&quot;</span><span class="p">,</span> <span class="p">())</span>
</span><span id="1-2304">    <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">hints</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
</span><span id="1-2305">        <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
</span><span id="1-2306">            <span class="n">value</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
</span><span id="1-2307">        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
</span><span id="1-2308">            <span class="c1"># class-level forward refs were handled above, this must be either</span>
</span><span id="1-2309">            <span class="c1"># a module-level annotation or a function argument annotation</span>
</span><span id="1-2310">            <span class="n">value</span> <span class="o">=</span> <span class="n">ForwardRef</span><span class="p">(</span>
</span><span id="1-2311">                <span class="n">value</span><span class="p">,</span>
</span><span id="1-2312">                <span class="n">is_argument</span><span class="o">=</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">ModuleType</span><span class="p">),</span>
</span><span id="1-2313">                <span class="n">is_class</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
</span><span id="1-2314">            <span class="p">)</span>
</span><span id="1-2315">        <span class="n">hints</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">_eval_type</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">globalns</span><span class="p">,</span> <span class="n">localns</span><span class="p">,</span> <span class="n">type_params</span><span class="p">)</span>
</span><span id="1-2316">    <span class="k">return</span> <span class="n">hints</span> <span class="k">if</span> <span class="n">include_extras</span> <span class="k">else</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">_strip_annotations</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">hints</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
</span><span id="1-2317">
</span><span id="1-2318">
</span><span id="1-2319"><span class="k">def</span><span class="w"> </span><span class="nf">_strip_annotations</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
</span><span id="1-2320"><span class="w">    </span><span class="sd">&quot;&quot;&quot;Strip the annotations from a given type.&quot;&quot;&quot;</span>
</span><span id="1-2321">    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">_AnnotatedAlias</span><span class="p">):</span>
</span><span id="1-2322">        <span class="k">return</span> <span class="n">_strip_annotations</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">__origin__</span><span class="p">)</span>
</span><span id="1-2323">    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="s2">&quot;__origin__&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">t</span><span class="o">.</span><span class="n">__origin__</span> <span class="ow">in</span> <span class="p">(</span><span class="n">Required</span><span class="p">,</span> <span class="n">NotRequired</span><span class="p">):</span>
</span><span id="1-2324">        <span class="k">return</span> <span class="n">_strip_annotations</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">__args__</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
</span><span id="1-2325">    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">_GenericAlias</span><span class="p">):</span>
</span><span id="1-2326">        <span class="n">stripped_args</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">_strip_annotations</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">t</span><span class="o">.</span><span class="n">__args__</span><span class="p">)</span>
</span><span id="1-2327">        <span class="k">if</span> <span class="n">stripped_args</span> <span class="o">==</span> <span class="n">t</span><span class="o">.</span><span class="n">__args__</span><span class="p">:</span>
</span><span id="1-2328">            <span class="k">return</span> <span class="n">t</span>
</span><span id="1-2329">        <span class="k">return</span> <span class="n">t</span><span class="o">.</span><span class="n">copy_with</span><span class="p">(</span><span class="n">stripped_args</span><span class="p">)</span>
</span><span id="1-2330">    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">GenericAlias</span><span class="p">):</span>
</span><span id="1-2331">        <span class="n">stripped_args</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">_strip_annotations</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">t</span><span class="o">.</span><span class="n">__args__</span><span class="p">)</span>
</span><span id="1-2332">        <span class="k">if</span> <span class="n">stripped_args</span> <span class="o">==</span> <span class="n">t</span><span class="o">.</span><span class="n">__args__</span><span class="p">:</span>
</span><span id="1-2333">            <span class="k">return</span> <span class="n">t</span>
</span><span id="1-2334">        <span class="k">return</span> <span class="n">GenericAlias</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">__origin__</span><span class="p">,</span> <span class="n">stripped_args</span><span class="p">)</span>
</span><span id="1-2335">    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">UnionType</span><span class="p">):</span>
</span><span id="1-2336">        <span class="n">stripped_args</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">_strip_annotations</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">t</span><span class="o">.</span><span class="n">__args__</span><span class="p">)</span>
</span><span id="1-2337">        <span class="k">if</span> <span class="n">stripped_args</span> <span class="o">==</span> <span class="n">t</span><span class="o">.</span><span class="n">__args__</span><span class="p">:</span>
</span><span id="1-2338">            <span class="k">return</span> <span class="n">t</span>
</span><span id="1-2339">        <span class="k">return</span> <span class="n">functools</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">or_</span><span class="p">,</span> <span class="n">stripped_args</span><span class="p">)</span>
</span><span id="1-2340">
</span><span id="1-2341">    <span class="k">return</span> <span class="n">t</span>
</span><span id="1-2342">
</span><span id="1-2343">
</span><span id="1-2344"><span class="k">def</span><span class="w"> </span><span class="nf">get_origin</span><span class="p">(</span><span class="n">tp</span><span class="p">):</span>
</span><span id="1-2345"><span class="w">    </span><span class="sd">&quot;&quot;&quot;Get the unsubscripted version of a type.</span>
</span><span id="1-2346">
</span><span id="1-2347"><span class="sd">    This supports generic types, Callable, Tuple, Union, Literal, Final, ClassVar,</span>
</span><span id="1-2348"><span class="sd">    Annotated, and others. Return None for unsupported types.</span>
</span><span id="1-2349">
</span><span id="1-2350"><span class="sd">    Examples::</span>
</span><span id="1-2351">
</span><span id="1-2352"><span class="sd">        &gt;&gt;&gt; P = ParamSpec(&#39;P&#39;)</span>
</span><span id="1-2353"><span class="sd">        &gt;&gt;&gt; assert get_origin(Literal[42]) is Literal</span>
</span><span id="1-2354"><span class="sd">        &gt;&gt;&gt; assert get_origin(int) is None</span>
</span><span id="1-2355"><span class="sd">        &gt;&gt;&gt; assert get_origin(ClassVar[int]) is ClassVar</span>
</span><span id="1-2356"><span class="sd">        &gt;&gt;&gt; assert get_origin(Generic) is Generic</span>
</span><span id="1-2357"><span class="sd">        &gt;&gt;&gt; assert get_origin(Generic[T]) is Generic</span>
</span><span id="1-2358"><span class="sd">        &gt;&gt;&gt; assert get_origin(Union[T, int]) is Union</span>
</span><span id="1-2359"><span class="sd">        &gt;&gt;&gt; assert get_origin(List[Tuple[T, T]][int]) is list</span>
</span><span id="1-2360"><span class="sd">        &gt;&gt;&gt; assert get_origin(P.args) is P</span>
</span><span id="1-2361"><span class="sd">    &quot;&quot;&quot;</span>
</span><span id="1-2362">    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">_AnnotatedAlias</span><span class="p">):</span>
</span><span id="1-2363">        <span class="k">return</span> <span class="n">Annotated</span>
</span><span id="1-2364">    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="p">(</span><span class="n">_BaseGenericAlias</span><span class="p">,</span> <span class="n">GenericAlias</span><span class="p">,</span>
</span><span id="1-2365">                       <span class="n">ParamSpecArgs</span><span class="p">,</span> <span class="n">ParamSpecKwargs</span><span class="p">)):</span>
</span><span id="1-2366">        <span class="k">return</span> <span class="n">tp</span><span class="o">.</span><span class="n">__origin__</span>
</span><span id="1-2367">    <span class="k">if</span> <span class="n">tp</span> <span class="ow">is</span> <span class="n">Generic</span><span class="p">:</span>
</span><span id="1-2368">        <span class="k">return</span> <span class="n">Generic</span>
</span><span id="1-2369">    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">UnionType</span><span class="p">):</span>
</span><span id="1-2370">        <span class="k">return</span> <span class="n">types</span><span class="o">.</span><span class="n">UnionType</span>
</span><span id="1-2371">    <span class="k">return</span> <span class="kc">None</span>
</span><span id="1-2372">
</span><span id="1-2373">
</span><span id="1-2374"><span class="k">def</span><span class="w"> </span><span class="nf">get_args</span><span class="p">(</span><span class="n">tp</span><span class="p">):</span>
</span><span id="1-2375"><span class="w">    </span><span class="sd">&quot;&quot;&quot;Get type arguments with all substitutions performed.</span>
</span><span id="1-2376">
</span><span id="1-2377"><span class="sd">    For unions, basic simplifications used by Union constructor are performed.</span>
</span><span id="1-2378">
</span><span id="1-2379"><span class="sd">    Examples::</span>
</span><span id="1-2380">
</span><span id="1-2381"><span class="sd">        &gt;&gt;&gt; T = TypeVar(&#39;T&#39;)</span>
</span><span id="1-2382"><span class="sd">        &gt;&gt;&gt; assert get_args(Dict[str, int]) == (str, int)</span>
</span><span id="1-2383"><span class="sd">        &gt;&gt;&gt; assert get_args(int) == ()</span>
</span><span id="1-2384"><span class="sd">        &gt;&gt;&gt; assert get_args(Union[int, Union[T, int], str][int]) == (int, str)</span>
</span><span id="1-2385"><span class="sd">        &gt;&gt;&gt; assert get_args(Union[int, Tuple[T, int]][str]) == (int, Tuple[str, int])</span>
</span><span id="1-2386"><span class="sd">        &gt;&gt;&gt; assert get_args(Callable[[], T][int]) == ([], int)</span>
</span><span id="1-2387"><span class="sd">    &quot;&quot;&quot;</span>
</span><span id="1-2388">    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">_AnnotatedAlias</span><span class="p">):</span>
</span><span id="1-2389">        <span class="k">return</span> <span class="p">(</span><span class="n">tp</span><span class="o">.</span><span class="n">__origin__</span><span class="p">,)</span> <span class="o">+</span> <span class="n">tp</span><span class="o">.</span><span class="n">__metadata__</span>
</span><span id="1-2390">    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="p">(</span><span class="n">_GenericAlias</span><span class="p">,</span> <span class="n">GenericAlias</span><span class="p">)):</span>
</span><span id="1-2391">        <span class="n">res</span> <span class="o">=</span> <span class="n">tp</span><span class="o">.</span><span class="n">__args__</span>
</span><span id="1-2392">        <span class="k">if</span> <span class="n">_should_unflatten_callable_args</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">res</span><span class="p">):</span>
</span><span id="1-2393">            <span class="n">res</span> <span class="o">=</span> <span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">res</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span> <span class="n">res</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
</span><span id="1-2394">        <span class="k">return</span> <span class="n">res</span>
</span><span id="1-2395">    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">UnionType</span><span class="p">):</span>
</span><span id="1-2396">        <span class="k">return</span> <span class="n">tp</span><span class="o">.</span><span class="n">__args__</span>
</span><span id="1-2397">    <span class="k">return</span> <span class="p">()</span>
</span><span id="1-2398">
</span><span id="1-2399">
</span><span id="1-2400"><span class="k">def</span><span class="w"> </span><span class="nf">is_typeddict</span><span class="p">(</span><span class="n">tp</span><span class="p">):</span>
</span><span id="1-2401"><span class="w">    </span><span class="sd">&quot;&quot;&quot;Check if an annotation is a TypedDict class.</span>
</span><span id="1-2402">
</span><span id="1-2403"><span class="sd">    For example::</span>
</span><span id="1-2404">
</span><span id="1-2405"><span class="sd">        &gt;&gt;&gt; from typing import TypedDict</span>
</span><span id="1-2406"><span class="sd">        &gt;&gt;&gt; class Film(TypedDict):</span>
</span><span id="1-2407"><span class="sd">        ...     title: str</span>
</span><span id="1-2408"><span class="sd">        ...     year: int</span>
</span><span id="1-2409"><span class="sd">        ...</span>
</span><span id="1-2410"><span class="sd">        &gt;&gt;&gt; is_typeddict(Film)</span>
</span><span id="1-2411"><span class="sd">        True</span>
</span><span id="1-2412"><span class="sd">        &gt;&gt;&gt; is_typeddict(dict)</span>
</span><span id="1-2413"><span class="sd">        False</span>
</span><span id="1-2414"><span class="sd">    &quot;&quot;&quot;</span>
</span><span id="1-2415">    <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">_TypedDictMeta</span><span class="p">)</span>
</span><span id="1-2416">
</span><span id="1-2417">
</span><span id="1-2418"><span class="n">_ASSERT_NEVER_REPR_MAX_LENGTH</span> <span class="o">=</span> <span class="mi">100</span>
</span><span id="1-2419">
</span><span id="1-2420">
</span><span id="1-2421"><span class="k">def</span><span class="w"> </span><span class="nf">assert_never</span><span class="p">(</span><span class="n">arg</span><span class="p">:</span> <span class="n">Never</span><span class="p">,</span> <span class="o">/</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Never</span><span class="p">:</span>
</span><span id="1-2422"><span class="w">    </span><span class="sd">&quot;&quot;&quot;Statically assert that a line of code is unreachable.</span>
</span><span id="1-2423">
</span><span id="1-2424"><span class="sd">    Example::</span>
</span><span id="1-2425">
</span><span id="1-2426"><span class="sd">        def int_or_str(arg: int | str) -&gt; None:</span>
</span><span id="1-2427"><span class="sd">            match arg:</span>
</span><span id="1-2428"><span class="sd">                case int():</span>
</span><span id="1-2429"><span class="sd">                    print(&quot;It&#39;s an int&quot;)</span>
</span><span id="1-2430"><span class="sd">                case str():</span>
</span><span id="1-2431"><span class="sd">                    print(&quot;It&#39;s a str&quot;)</span>
</span><span id="1-2432"><span class="sd">                case _:</span>
</span><span id="1-2433"><span class="sd">                    assert_never(arg)</span>
</span><span id="1-2434">
</span><span id="1-2435"><span class="sd">    If a type checker finds that a call to assert_never() is</span>
</span><span id="1-2436"><span class="sd">    reachable, it will emit an error.</span>
</span><span id="1-2437">
</span><span id="1-2438"><span class="sd">    At runtime, this throws an exception when called.</span>
</span><span id="1-2439"><span class="sd">    &quot;&quot;&quot;</span>
</span><span id="1-2440">    <span class="n">value</span> <span class="o">=</span> <span class="nb">repr</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
</span><span id="1-2441">    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">_ASSERT_NEVER_REPR_MAX_LENGTH</span><span class="p">:</span>
</span><span id="1-2442">        <span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="p">[:</span><span class="n">_ASSERT_NEVER_REPR_MAX_LENGTH</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;...&#39;</span>
</span><span id="1-2443">    <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Expected code to be unreachable, but got: </span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</span><span id="1-2444">
</span><span id="1-2445">
</span><span id="1-2446"><span class="k">def</span><span class="w"> </span><span class="nf">no_type_check</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span>
</span><span id="1-2447"><span class="w">    </span><span class="sd">&quot;&quot;&quot;Decorator to indicate that annotations are not type hints.</span>
</span><span id="1-2448">
</span><span id="1-2449"><span class="sd">    The argument must be a class or function; if it is a class, it</span>
</span><span id="1-2450"><span class="sd">    applies recursively to all methods and classes defined in that class</span>
</span><span id="1-2451"><span class="sd">    (but not to methods defined in its superclasses or subclasses).</span>
</span><span id="1-2452">
</span><span id="1-2453"><span class="sd">    This mutates the function(s) or class(es) in place.</span>
</span><span id="1-2454"><span class="sd">    &quot;&quot;&quot;</span>
</span><span id="1-2455">    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="nb">type</span><span class="p">):</span>
</span><span id="1-2456">        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="nb">dir</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span>
</span><span id="1-2457">            <span class="n">obj</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
</span><span id="1-2458">            <span class="k">if</span> <span class="p">(</span>
</span><span id="1-2459">                <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s1">&#39;__qualname__&#39;</span><span class="p">)</span>
</span><span id="1-2460">                <span class="ow">or</span> <span class="n">obj</span><span class="o">.</span><span class="vm">__qualname__</span> <span class="o">!=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">arg</span><span class="o">.</span><span class="vm">__qualname__</span><span class="si">}</span><span class="s1">.</span><span class="si">{</span><span class="n">obj</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s1">&#39;</span>
</span><span id="1-2461">                <span class="ow">or</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s1">&#39;__module__&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="o">!=</span> <span class="n">arg</span><span class="o">.</span><span class="vm">__module__</span>
</span><span id="1-2462">            <span class="p">):</span>
</span><span id="1-2463">                <span class="c1"># We only modify objects that are defined in this type directly.</span>
</span><span id="1-2464">                <span class="c1"># If classes / methods are nested in multiple layers,</span>
</span><span id="1-2465">                <span class="c1"># we will modify them when processing their direct holders.</span>
</span><span id="1-2466">                <span class="k">continue</span>
</span><span id="1-2467">            <span class="c1"># Instance, class, and static methods:</span>
</span><span id="1-2468">            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">FunctionType</span><span class="p">):</span>
</span><span id="1-2469">                <span class="n">obj</span><span class="o">.</span><span class="n">__no_type_check__</span> <span class="o">=</span> <span class="kc">True</span>
</span><span id="1-2470">            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">MethodType</span><span class="p">):</span>
</span><span id="1-2471">                <span class="n">obj</span><span class="o">.</span><span class="vm">__func__</span><span class="o">.</span><span class="n">__no_type_check__</span> <span class="o">=</span> <span class="kc">True</span>
</span><span id="1-2472">            <span class="c1"># Nested types:</span>
</span><span id="1-2473">            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="nb">type</span><span class="p">):</span>
</span><span id="1-2474">                <span class="n">no_type_check</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
</span><span id="1-2475">    <span class="k">try</span><span class="p">:</span>
</span><span id="1-2476">        <span class="n">arg</span><span class="o">.</span><span class="n">__no_type_check__</span> <span class="o">=</span> <span class="kc">True</span>
</span><span id="1-2477">    <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>  <span class="c1"># built-in classes</span>
</span><span id="1-2478">        <span class="k">pass</span>
</span><span id="1-2479">    <span class="k">return</span> <span class="n">arg</span>
</span><span id="1-2480">
</span><span id="1-2481">
</span><span id="1-2482"><span class="k">def</span><span class="w"> </span><span class="nf">no_type_check_decorator</span><span class="p">(</span><span class="n">decorator</span><span class="p">):</span>
</span><span id="1-2483"><span class="w">    </span><span class="sd">&quot;&quot;&quot;Decorator to give another decorator the @no_type_check effect.</span>
</span><span id="1-2484">
</span><span id="1-2485"><span class="sd">    This wraps the decorator with something that wraps the decorated</span>
</span><span id="1-2486"><span class="sd">    function in @no_type_check.</span>
</span><span id="1-2487"><span class="sd">    &quot;&quot;&quot;</span>
</span><span id="1-2488">    <span class="nd">@functools</span><span class="o">.</span><span class="n">wraps</span><span class="p">(</span><span class="n">decorator</span><span class="p">)</span>
</span><span id="1-2489">    <span class="k">def</span><span class="w"> </span><span class="nf">wrapped_decorator</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
</span><span id="1-2490">        <span class="n">func</span> <span class="o">=</span> <span class="n">decorator</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>
</span><span id="1-2491">        <span class="n">func</span> <span class="o">=</span> <span class="n">no_type_check</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
</span><span id="1-2492">        <span class="k">return</span> <span class="n">func</span>
</span><span id="1-2493">
</span><span id="1-2494">    <span class="k">return</span> <span class="n">wrapped_decorator</span>
</span><span id="1-2495">
</span><span id="1-2496">
</span><span id="1-2497"><span class="k">def</span><span class="w"> </span><span class="nf">_overload_dummy</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
</span><span id="1-2498"><span class="w">    </span><span class="sd">&quot;&quot;&quot;Helper for @overload to raise when called.&quot;&quot;&quot;</span>
</span><span id="1-2499">    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
</span><span id="1-2500">        <span class="s2">&quot;You should not call an overloaded function. &quot;</span>
</span><span id="1-2501">        <span class="s2">&quot;A series of @overload-decorated functions &quot;</span>
</span><span id="1-2502">        <span class="s2">&quot;outside a stub module should always be followed &quot;</span>
</span><span id="1-2503">        <span class="s2">&quot;by an implementation that is not @overload-ed.&quot;</span><span class="p">)</span>
</span><span id="1-2504">
</span><span id="1-2505">
</span><span id="1-2506"><span class="c1"># {module: {qualname: {firstlineno: func}}}</span>
</span><span id="1-2507"><span class="n">_overload_registry</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span><span class="n">defaultdict</span><span class="p">,</span> <span class="nb">dict</span><span class="p">))</span>
</span><span id="1-2508">
</span><span id="1-2509">
</span><span id="1-2510"><span class="k">def</span><span class="w"> </span><span class="nf">overload</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
</span><span id="1-2511"><span class="w">    </span><span class="sd">&quot;&quot;&quot;Decorator for overloaded functions/methods.</span>
</span><span id="1-2512">
</span><span id="1-2513"><span class="sd">    In a stub file, place two or more stub definitions for the same</span>
</span><span id="1-2514"><span class="sd">    function in a row, each decorated with @overload.</span>
</span><span id="1-2515">
</span><span id="1-2516"><span class="sd">    For example::</span>
</span><span id="1-2517">
</span><span id="1-2518"><span class="sd">        @overload</span>
</span><span id="1-2519"><span class="sd">        def utf8(value: None) -&gt; None: ...</span>
</span><span id="1-2520"><span class="sd">        @overload</span>
</span><span id="1-2521"><span class="sd">        def utf8(value: bytes) -&gt; bytes: ...</span>
</span><span id="1-2522"><span class="sd">        @overload</span>
</span><span id="1-2523"><span class="sd">        def utf8(value: str) -&gt; bytes: ...</span>
</span><span id="1-2524">
</span><span id="1-2525"><span class="sd">    In a non-stub file (i.e. a regular .py file), do the same but</span>
</span><span id="1-2526"><span class="sd">    follow it with an implementation.  The implementation should *not*</span>
</span><span id="1-2527"><span class="sd">    be decorated with @overload::</span>
</span><span id="1-2528">
</span><span id="1-2529"><span class="sd">        @overload</span>
</span><span id="1-2530"><span class="sd">        def utf8(value: None) -&gt; None: ...</span>
</span><span id="1-2531"><span class="sd">        @overload</span>
</span><span id="1-2532"><span class="sd">        def utf8(value: bytes) -&gt; bytes: ...</span>
</span><span id="1-2533"><span class="sd">        @overload</span>
</span><span id="1-2534"><span class="sd">        def utf8(value: str) -&gt; bytes: ...</span>
</span><span id="1-2535"><span class="sd">        def utf8(value):</span>
</span><span id="1-2536"><span class="sd">            ...  # implementation goes here</span>
</span><span id="1-2537">
</span><span id="1-2538"><span class="sd">    The overloads for a function can be retrieved at runtime using the</span>
</span><span id="1-2539"><span class="sd">    get_overloads() function.</span>
</span><span id="1-2540"><span class="sd">    &quot;&quot;&quot;</span>
</span><span id="1-2541">    <span class="c1"># classmethod and staticmethod</span>
</span><span id="1-2542">    <span class="n">f</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="s2">&quot;__func__&quot;</span><span class="p">,</span> <span class="n">func</span><span class="p">)</span>
</span><span id="1-2543">    <span class="k">try</span><span class="p">:</span>
</span><span id="1-2544">        <span class="n">_overload_registry</span><span class="p">[</span><span class="n">f</span><span class="o">.</span><span class="vm">__module__</span><span class="p">][</span><span class="n">f</span><span class="o">.</span><span class="vm">__qualname__</span><span class="p">][</span><span class="n">f</span><span class="o">.</span><span class="vm">__code__</span><span class="o">.</span><span class="n">co_firstlineno</span><span class="p">]</span> <span class="o">=</span> <span class="n">func</span>
</span><span id="1-2545">    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
</span><span id="1-2546">        <span class="c1"># Not a normal function; ignore.</span>
</span><span id="1-2547">        <span class="k">pass</span>
</span><span id="1-2548">    <span class="k">return</span> <span class="n">_overload_dummy</span>
</span><span id="1-2549">
</span><span id="1-2550">
</span><span id="1-2551"><span class="k">def</span><span class="w"> </span><span class="nf">get_overloads</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
</span><span id="1-2552"><span class="w">    </span><span class="sd">&quot;&quot;&quot;Return all defined overloads for *func* as a sequence.&quot;&quot;&quot;</span>
</span><span id="1-2553">    <span class="c1"># classmethod and staticmethod</span>
</span><span id="1-2554">    <span class="n">f</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="s2">&quot;__func__&quot;</span><span class="p">,</span> <span class="n">func</span><span class="p">)</span>
</span><span id="1-2555">    <span class="k">if</span> <span class="n">f</span><span class="o">.</span><span class="vm">__module__</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">_overload_registry</span><span class="p">:</span>
</span><span id="1-2556">        <span class="k">return</span> <span class="p">[]</span>
</span><span id="1-2557">    <span class="n">mod_dict</span> <span class="o">=</span> <span class="n">_overload_registry</span><span class="p">[</span><span class="n">f</span><span class="o">.</span><span class="vm">__module__</span><span class="p">]</span>
</span><span id="1-2558">    <span class="k">if</span> <span class="n">f</span><span class="o">.</span><span class="vm">__qualname__</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">mod_dict</span><span class="p">:</span>
</span><span id="1-2559">        <span class="k">return</span> <span class="p">[]</span>
</span><span id="1-2560">    <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">mod_dict</span><span class="p">[</span><span class="n">f</span><span class="o">.</span><span class="vm">__qualname__</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
</span><span id="1-2561">
</span><span id="1-2562">
</span><span id="1-2563"><span class="k">def</span><span class="w"> </span><span class="nf">clear_overloads</span><span class="p">():</span>
</span><span id="1-2564"><span class="w">    </span><span class="sd">&quot;&quot;&quot;Clear all overloads in the registry.&quot;&quot;&quot;</span>
</span><span id="1-2565">    <span class="n">_overload_registry</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
</span><span id="1-2566">
</span><span id="1-2567">
</span><span id="1-2568"><span class="k">def</span><span class="w"> </span><span class="nf">final</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
</span><span id="1-2569"><span class="w">    </span><span class="sd">&quot;&quot;&quot;Decorator to indicate final methods and final classes.</span>
</span><span id="1-2570">
</span><span id="1-2571"><span class="sd">    Use this decorator to indicate to type checkers that the decorated</span>
</span><span id="1-2572"><span class="sd">    method cannot be overridden, and decorated class cannot be subclassed.</span>
</span><span id="1-2573">
</span><span id="1-2574"><span class="sd">    For example::</span>
</span><span id="1-2575">
</span><span id="1-2576"><span class="sd">        class Base:</span>
</span><span id="1-2577"><span class="sd">            @final</span>
</span><span id="1-2578"><span class="sd">            def done(self) -&gt; None:</span>
</span><span id="1-2579"><span class="sd">                ...</span>
</span><span id="1-2580"><span class="sd">        class Sub(Base):</span>
</span><span id="1-2581"><span class="sd">            def done(self) -&gt; None:  # Error reported by type checker</span>
</span><span id="1-2582"><span class="sd">                ...</span>
</span><span id="1-2583">
</span><span id="1-2584"><span class="sd">        @final</span>
</span><span id="1-2585"><span class="sd">        class Leaf:</span>
</span><span id="1-2586"><span class="sd">            ...</span>
</span><span id="1-2587"><span class="sd">        class Other(Leaf):  # Error reported by type checker</span>
</span><span id="1-2588"><span class="sd">            ...</span>
</span><span id="1-2589">
</span><span id="1-2590"><span class="sd">    There is no runtime checking of these properties. The decorator</span>
</span><span id="1-2591"><span class="sd">    attempts to set the ``__final__`` attribute to ``True`` on the decorated</span>
</span><span id="1-2592"><span class="sd">    object to allow runtime introspection.</span>
</span><span id="1-2593"><span class="sd">    &quot;&quot;&quot;</span>
</span><span id="1-2594">    <span class="k">try</span><span class="p">:</span>
</span><span id="1-2595">        <span class="n">f</span><span class="o">.</span><span class="n">__final__</span> <span class="o">=</span> <span class="kc">True</span>
</span><span id="1-2596">    <span class="k">except</span> <span class="p">(</span><span class="ne">AttributeError</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">):</span>
</span><span id="1-2597">        <span class="c1"># Skip the attribute silently if it is not writable.</span>
</span><span id="1-2598">        <span class="c1"># AttributeError happens if the object has __slots__ or a</span>
</span><span id="1-2599">        <span class="c1"># read-only property, TypeError if it&#39;s a builtin class.</span>
</span><span id="1-2600">        <span class="k">pass</span>
</span><span id="1-2601">    <span class="k">return</span> <span class="n">f</span>
</span><span id="1-2602">
</span><span id="1-2603">
</span><span id="1-2604"><span class="c1"># Some unconstrained type variables.  These were initially used by the container types.</span>
</span><span id="1-2605"><span class="c1"># They were never meant for export and are now unused, but we keep them around to</span>
</span><span id="1-2606"><span class="c1"># avoid breaking compatibility with users who import them.</span>
</span><span id="1-2607"><span class="n">T</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>  <span class="c1"># Any type.</span>
</span><span id="1-2608"><span class="n">KT</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;KT&#39;</span><span class="p">)</span>  <span class="c1"># Key type.</span>
</span><span id="1-2609"><span class="n">VT</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;VT&#39;</span><span class="p">)</span>  <span class="c1"># Value type.</span>
</span><span id="1-2610"><span class="n">T_co</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;T_co&#39;</span><span class="p">,</span> <span class="n">covariant</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  <span class="c1"># Any type covariant containers.</span>
</span><span id="1-2611"><span class="n">V_co</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;V_co&#39;</span><span class="p">,</span> <span class="n">covariant</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  <span class="c1"># Any type covariant containers.</span>
</span><span id="1-2612"><span class="n">VT_co</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;VT_co&#39;</span><span class="p">,</span> <span class="n">covariant</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  <span class="c1"># Value type covariant containers.</span>
</span><span id="1-2613"><span class="n">T_contra</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;T_contra&#39;</span><span class="p">,</span> <span class="n">contravariant</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  <span class="c1"># Ditto contravariant.</span>
</span><span id="1-2614"><span class="c1"># Internal type variable used for Type[].</span>
</span><span id="1-2615"><span class="n">CT_co</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;CT_co&#39;</span><span class="p">,</span> <span class="n">covariant</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">bound</span><span class="o">=</span><span class="nb">type</span><span class="p">)</span>
</span><span id="1-2616">
</span><span id="1-2617">
</span><span id="1-2618"><span class="c1"># A useful type variable with constraints.  This represents string types.</span>
</span><span id="1-2619"><span class="c1"># (This one *is* for export!)</span>
</span><span id="1-2620"><span class="n">AnyStr</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;AnyStr&#39;</span><span class="p">,</span> <span class="nb">bytes</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
</span><span id="1-2621">
</span><span id="1-2622">
</span><span id="1-2623"><span class="c1"># Various ABCs mimicking those in collections.abc.</span>
</span><span id="1-2624"><span class="n">_alias</span> <span class="o">=</span> <span class="n">_SpecialGenericAlias</span>
</span><span id="1-2625">
</span><span id="1-2626"><span class="n">Hashable</span> <span class="o">=</span> <span class="n">_alias</span><span class="p">(</span><span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">Hashable</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>  <span class="c1"># Not generic.</span>
</span><span id="1-2627"><span class="n">Awaitable</span> <span class="o">=</span> <span class="n">_alias</span><span class="p">(</span><span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">Awaitable</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</span><span id="1-2628"><span class="n">Coroutine</span> <span class="o">=</span> <span class="n">_alias</span><span class="p">(</span><span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">Coroutine</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
</span><span id="1-2629"><span class="n">AsyncIterable</span> <span class="o">=</span> <span class="n">_alias</span><span class="p">(</span><span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">AsyncIterable</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</span><span id="1-2630"><span class="n">AsyncIterator</span> <span class="o">=</span> <span class="n">_alias</span><span class="p">(</span><span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">AsyncIterator</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</span><span id="1-2631"><span class="n">Iterable</span> <span class="o">=</span> <span class="n">_alias</span><span class="p">(</span><span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">Iterable</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</span><span id="1-2632"><span class="n">Iterator</span> <span class="o">=</span> <span class="n">_alias</span><span class="p">(</span><span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">Iterator</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</span><span id="1-2633"><span class="n">Reversible</span> <span class="o">=</span> <span class="n">_alias</span><span class="p">(</span><span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">Reversible</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</span><span id="1-2634"><span class="n">Sized</span> <span class="o">=</span> <span class="n">_alias</span><span class="p">(</span><span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">Sized</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>  <span class="c1"># Not generic.</span>
</span><span id="1-2635"><span class="n">Container</span> <span class="o">=</span> <span class="n">_alias</span><span class="p">(</span><span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</span><span id="1-2636"><span class="n">Collection</span> <span class="o">=</span> <span class="n">_alias</span><span class="p">(</span><span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">Collection</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</span><span id="1-2637"><span class="n">Callable</span> <span class="o">=</span> <span class="n">_CallableType</span><span class="p">(</span><span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">Callable</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
</span><span id="1-2638"><span class="n">Callable</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> \
</span><span id="1-2639"><span class="w">    </span><span class="sd">&quot;&quot;&quot;Deprecated alias to collections.abc.Callable.</span>
</span><span id="1-2640">
</span><span id="1-2641"><span class="sd">    Callable[[int], str] signifies a function that takes a single</span>
</span><span id="1-2642"><span class="sd">    parameter of type int and returns a str.</span>
</span><span id="1-2643">
</span><span id="1-2644"><span class="sd">    The subscription syntax must always be used with exactly two</span>
</span><span id="1-2645"><span class="sd">    values: the argument list and the return type.</span>
</span><span id="1-2646"><span class="sd">    The argument list must be a list of types, a ParamSpec,</span>
</span><span id="1-2647"><span class="sd">    Concatenate or ellipsis. The return type must be a single type.</span>
</span><span id="1-2648">
</span><span id="1-2649"><span class="sd">    There is no syntax to indicate optional or keyword arguments;</span>
</span><span id="1-2650"><span class="sd">    such function types are rarely used as callback types.</span>
</span><span id="1-2651"><span class="sd">    &quot;&quot;&quot;</span>
</span><span id="1-2652"><span class="n">AbstractSet</span> <span class="o">=</span> <span class="n">_alias</span><span class="p">(</span><span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">Set</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;AbstractSet&#39;</span><span class="p">)</span>
</span><span id="1-2653"><span class="n">MutableSet</span> <span class="o">=</span> <span class="n">_alias</span><span class="p">(</span><span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">MutableSet</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</span><span id="1-2654"><span class="c1"># NOTE: Mapping is only covariant in the value type.</span>
</span><span id="1-2655"><span class="n">Mapping</span> <span class="o">=</span> <span class="n">_alias</span><span class="p">(</span><span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">Mapping</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
</span><span id="1-2656"><span class="n">MutableMapping</span> <span class="o">=</span> <span class="n">_alias</span><span class="p">(</span><span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">MutableMapping</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
</span><span id="1-2657"><span class="n">Sequence</span> <span class="o">=</span> <span class="n">_alias</span><span class="p">(</span><span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">Sequence</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</span><span id="1-2658"><span class="n">MutableSequence</span> <span class="o">=</span> <span class="n">_alias</span><span class="p">(</span><span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">MutableSequence</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</span><span id="1-2659"><span class="n">ByteString</span> <span class="o">=</span> <span class="n">_DeprecatedGenericAlias</span><span class="p">(</span>
</span><span id="1-2660">    <span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">ByteString</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">removal_version</span><span class="o">=</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">14</span><span class="p">)</span>  <span class="c1"># Not generic.</span>
</span><span id="1-2661"><span class="p">)</span>
</span><span id="1-2662"><span class="c1"># Tuple accepts variable number of parameters.</span>
</span><span id="1-2663"><span class="n">Tuple</span> <span class="o">=</span> <span class="n">_TupleType</span><span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">inst</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;Tuple&#39;</span><span class="p">)</span>
</span><span id="1-2664"><span class="n">Tuple</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> \
</span><span id="1-2665"><span class="w">    </span><span class="sd">&quot;&quot;&quot;Deprecated alias to builtins.tuple.</span>
</span><span id="1-2666">
</span><span id="1-2667"><span class="sd">    Tuple[X, Y] is the cross-product type of X and Y.</span>
</span><span id="1-2668">
</span><span id="1-2669"><span class="sd">    Example: Tuple[T1, T2] is a tuple of two elements corresponding</span>
</span><span id="1-2670"><span class="sd">    to type variables T1 and T2.  Tuple[int, float, str] is a tuple</span>
</span><span id="1-2671"><span class="sd">    of an int, a float and a string.</span>
</span><span id="1-2672">
</span><span id="1-2673"><span class="sd">    To specify a variable-length tuple of homogeneous type, use Tuple[T, ...].</span>
</span><span id="1-2674"><span class="sd">    &quot;&quot;&quot;</span>
</span><span id="1-2675"><span class="n">List</span> <span class="o">=</span> <span class="n">_alias</span><span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">inst</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;List&#39;</span><span class="p">)</span>
</span><span id="1-2676"><span class="n">Deque</span> <span class="o">=</span> <span class="n">_alias</span><span class="p">(</span><span class="n">collections</span><span class="o">.</span><span class="n">deque</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;Deque&#39;</span><span class="p">)</span>
</span><span id="1-2677"><span class="n">Set</span> <span class="o">=</span> <span class="n">_alias</span><span class="p">(</span><span class="nb">set</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">inst</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;Set&#39;</span><span class="p">)</span>
</span><span id="1-2678"><span class="n">FrozenSet</span> <span class="o">=</span> <span class="n">_alias</span><span class="p">(</span><span class="nb">frozenset</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">inst</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;FrozenSet&#39;</span><span class="p">)</span>
</span><span id="1-2679"><span class="n">MappingView</span> <span class="o">=</span> <span class="n">_alias</span><span class="p">(</span><span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">MappingView</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</span><span id="1-2680"><span class="n">KeysView</span> <span class="o">=</span> <span class="n">_alias</span><span class="p">(</span><span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">KeysView</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</span><span id="1-2681"><span class="n">ItemsView</span> <span class="o">=</span> <span class="n">_alias</span><span class="p">(</span><span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">ItemsView</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
</span><span id="1-2682"><span class="n">ValuesView</span> <span class="o">=</span> <span class="n">_alias</span><span class="p">(</span><span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">ValuesView</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</span><span id="1-2683"><span class="n">ContextManager</span> <span class="o">=</span> <span class="n">_alias</span><span class="p">(</span><span class="n">contextlib</span><span class="o">.</span><span class="n">AbstractContextManager</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;ContextManager&#39;</span><span class="p">)</span>
</span><span id="1-2684"><span class="n">AsyncContextManager</span> <span class="o">=</span> <span class="n">_alias</span><span class="p">(</span><span class="n">contextlib</span><span class="o">.</span><span class="n">AbstractAsyncContextManager</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;AsyncContextManager&#39;</span><span class="p">)</span>
</span><span id="1-2685"><span class="n">Dict</span> <span class="o">=</span> <span class="n">_alias</span><span class="p">(</span><span class="nb">dict</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">inst</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;Dict&#39;</span><span class="p">)</span>
</span><span id="1-2686"><span class="n">DefaultDict</span> <span class="o">=</span> <span class="n">_alias</span><span class="p">(</span><span class="n">collections</span><span class="o">.</span><span class="n">defaultdict</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;DefaultDict&#39;</span><span class="p">)</span>
</span><span id="1-2687"><span class="n">OrderedDict</span> <span class="o">=</span> <span class="n">_alias</span><span class="p">(</span><span class="n">collections</span><span class="o">.</span><span class="n">OrderedDict</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
</span><span id="1-2688"><span class="n">Counter</span> <span class="o">=</span> <span class="n">_alias</span><span class="p">(</span><span class="n">collections</span><span class="o">.</span><span class="n">Counter</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</span><span id="1-2689"><span class="n">ChainMap</span> <span class="o">=</span> <span class="n">_alias</span><span class="p">(</span><span class="n">collections</span><span class="o">.</span><span class="n">ChainMap</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
</span><span id="1-2690"><span class="n">Generator</span> <span class="o">=</span> <span class="n">_alias</span><span class="p">(</span><span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">Generator</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
</span><span id="1-2691"><span class="n">AsyncGenerator</span> <span class="o">=</span> <span class="n">_alias</span><span class="p">(</span><span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">AsyncGenerator</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
</span><span id="1-2692"><span class="n">Type</span> <span class="o">=</span> <span class="n">_alias</span><span class="p">(</span><span class="nb">type</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">inst</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;Type&#39;</span><span class="p">)</span>
</span><span id="1-2693"><span class="n">Type</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> \
</span><span id="1-2694"><span class="w">    </span><span class="sd">&quot;&quot;&quot;Deprecated alias to builtins.type.</span>
</span><span id="1-2695">
</span><span id="1-2696"><span class="sd">    builtins.type or typing.Type can be used to annotate class objects.</span>
</span><span id="1-2697"><span class="sd">    For example, suppose we have the following classes::</span>
</span><span id="1-2698">
</span><span id="1-2699"><span class="sd">        class User: ...  # Abstract base for User classes</span>
</span><span id="1-2700"><span class="sd">        class BasicUser(User): ...</span>
</span><span id="1-2701"><span class="sd">        class ProUser(User): ...</span>
</span><span id="1-2702"><span class="sd">        class TeamUser(User): ...</span>
</span><span id="1-2703">
</span><span id="1-2704"><span class="sd">    And a function that takes a class argument that&#39;s a subclass of</span>
</span><span id="1-2705"><span class="sd">    User and returns an instance of the corresponding class::</span>
</span><span id="1-2706">
</span><span id="1-2707"><span class="sd">        def new_user[U](user_class: Type[U]) -&gt; U:</span>
</span><span id="1-2708"><span class="sd">            user = user_class()</span>
</span><span id="1-2709"><span class="sd">            # (Here we could write the user object to a database)</span>
</span><span id="1-2710"><span class="sd">            return user</span>
</span><span id="1-2711">
</span><span id="1-2712"><span class="sd">        joe = new_user(BasicUser)</span>
</span><span id="1-2713">
</span><span id="1-2714"><span class="sd">    At this point the type checker knows that joe has type BasicUser.</span>
</span><span id="1-2715"><span class="sd">    &quot;&quot;&quot;</span>
</span><span id="1-2716">
</span><span id="1-2717">
</span><span id="1-2718"><span class="nd">@runtime_checkable</span>
</span><span id="1-2719"><span class="k">class</span><span class="w"> </span><span class="nc">SupportsInt</span><span class="p">(</span><span class="n">Protocol</span><span class="p">):</span>
</span><span id="1-2720"><span class="w">    </span><span class="sd">&quot;&quot;&quot;An ABC with one abstract method __int__.&quot;&quot;&quot;</span>
</span><span id="1-2721">
</span><span id="1-2722">    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">()</span>
</span><span id="1-2723">
</span><span id="1-2724">    <span class="nd">@abstractmethod</span>
</span><span id="1-2725">    <span class="k">def</span><span class="w"> </span><span class="fm">__int__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
</span><span id="1-2726">        <span class="k">pass</span>
</span><span id="1-2727">
</span><span id="1-2728">
</span><span id="1-2729"><span class="nd">@runtime_checkable</span>
</span><span id="1-2730"><span class="k">class</span><span class="w"> </span><span class="nc">SupportsFloat</span><span class="p">(</span><span class="n">Protocol</span><span class="p">):</span>
</span><span id="1-2731"><span class="w">    </span><span class="sd">&quot;&quot;&quot;An ABC with one abstract method __float__.&quot;&quot;&quot;</span>
</span><span id="1-2732">
</span><span id="1-2733">    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">()</span>
</span><span id="1-2734">
</span><span id="1-2735">    <span class="nd">@abstractmethod</span>
</span><span id="1-2736">    <span class="k">def</span><span class="w"> </span><span class="fm">__float__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
</span><span id="1-2737">        <span class="k">pass</span>
</span><span id="1-2738">
</span><span id="1-2739">
</span><span id="1-2740"><span class="nd">@runtime_checkable</span>
</span><span id="1-2741"><span class="k">class</span><span class="w"> </span><span class="nc">SupportsComplex</span><span class="p">(</span><span class="n">Protocol</span><span class="p">):</span>
</span><span id="1-2742"><span class="w">    </span><span class="sd">&quot;&quot;&quot;An ABC with one abstract method __complex__.&quot;&quot;&quot;</span>
</span><span id="1-2743">
</span><span id="1-2744">    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">()</span>
</span><span id="1-2745">
</span><span id="1-2746">    <span class="nd">@abstractmethod</span>
</span><span id="1-2747">    <span class="k">def</span><span class="w"> </span><span class="fm">__complex__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">complex</span><span class="p">:</span>
</span><span id="1-2748">        <span class="k">pass</span>
</span><span id="1-2749">
</span><span id="1-2750">
</span><span id="1-2751"><span class="nd">@runtime_checkable</span>
</span><span id="1-2752"><span class="k">class</span><span class="w"> </span><span class="nc">SupportsBytes</span><span class="p">(</span><span class="n">Protocol</span><span class="p">):</span>
</span><span id="1-2753"><span class="w">    </span><span class="sd">&quot;&quot;&quot;An ABC with one abstract method __bytes__.&quot;&quot;&quot;</span>
</span><span id="1-2754">
</span><span id="1-2755">    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">()</span>
</span><span id="1-2756">
</span><span id="1-2757">    <span class="nd">@abstractmethod</span>
</span><span id="1-2758">    <span class="k">def</span><span class="w"> </span><span class="fm">__bytes__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bytes</span><span class="p">:</span>
</span><span id="1-2759">        <span class="k">pass</span>
</span><span id="1-2760">
</span><span id="1-2761">
</span><span id="1-2762"><span class="nd">@runtime_checkable</span>
</span><span id="1-2763"><span class="k">class</span><span class="w"> </span><span class="nc">SupportsIndex</span><span class="p">(</span><span class="n">Protocol</span><span class="p">):</span>
</span><span id="1-2764"><span class="w">    </span><span class="sd">&quot;&quot;&quot;An ABC with one abstract method __index__.&quot;&quot;&quot;</span>
</span><span id="1-2765">
</span><span id="1-2766">    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">()</span>
</span><span id="1-2767">
</span><span id="1-2768">    <span class="nd">@abstractmethod</span>
</span><span id="1-2769">    <span class="k">def</span><span class="w"> </span><span class="fm">__index__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
</span><span id="1-2770">        <span class="k">pass</span>
</span><span id="1-2771">
</span><span id="1-2772">
</span><span id="1-2773"><span class="nd">@runtime_checkable</span>
</span><span id="1-2774"><span class="k">class</span><span class="w"> </span><span class="nc">SupportsAbs</span><span class="p">[</span><span class="n">T</span><span class="p">](</span><span class="n">Protocol</span><span class="p">):</span>
</span><span id="1-2775"><span class="w">    </span><span class="sd">&quot;&quot;&quot;An ABC with one abstract method __abs__ that is covariant in its return type.&quot;&quot;&quot;</span>
</span><span id="1-2776">
</span><span id="1-2777">    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">()</span>
</span><span id="1-2778">
</span><span id="1-2779">    <span class="nd">@abstractmethod</span>
</span><span id="1-2780">    <span class="k">def</span><span class="w"> </span><span class="fm">__abs__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">T</span><span class="p">:</span>
</span><span id="1-2781">        <span class="k">pass</span>
</span><span id="1-2782">
</span><span id="1-2783">
</span><span id="1-2784"><span class="nd">@runtime_checkable</span>
</span><span id="1-2785"><span class="k">class</span><span class="w"> </span><span class="nc">SupportsRound</span><span class="p">[</span><span class="n">T</span><span class="p">](</span><span class="n">Protocol</span><span class="p">):</span>
</span><span id="1-2786"><span class="w">    </span><span class="sd">&quot;&quot;&quot;An ABC with one abstract method __round__ that is covariant in its return type.&quot;&quot;&quot;</span>
</span><span id="1-2787">
</span><span id="1-2788">    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">()</span>
</span><span id="1-2789">
</span><span id="1-2790">    <span class="nd">@abstractmethod</span>
</span><span id="1-2791">    <span class="k">def</span><span class="w"> </span><span class="fm">__round__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ndigits</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">T</span><span class="p">:</span>
</span><span id="1-2792">        <span class="k">pass</span>
</span><span id="1-2793">
</span><span id="1-2794">
</span><span id="1-2795"><span class="k">def</span><span class="w"> </span><span class="nf">_make_nmtuple</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">types</span><span class="p">,</span> <span class="n">module</span><span class="p">,</span> <span class="n">defaults</span> <span class="o">=</span> <span class="p">()):</span>
</span><span id="1-2796">    <span class="n">fields</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">types</span><span class="p">]</span>
</span><span id="1-2797">    <span class="n">types</span> <span class="o">=</span> <span class="p">{</span><span class="n">n</span><span class="p">:</span> <span class="n">_type_check</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;field </span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s2"> annotation must be a type&quot;</span><span class="p">)</span>
</span><span id="1-2798">             <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">types</span><span class="p">}</span>
</span><span id="1-2799">    <span class="n">nm_tpl</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">namedtuple</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">fields</span><span class="p">,</span>
</span><span id="1-2800">                                    <span class="n">defaults</span><span class="o">=</span><span class="n">defaults</span><span class="p">,</span> <span class="n">module</span><span class="o">=</span><span class="n">module</span><span class="p">)</span>
</span><span id="1-2801">    <span class="n">nm_tpl</span><span class="o">.</span><span class="vm">__annotations__</span> <span class="o">=</span> <span class="n">nm_tpl</span><span class="o">.</span><span class="fm">__new__</span><span class="o">.</span><span class="vm">__annotations__</span> <span class="o">=</span> <span class="n">types</span>
</span><span id="1-2802">    <span class="k">return</span> <span class="n">nm_tpl</span>
</span><span id="1-2803">
</span><span id="1-2804">
</span><span id="1-2805"><span class="c1"># attributes prohibited to set in NamedTuple class syntax</span>
</span><span id="1-2806"><span class="n">_prohibited</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">({</span><span class="s1">&#39;__new__&#39;</span><span class="p">,</span> <span class="s1">&#39;__init__&#39;</span><span class="p">,</span> <span class="s1">&#39;__slots__&#39;</span><span class="p">,</span> <span class="s1">&#39;__getnewargs__&#39;</span><span class="p">,</span>
</span><span id="1-2807">                         <span class="s1">&#39;_fields&#39;</span><span class="p">,</span> <span class="s1">&#39;_field_defaults&#39;</span><span class="p">,</span>
</span><span id="1-2808">                         <span class="s1">&#39;_make&#39;</span><span class="p">,</span> <span class="s1">&#39;_replace&#39;</span><span class="p">,</span> <span class="s1">&#39;_asdict&#39;</span><span class="p">,</span> <span class="s1">&#39;_source&#39;</span><span class="p">})</span>
</span><span id="1-2809">
</span><span id="1-2810"><span class="n">_special</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">({</span><span class="s1">&#39;__module__&#39;</span><span class="p">,</span> <span class="s1">&#39;__name__&#39;</span><span class="p">,</span> <span class="s1">&#39;__annotations__&#39;</span><span class="p">})</span>
</span><span id="1-2811">
</span><span id="1-2812">
</span><span id="1-2813"><span class="k">class</span><span class="w"> </span><span class="nc">NamedTupleMeta</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>
</span><span id="1-2814">    <span class="k">def</span><span class="w"> </span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">typename</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">ns</span><span class="p">):</span>
</span><span id="1-2815">        <span class="k">assert</span> <span class="n">_NamedTuple</span> <span class="ow">in</span> <span class="n">bases</span>
</span><span id="1-2816">        <span class="k">for</span> <span class="n">base</span> <span class="ow">in</span> <span class="n">bases</span><span class="p">:</span>
</span><span id="1-2817">            <span class="k">if</span> <span class="n">base</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">_NamedTuple</span> <span class="ow">and</span> <span class="n">base</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">Generic</span><span class="p">:</span>
</span><span id="1-2818">                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
</span><span id="1-2819">                    <span class="s1">&#39;can only inherit from a NamedTuple type and Generic&#39;</span><span class="p">)</span>
</span><span id="1-2820">        <span class="n">bases</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">tuple</span> <span class="k">if</span> <span class="n">base</span> <span class="ow">is</span> <span class="n">_NamedTuple</span> <span class="k">else</span> <span class="n">base</span> <span class="k">for</span> <span class="n">base</span> <span class="ow">in</span> <span class="n">bases</span><span class="p">)</span>
</span><span id="1-2821">        <span class="n">types</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;__annotations__&#39;</span><span class="p">,</span> <span class="p">{})</span>
</span><span id="1-2822">        <span class="n">default_names</span> <span class="o">=</span> <span class="p">[]</span>
</span><span id="1-2823">        <span class="k">for</span> <span class="n">field_name</span> <span class="ow">in</span> <span class="n">types</span><span class="p">:</span>
</span><span id="1-2824">            <span class="k">if</span> <span class="n">field_name</span> <span class="ow">in</span> <span class="n">ns</span><span class="p">:</span>
</span><span id="1-2825">                <span class="n">default_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">field_name</span><span class="p">)</span>
</span><span id="1-2826">            <span class="k">elif</span> <span class="n">default_names</span><span class="p">:</span>
</span><span id="1-2827">                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Non-default namedtuple field </span><span class="si">{</span><span class="n">field_name</span><span class="si">}</span><span class="s2"> &quot;</span>
</span><span id="1-2828">                                <span class="sa">f</span><span class="s2">&quot;cannot follow default field&quot;</span>
</span><span id="1-2829">                                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="s1">&#39;s&#39;</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="nb">len</span><span class="p">(</span><span class="n">default_names</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="s1">&#39;&#39;</span><span class="si">}</span><span class="s2"> &quot;</span>
</span><span id="1-2830">                                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">default_names</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</span><span id="1-2831">        <span class="n">nm_tpl</span> <span class="o">=</span> <span class="n">_make_nmtuple</span><span class="p">(</span><span class="n">typename</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">items</span><span class="p">(),</span>
</span><span id="1-2832">                               <span class="n">defaults</span><span class="o">=</span><span class="p">[</span><span class="n">ns</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">default_names</span><span class="p">],</span>
</span><span id="1-2833">                               <span class="n">module</span><span class="o">=</span><span class="n">ns</span><span class="p">[</span><span class="s1">&#39;__module__&#39;</span><span class="p">])</span>
</span><span id="1-2834">        <span class="n">nm_tpl</span><span class="o">.</span><span class="vm">__bases__</span> <span class="o">=</span> <span class="n">bases</span>
</span><span id="1-2835">        <span class="k">if</span> <span class="n">Generic</span> <span class="ow">in</span> <span class="n">bases</span><span class="p">:</span>
</span><span id="1-2836">            <span class="n">class_getitem</span> <span class="o">=</span> <span class="n">_generic_class_getitem</span>
</span><span id="1-2837">            <span class="n">nm_tpl</span><span class="o">.</span><span class="n">__class_getitem__</span> <span class="o">=</span> <span class="nb">classmethod</span><span class="p">(</span><span class="n">class_getitem</span><span class="p">)</span>
</span><span id="1-2838">        <span class="c1"># update from user namespace without overriding special namedtuple attributes</span>
</span><span id="1-2839">        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">ns</span><span class="p">:</span>
</span><span id="1-2840">            <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">_prohibited</span><span class="p">:</span>
</span><span id="1-2841">                <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;Cannot overwrite NamedTuple attribute &quot;</span> <span class="o">+</span> <span class="n">key</span><span class="p">)</span>
</span><span id="1-2842">            <span class="k">elif</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">_special</span> <span class="ow">and</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">nm_tpl</span><span class="o">.</span><span class="n">_fields</span><span class="p">:</span>
</span><span id="1-2843">                <span class="nb">setattr</span><span class="p">(</span><span class="n">nm_tpl</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">ns</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>
</span><span id="1-2844">        <span class="k">if</span> <span class="n">Generic</span> <span class="ow">in</span> <span class="n">bases</span><span class="p">:</span>
</span><span id="1-2845">            <span class="n">nm_tpl</span><span class="o">.</span><span class="n">__init_subclass__</span><span class="p">()</span>
</span><span id="1-2846">        <span class="k">return</span> <span class="n">nm_tpl</span>
</span><span id="1-2847">
</span><span id="1-2848">
</span><span id="1-2849"><span class="k">def</span><span class="w"> </span><span class="nf">NamedTuple</span><span class="p">(</span><span class="n">typename</span><span class="p">,</span> <span class="n">fields</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
</span><span id="1-2850"><span class="w">    </span><span class="sd">&quot;&quot;&quot;Typed version of namedtuple.</span>
</span><span id="1-2851">
</span><span id="1-2852"><span class="sd">    Usage::</span>
</span><span id="1-2853">
</span><span id="1-2854"><span class="sd">        class Employee(NamedTuple):</span>
</span><span id="1-2855"><span class="sd">            name: str</span>
</span><span id="1-2856"><span class="sd">            id: int</span>
</span><span id="1-2857">
</span><span id="1-2858"><span class="sd">    This is equivalent to::</span>
</span><span id="1-2859">
</span><span id="1-2860"><span class="sd">        Employee = collections.namedtuple(&#39;Employee&#39;, [&#39;name&#39;, &#39;id&#39;])</span>
</span><span id="1-2861">
</span><span id="1-2862"><span class="sd">    The resulting class has an extra __annotations__ attribute, giving a</span>
</span><span id="1-2863"><span class="sd">    dict that maps field names to types.  (The field names are also in</span>
</span><span id="1-2864"><span class="sd">    the _fields attribute, which is part of the namedtuple API.)</span>
</span><span id="1-2865"><span class="sd">    An alternative equivalent functional syntax is also accepted::</span>
</span><span id="1-2866">
</span><span id="1-2867"><span class="sd">        Employee = NamedTuple(&#39;Employee&#39;, [(&#39;name&#39;, str), (&#39;id&#39;, int)])</span>
</span><span id="1-2868"><span class="sd">    &quot;&quot;&quot;</span>
</span><span id="1-2869">    <span class="k">if</span> <span class="n">fields</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
</span><span id="1-2870">        <span class="n">fields</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
</span><span id="1-2871">    <span class="k">elif</span> <span class="n">kwargs</span><span class="p">:</span>
</span><span id="1-2872">        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Either list of fields or keywords&quot;</span>
</span><span id="1-2873">                        <span class="s2">&quot; can be provided to NamedTuple, not both&quot;</span><span class="p">)</span>
</span><span id="1-2874">    <span class="n">nt</span> <span class="o">=</span> <span class="n">_make_nmtuple</span><span class="p">(</span><span class="n">typename</span><span class="p">,</span> <span class="n">fields</span><span class="p">,</span> <span class="n">module</span><span class="o">=</span><span class="n">_caller</span><span class="p">())</span>
</span><span id="1-2875">    <span class="n">nt</span><span class="o">.</span><span class="n">__orig_bases__</span> <span class="o">=</span> <span class="p">(</span><span class="n">NamedTuple</span><span class="p">,)</span>
</span><span id="1-2876">    <span class="k">return</span> <span class="n">nt</span>
</span><span id="1-2877">
</span><span id="1-2878"><span class="n">_NamedTuple</span> <span class="o">=</span> <span class="nb">type</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="n">NamedTupleMeta</span><span class="p">,</span> <span class="s1">&#39;NamedTuple&#39;</span><span class="p">,</span> <span class="p">(),</span> <span class="p">{})</span>
</span><span id="1-2879">
</span><span id="1-2880"><span class="k">def</span><span class="w"> </span><span class="nf">_namedtuple_mro_entries</span><span class="p">(</span><span class="n">bases</span><span class="p">):</span>
</span><span id="1-2881">    <span class="k">assert</span> <span class="n">NamedTuple</span> <span class="ow">in</span> <span class="n">bases</span>
</span><span id="1-2882">    <span class="k">return</span> <span class="p">(</span><span class="n">_NamedTuple</span><span class="p">,)</span>
</span><span id="1-2883">
</span><span id="1-2884"><span class="n">NamedTuple</span><span class="o">.</span><span class="n">__mro_entries__</span> <span class="o">=</span> <span class="n">_namedtuple_mro_entries</span>
</span><span id="1-2885">
</span><span id="1-2886">
</span><span id="1-2887"><span class="k">class</span><span class="w"> </span><span class="nc">_TypedDictMeta</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>
</span><span id="1-2888">    <span class="k">def</span><span class="w"> </span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">ns</span><span class="p">,</span> <span class="n">total</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
</span><span id="1-2889"><span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a new typed dict class object.</span>
</span><span id="1-2890">
</span><span id="1-2891"><span class="sd">        This method is called when TypedDict is subclassed,</span>
</span><span id="1-2892"><span class="sd">        or when TypedDict is instantiated. This way</span>
</span><span id="1-2893"><span class="sd">        TypedDict supports all three syntax forms described in its docstring.</span>
</span><span id="1-2894"><span class="sd">        Subclasses and instances of TypedDict return actual dictionaries.</span>
</span><span id="1-2895"><span class="sd">        &quot;&quot;&quot;</span>
</span><span id="1-2896">        <span class="k">for</span> <span class="n">base</span> <span class="ow">in</span> <span class="n">bases</span><span class="p">:</span>
</span><span id="1-2897">            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">base</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">_TypedDictMeta</span> <span class="ow">and</span> <span class="n">base</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">Generic</span><span class="p">:</span>
</span><span id="1-2898">                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;cannot inherit from both a TypedDict type &#39;</span>
</span><span id="1-2899">                                <span class="s1">&#39;and a non-TypedDict base class&#39;</span><span class="p">)</span>
</span><span id="1-2900">
</span><span id="1-2901">        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="nb">issubclass</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">Generic</span><span class="p">)</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">bases</span><span class="p">):</span>
</span><span id="1-2902">            <span class="n">generic_base</span> <span class="o">=</span> <span class="p">(</span><span class="n">Generic</span><span class="p">,)</span>
</span><span id="1-2903">        <span class="k">else</span><span class="p">:</span>
</span><span id="1-2904">            <span class="n">generic_base</span> <span class="o">=</span> <span class="p">()</span>
</span><span id="1-2905">
</span><span id="1-2906">        <span class="n">tp_dict</span> <span class="o">=</span> <span class="nb">type</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="n">_TypedDictMeta</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="p">(</span><span class="o">*</span><span class="n">generic_base</span><span class="p">,</span> <span class="nb">dict</span><span class="p">),</span> <span class="n">ns</span><span class="p">)</span>
</span><span id="1-2907">
</span><span id="1-2908">        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">tp_dict</span><span class="p">,</span> <span class="s1">&#39;__orig_bases__&#39;</span><span class="p">):</span>
</span><span id="1-2909">            <span class="n">tp_dict</span><span class="o">.</span><span class="n">__orig_bases__</span> <span class="o">=</span> <span class="n">bases</span>
</span><span id="1-2910">
</span><span id="1-2911">        <span class="n">annotations</span> <span class="o">=</span> <span class="p">{}</span>
</span><span id="1-2912">        <span class="n">own_annotations</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;__annotations__&#39;</span><span class="p">,</span> <span class="p">{})</span>
</span><span id="1-2913">        <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;TypedDict(&#39;Name&#39;, {f0: t0, f1: t1, ...}); each t must be a type&quot;</span>
</span><span id="1-2914">        <span class="n">own_annotations</span> <span class="o">=</span> <span class="p">{</span>
</span><span id="1-2915">            <span class="n">n</span><span class="p">:</span> <span class="n">_type_check</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">module</span><span class="o">=</span><span class="n">tp_dict</span><span class="o">.</span><span class="vm">__module__</span><span class="p">)</span>
</span><span id="1-2916">            <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">tp</span> <span class="ow">in</span> <span class="n">own_annotations</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
</span><span id="1-2917">        <span class="p">}</span>
</span><span id="1-2918">        <span class="n">required_keys</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
</span><span id="1-2919">        <span class="n">optional_keys</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
</span><span id="1-2920">
</span><span id="1-2921">        <span class="k">for</span> <span class="n">base</span> <span class="ow">in</span> <span class="n">bases</span><span class="p">:</span>
</span><span id="1-2922">            <span class="n">annotations</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">base</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;__annotations__&#39;</span><span class="p">,</span> <span class="p">{}))</span>
</span><span id="1-2923">
</span><span id="1-2924">            <span class="n">base_required</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;__required_keys__&#39;</span><span class="p">,</span> <span class="nb">set</span><span class="p">())</span>
</span><span id="1-2925">            <span class="n">required_keys</span> <span class="o">|=</span> <span class="n">base_required</span>
</span><span id="1-2926">            <span class="n">optional_keys</span> <span class="o">-=</span> <span class="n">base_required</span>
</span><span id="1-2927">
</span><span id="1-2928">            <span class="n">base_optional</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;__optional_keys__&#39;</span><span class="p">,</span> <span class="nb">set</span><span class="p">())</span>
</span><span id="1-2929">            <span class="n">required_keys</span> <span class="o">-=</span> <span class="n">base_optional</span>
</span><span id="1-2930">            <span class="n">optional_keys</span> <span class="o">|=</span> <span class="n">base_optional</span>
</span><span id="1-2931">
</span><span id="1-2932">        <span class="n">annotations</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">own_annotations</span><span class="p">)</span>
</span><span id="1-2933">        <span class="k">for</span> <span class="n">annotation_key</span><span class="p">,</span> <span class="n">annotation_type</span> <span class="ow">in</span> <span class="n">own_annotations</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
</span><span id="1-2934">            <span class="n">annotation_origin</span> <span class="o">=</span> <span class="n">get_origin</span><span class="p">(</span><span class="n">annotation_type</span><span class="p">)</span>
</span><span id="1-2935">            <span class="k">if</span> <span class="n">annotation_origin</span> <span class="ow">is</span> <span class="n">Annotated</span><span class="p">:</span>
</span><span id="1-2936">                <span class="n">annotation_args</span> <span class="o">=</span> <span class="n">get_args</span><span class="p">(</span><span class="n">annotation_type</span><span class="p">)</span>
</span><span id="1-2937">                <span class="k">if</span> <span class="n">annotation_args</span><span class="p">:</span>
</span><span id="1-2938">                    <span class="n">annotation_type</span> <span class="o">=</span> <span class="n">annotation_args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</span><span id="1-2939">                    <span class="n">annotation_origin</span> <span class="o">=</span> <span class="n">get_origin</span><span class="p">(</span><span class="n">annotation_type</span><span class="p">)</span>
</span><span id="1-2940">
</span><span id="1-2941">            <span class="k">if</span> <span class="n">annotation_origin</span> <span class="ow">is</span> <span class="n">Required</span><span class="p">:</span>
</span><span id="1-2942">                <span class="n">is_required</span> <span class="o">=</span> <span class="kc">True</span>
</span><span id="1-2943">            <span class="k">elif</span> <span class="n">annotation_origin</span> <span class="ow">is</span> <span class="n">NotRequired</span><span class="p">:</span>
</span><span id="1-2944">                <span class="n">is_required</span> <span class="o">=</span> <span class="kc">False</span>
</span><span id="1-2945">            <span class="k">else</span><span class="p">:</span>
</span><span id="1-2946">                <span class="n">is_required</span> <span class="o">=</span> <span class="n">total</span>
</span><span id="1-2947">
</span><span id="1-2948">            <span class="k">if</span> <span class="n">is_required</span><span class="p">:</span>
</span><span id="1-2949">                <span class="n">required_keys</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">annotation_key</span><span class="p">)</span>
</span><span id="1-2950">                <span class="n">optional_keys</span><span class="o">.</span><span class="n">discard</span><span class="p">(</span><span class="n">annotation_key</span><span class="p">)</span>
</span><span id="1-2951">            <span class="k">else</span><span class="p">:</span>
</span><span id="1-2952">                <span class="n">optional_keys</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">annotation_key</span><span class="p">)</span>
</span><span id="1-2953">                <span class="n">required_keys</span><span class="o">.</span><span class="n">discard</span><span class="p">(</span><span class="n">annotation_key</span><span class="p">)</span>
</span><span id="1-2954">
</span><span id="1-2955">        <span class="k">assert</span> <span class="n">required_keys</span><span class="o">.</span><span class="n">isdisjoint</span><span class="p">(</span><span class="n">optional_keys</span><span class="p">),</span> <span class="p">(</span>
</span><span id="1-2956">            <span class="sa">f</span><span class="s2">&quot;Required keys overlap with optional keys in </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">:&quot;</span>
</span><span id="1-2957">            <span class="sa">f</span><span class="s2">&quot; </span><span class="si">{</span><span class="n">required_keys</span><span class="si">=}</span><span class="s2">, </span><span class="si">{</span><span class="n">optional_keys</span><span class="si">=}</span><span class="s2">&quot;</span>
</span><span id="1-2958">        <span class="p">)</span>
</span><span id="1-2959">        <span class="n">tp_dict</span><span class="o">.</span><span class="vm">__annotations__</span> <span class="o">=</span> <span class="n">annotations</span>
</span><span id="1-2960">        <span class="n">tp_dict</span><span class="o">.</span><span class="n">__required_keys__</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">(</span><span class="n">required_keys</span><span class="p">)</span>
</span><span id="1-2961">        <span class="n">tp_dict</span><span class="o">.</span><span class="n">__optional_keys__</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">(</span><span class="n">optional_keys</span><span class="p">)</span>
</span><span id="1-2962">        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">tp_dict</span><span class="p">,</span> <span class="s1">&#39;__total__&#39;</span><span class="p">):</span>
</span><span id="1-2963">            <span class="n">tp_dict</span><span class="o">.</span><span class="n">__total__</span> <span class="o">=</span> <span class="n">total</span>
</span><span id="1-2964">        <span class="k">return</span> <span class="n">tp_dict</span>
</span><span id="1-2965">
</span><span id="1-2966">    <span class="fm">__call__</span> <span class="o">=</span> <span class="nb">dict</span>  <span class="c1"># static method</span>
</span><span id="1-2967">
</span><span id="1-2968">    <span class="k">def</span><span class="w"> </span><span class="fm">__subclasscheck__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
</span><span id="1-2969">        <span class="c1"># Typed dicts are only for static structural subtyping.</span>
</span><span id="1-2970">        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;TypedDict does not support instance and class checks&#39;</span><span class="p">)</span>
</span><span id="1-2971">
</span><span id="1-2972">    <span class="fm">__instancecheck__</span> <span class="o">=</span> <span class="fm">__subclasscheck__</span>
</span><span id="1-2973">
</span><span id="1-2974">
</span><span id="1-2975"><span class="k">def</span><span class="w"> </span><span class="nf">TypedDict</span><span class="p">(</span><span class="n">typename</span><span class="p">,</span> <span class="n">fields</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">total</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
</span><span id="1-2976"><span class="w">    </span><span class="sd">&quot;&quot;&quot;A simple typed namespace. At runtime it is equivalent to a plain dict.</span>
</span><span id="1-2977">
</span><span id="1-2978"><span class="sd">    TypedDict creates a dictionary type such that a type checker will expect all</span>
</span><span id="1-2979"><span class="sd">    instances to have a certain set of keys, where each key is</span>
</span><span id="1-2980"><span class="sd">    associated with a value of a consistent type. This expectation</span>
</span><span id="1-2981"><span class="sd">    is not checked at runtime.</span>
</span><span id="1-2982">
</span><span id="1-2983"><span class="sd">    Usage::</span>
</span><span id="1-2984">
</span><span id="1-2985"><span class="sd">        &gt;&gt;&gt; class Point2D(TypedDict):</span>
</span><span id="1-2986"><span class="sd">        ...     x: int</span>
</span><span id="1-2987"><span class="sd">        ...     y: int</span>
</span><span id="1-2988"><span class="sd">        ...     label: str</span>
</span><span id="1-2989"><span class="sd">        ...</span>
</span><span id="1-2990"><span class="sd">        &gt;&gt;&gt; a: Point2D = {&#39;x&#39;: 1, &#39;y&#39;: 2, &#39;label&#39;: &#39;good&#39;}  # OK</span>
</span><span id="1-2991"><span class="sd">        &gt;&gt;&gt; b: Point2D = {&#39;z&#39;: 3, &#39;label&#39;: &#39;bad&#39;}           # Fails type check</span>
</span><span id="1-2992"><span class="sd">        &gt;&gt;&gt; Point2D(x=1, y=2, label=&#39;first&#39;) == dict(x=1, y=2, label=&#39;first&#39;)</span>
</span><span id="1-2993"><span class="sd">        True</span>
</span><span id="1-2994">
</span><span id="1-2995"><span class="sd">    The type info can be accessed via the Point2D.__annotations__ dict, and</span>
</span><span id="1-2996"><span class="sd">    the Point2D.__required_keys__ and Point2D.__optional_keys__ frozensets.</span>
</span><span id="1-2997"><span class="sd">    TypedDict supports an additional equivalent form::</span>
</span><span id="1-2998">
</span><span id="1-2999"><span class="sd">        Point2D = TypedDict(&#39;Point2D&#39;, {&#39;x&#39;: int, &#39;y&#39;: int, &#39;label&#39;: str})</span>
</span><span id="1-3000">
</span><span id="1-3001"><span class="sd">    By default, all keys must be present in a TypedDict. It is possible</span>
</span><span id="1-3002"><span class="sd">    to override this by specifying totality::</span>
</span><span id="1-3003">
</span><span id="1-3004"><span class="sd">        class Point2D(TypedDict, total=False):</span>
</span><span id="1-3005"><span class="sd">            x: int</span>
</span><span id="1-3006"><span class="sd">            y: int</span>
</span><span id="1-3007">
</span><span id="1-3008"><span class="sd">    This means that a Point2D TypedDict can have any of the keys omitted. A type</span>
</span><span id="1-3009"><span class="sd">    checker is only expected to support a literal False or True as the value of</span>
</span><span id="1-3010"><span class="sd">    the total argument. True is the default, and makes all items defined in the</span>
</span><span id="1-3011"><span class="sd">    class body be required.</span>
</span><span id="1-3012">
</span><span id="1-3013"><span class="sd">    The Required and NotRequired special forms can also be used to mark</span>
</span><span id="1-3014"><span class="sd">    individual keys as being required or not required::</span>
</span><span id="1-3015">
</span><span id="1-3016"><span class="sd">        class Point2D(TypedDict):</span>
</span><span id="1-3017"><span class="sd">            x: int               # the &quot;x&quot; key must always be present (Required is the default)</span>
</span><span id="1-3018"><span class="sd">            y: NotRequired[int]  # the &quot;y&quot; key can be omitted</span>
</span><span id="1-3019">
</span><span id="1-3020"><span class="sd">    See PEP 655 for more details on Required and NotRequired.</span>
</span><span id="1-3021"><span class="sd">    &quot;&quot;&quot;</span>
</span><span id="1-3022">    <span class="k">if</span> <span class="n">fields</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
</span><span id="1-3023">        <span class="n">fields</span> <span class="o">=</span> <span class="n">kwargs</span>
</span><span id="1-3024">    <span class="k">elif</span> <span class="n">kwargs</span><span class="p">:</span>
</span><span id="1-3025">        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;TypedDict takes either a dict or keyword arguments,&quot;</span>
</span><span id="1-3026">                        <span class="s2">&quot; but not both&quot;</span><span class="p">)</span>
</span><span id="1-3027">    <span class="k">if</span> <span class="n">kwargs</span><span class="p">:</span>
</span><span id="1-3028">        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
</span><span id="1-3029">            <span class="s2">&quot;The kwargs-based syntax for TypedDict definitions is deprecated &quot;</span>
</span><span id="1-3030">            <span class="s2">&quot;in Python 3.11, will be removed in Python 3.13, and may not be &quot;</span>
</span><span id="1-3031">            <span class="s2">&quot;understood by third-party type checkers.&quot;</span><span class="p">,</span>
</span><span id="1-3032">            <span class="ne">DeprecationWarning</span><span class="p">,</span>
</span><span id="1-3033">            <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
</span><span id="1-3034">        <span class="p">)</span>
</span><span id="1-3035">
</span><span id="1-3036">    <span class="n">ns</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;__annotations__&#39;</span><span class="p">:</span> <span class="nb">dict</span><span class="p">(</span><span class="n">fields</span><span class="p">)}</span>
</span><span id="1-3037">    <span class="n">module</span> <span class="o">=</span> <span class="n">_caller</span><span class="p">()</span>
</span><span id="1-3038">    <span class="k">if</span> <span class="n">module</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
</span><span id="1-3039">        <span class="c1"># Setting correct module is necessary to make typed dict classes pickleable.</span>
</span><span id="1-3040">        <span class="n">ns</span><span class="p">[</span><span class="s1">&#39;__module__&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">module</span>
</span><span id="1-3041">
</span><span id="1-3042">    <span class="n">td</span> <span class="o">=</span> <span class="n">_TypedDictMeta</span><span class="p">(</span><span class="n">typename</span><span class="p">,</span> <span class="p">(),</span> <span class="n">ns</span><span class="p">,</span> <span class="n">total</span><span class="o">=</span><span class="n">total</span><span class="p">)</span>
</span><span id="1-3043">    <span class="n">td</span><span class="o">.</span><span class="n">__orig_bases__</span> <span class="o">=</span> <span class="p">(</span><span class="n">TypedDict</span><span class="p">,)</span>
</span><span id="1-3044">    <span class="k">return</span> <span class="n">td</span>
</span><span id="1-3045">
</span><span id="1-3046"><span class="n">_TypedDict</span> <span class="o">=</span> <span class="nb">type</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="n">_TypedDictMeta</span><span class="p">,</span> <span class="s1">&#39;TypedDict&#39;</span><span class="p">,</span> <span class="p">(),</span> <span class="p">{})</span>
</span><span id="1-3047"><span class="n">TypedDict</span><span class="o">.</span><span class="n">__mro_entries__</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">bases</span><span class="p">:</span> <span class="p">(</span><span class="n">_TypedDict</span><span class="p">,)</span>
</span><span id="1-3048">
</span><span id="1-3049">
</span><span id="1-3050"><span class="nd">@_SpecialForm</span>
</span><span id="1-3051"><span class="k">def</span><span class="w"> </span><span class="nf">Required</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parameters</span><span class="p">):</span>
</span><span id="1-3052"><span class="w">    </span><span class="sd">&quot;&quot;&quot;Special typing construct to mark a TypedDict key as required.</span>
</span><span id="1-3053">
</span><span id="1-3054"><span class="sd">    This is mainly useful for total=False TypedDicts.</span>
</span><span id="1-3055">
</span><span id="1-3056"><span class="sd">    For example::</span>
</span><span id="1-3057">
</span><span id="1-3058"><span class="sd">        class Movie(TypedDict, total=False):</span>
</span><span id="1-3059"><span class="sd">            title: Required[str]</span>
</span><span id="1-3060"><span class="sd">            year: int</span>
</span><span id="1-3061">
</span><span id="1-3062"><span class="sd">        m = Movie(</span>
</span><span id="1-3063"><span class="sd">            title=&#39;The Matrix&#39;,  # typechecker error if key is omitted</span>
</span><span id="1-3064"><span class="sd">            year=1999,</span>
</span><span id="1-3065"><span class="sd">        )</span>
</span><span id="1-3066">
</span><span id="1-3067"><span class="sd">    There is no runtime checking that a required key is actually provided</span>
</span><span id="1-3068"><span class="sd">    when instantiating a related TypedDict.</span>
</span><span id="1-3069"><span class="sd">    &quot;&quot;&quot;</span>
</span><span id="1-3070">    <span class="n">item</span> <span class="o">=</span> <span class="n">_type_check</span><span class="p">(</span><span class="n">parameters</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_name</span><span class="si">}</span><span class="s1"> accepts only a single type.&#39;</span><span class="p">)</span>
</span><span id="1-3071">    <span class="k">return</span> <span class="n">_GenericAlias</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="p">(</span><span class="n">item</span><span class="p">,))</span>
</span><span id="1-3072">
</span><span id="1-3073">
</span><span id="1-3074"><span class="nd">@_SpecialForm</span>
</span><span id="1-3075"><span class="k">def</span><span class="w"> </span><span class="nf">NotRequired</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parameters</span><span class="p">):</span>
</span><span id="1-3076"><span class="w">    </span><span class="sd">&quot;&quot;&quot;Special typing construct to mark a TypedDict key as potentially missing.</span>
</span><span id="1-3077">
</span><span id="1-3078"><span class="sd">    For example::</span>
</span><span id="1-3079">
</span><span id="1-3080"><span class="sd">        class Movie(TypedDict):</span>
</span><span id="1-3081"><span class="sd">            title: str</span>
</span><span id="1-3082"><span class="sd">            year: NotRequired[int]</span>
</span><span id="1-3083">
</span><span id="1-3084"><span class="sd">        m = Movie(</span>
</span><span id="1-3085"><span class="sd">            title=&#39;The Matrix&#39;,  # typechecker error if key is omitted</span>
</span><span id="1-3086"><span class="sd">            year=1999,</span>
</span><span id="1-3087"><span class="sd">        )</span>
</span><span id="1-3088"><span class="sd">    &quot;&quot;&quot;</span>
</span><span id="1-3089">    <span class="n">item</span> <span class="o">=</span> <span class="n">_type_check</span><span class="p">(</span><span class="n">parameters</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_name</span><span class="si">}</span><span class="s1"> accepts only a single type.&#39;</span><span class="p">)</span>
</span><span id="1-3090">    <span class="k">return</span> <span class="n">_GenericAlias</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="p">(</span><span class="n">item</span><span class="p">,))</span>
</span><span id="1-3091">
</span><span id="1-3092">
</span><span id="1-3093"><span class="k">class</span><span class="w"> </span><span class="nc">NewType</span><span class="p">:</span>
</span><span id="1-3094"><span class="w">    </span><span class="sd">&quot;&quot;&quot;NewType creates simple unique types with almost zero runtime overhead.</span>
</span><span id="1-3095">
</span><span id="1-3096"><span class="sd">    NewType(name, tp) is considered a subtype of tp</span>
</span><span id="1-3097"><span class="sd">    by static type checkers. At runtime, NewType(name, tp) returns</span>
</span><span id="1-3098"><span class="sd">    a dummy callable that simply returns its argument.</span>
</span><span id="1-3099">
</span><span id="1-3100"><span class="sd">    Usage::</span>
</span><span id="1-3101">
</span><span id="1-3102"><span class="sd">        UserId = NewType(&#39;UserId&#39;, int)</span>
</span><span id="1-3103">
</span><span id="1-3104"><span class="sd">        def name_by_id(user_id: UserId) -&gt; str:</span>
</span><span id="1-3105"><span class="sd">            ...</span>
</span><span id="1-3106">
</span><span id="1-3107"><span class="sd">        UserId(&#39;user&#39;)          # Fails type check</span>
</span><span id="1-3108">
</span><span id="1-3109"><span class="sd">        name_by_id(42)          # Fails type check</span>
</span><span id="1-3110"><span class="sd">        name_by_id(UserId(42))  # OK</span>
</span><span id="1-3111">
</span><span id="1-3112"><span class="sd">        num = UserId(5) + 1     # type: int</span>
</span><span id="1-3113"><span class="sd">    &quot;&quot;&quot;</span>
</span><span id="1-3114">
</span><span id="1-3115">    <span class="fm">__call__</span> <span class="o">=</span> <span class="n">_idfunc</span>
</span><span id="1-3116">
</span><span id="1-3117">    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">tp</span><span class="p">):</span>
</span><span id="1-3118">        <span class="bp">self</span><span class="o">.</span><span class="vm">__qualname__</span> <span class="o">=</span> <span class="n">name</span>
</span><span id="1-3119">        <span class="k">if</span> <span class="s1">&#39;.&#39;</span> <span class="ow">in</span> <span class="n">name</span><span class="p">:</span>
</span><span id="1-3120">            <span class="n">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">.</span><span class="n">rpartition</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</span><span id="1-3121">        <span class="bp">self</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">=</span> <span class="n">name</span>
</span><span id="1-3122">        <span class="bp">self</span><span class="o">.</span><span class="n">__supertype__</span> <span class="o">=</span> <span class="n">tp</span>
</span><span id="1-3123">        <span class="n">def_mod</span> <span class="o">=</span> <span class="n">_caller</span><span class="p">()</span>
</span><span id="1-3124">        <span class="k">if</span> <span class="n">def_mod</span> <span class="o">!=</span> <span class="s1">&#39;typing&#39;</span><span class="p">:</span>
</span><span id="1-3125">            <span class="bp">self</span><span class="o">.</span><span class="vm">__module__</span> <span class="o">=</span> <span class="n">def_mod</span>
</span><span id="1-3126">
</span><span id="1-3127">    <span class="k">def</span><span class="w"> </span><span class="nf">__mro_entries__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bases</span><span class="p">):</span>
</span><span id="1-3128">        <span class="c1"># We defined __mro_entries__ to get a better error message</span>
</span><span id="1-3129">        <span class="c1"># if a user attempts to subclass a NewType instance. bpo-46170</span>
</span><span id="1-3130">        <span class="n">superclass_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__name__</span>
</span><span id="1-3131">
</span><span id="1-3132">        <span class="k">class</span><span class="w"> </span><span class="nc">Dummy</span><span class="p">:</span>
</span><span id="1-3133">            <span class="k">def</span><span class="w"> </span><span class="nf">__init_subclass__</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
</span><span id="1-3134">                <span class="n">subclass_name</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span>
</span><span id="1-3135">                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
</span><span id="1-3136">                    <span class="sa">f</span><span class="s2">&quot;Cannot subclass an instance of NewType. Perhaps you were looking for: &quot;</span>
</span><span id="1-3137">                    <span class="sa">f</span><span class="s2">&quot;`</span><span class="si">{</span><span class="n">subclass_name</span><span class="si">}</span><span class="s2"> = NewType(</span><span class="si">{</span><span class="n">subclass_name</span><span class="si">!r}</span><span class="s2">, </span><span class="si">{</span><span class="n">superclass_name</span><span class="si">}</span><span class="s2">)`&quot;</span>
</span><span id="1-3138">                <span class="p">)</span>
</span><span id="1-3139">
</span><span id="1-3140">        <span class="k">return</span> <span class="p">(</span><span class="n">Dummy</span><span class="p">,)</span>
</span><span id="1-3141">
</span><span id="1-3142">    <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span id="1-3143">        <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__module__</span><span class="si">}</span><span class="s1">.</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__qualname__</span><span class="si">}</span><span class="s1">&#39;</span>
</span><span id="1-3144">
</span><span id="1-3145">    <span class="k">def</span><span class="w"> </span><span class="nf">__reduce__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span id="1-3146">        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__qualname__</span>
</span><span id="1-3147">
</span><span id="1-3148">    <span class="k">def</span><span class="w"> </span><span class="fm">__or__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
</span><span id="1-3149">        <span class="k">return</span> <span class="n">Union</span><span class="p">[</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">]</span>
</span><span id="1-3150">
</span><span id="1-3151">    <span class="k">def</span><span class="w"> </span><span class="fm">__ror__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
</span><span id="1-3152">        <span class="k">return</span> <span class="n">Union</span><span class="p">[</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="p">]</span>
</span><span id="1-3153">
</span><span id="1-3154">
</span><span id="1-3155"><span class="c1"># Python-version-specific alias (Python 2: unicode; Python 3: str)</span>
</span><span id="1-3156"><span class="n">Text</span> <span class="o">=</span> <span class="nb">str</span>
</span><span id="1-3157">
</span><span id="1-3158">
</span><span id="1-3159"><span class="c1"># Constant that&#39;s True when type checking, but False here.</span>
</span><span id="1-3160"><span class="n">TYPE_CHECKING</span> <span class="o">=</span> <span class="kc">False</span>
</span><span id="1-3161">
</span><span id="1-3162">
</span><span id="1-3163"><span class="k">class</span><span class="w"> </span><span class="nc">IO</span><span class="p">(</span><span class="n">Generic</span><span class="p">[</span><span class="n">AnyStr</span><span class="p">]):</span>
</span><span id="1-3164"><span class="w">    </span><span class="sd">&quot;&quot;&quot;Generic base class for TextIO and BinaryIO.</span>
</span><span id="1-3165">
</span><span id="1-3166"><span class="sd">    This is an abstract, generic version of the return of open().</span>
</span><span id="1-3167">
</span><span id="1-3168"><span class="sd">    NOTE: This does not distinguish between the different possible</span>
</span><span id="1-3169"><span class="sd">    classes (text vs. binary, read vs. write vs. read/write,</span>
</span><span id="1-3170"><span class="sd">    append-only, unbuffered).  The TextIO and BinaryIO subclasses</span>
</span><span id="1-3171"><span class="sd">    below capture the distinctions between text vs. binary, which is</span>
</span><span id="1-3172"><span class="sd">    pervasive in the interface; however we currently do not offer a</span>
</span><span id="1-3173"><span class="sd">    way to track the other distinctions in the type system.</span>
</span><span id="1-3174"><span class="sd">    &quot;&quot;&quot;</span>
</span><span id="1-3175">
</span><span id="1-3176">    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">()</span>
</span><span id="1-3177">
</span><span id="1-3178">    <span class="nd">@property</span>
</span><span id="1-3179">    <span class="nd">@abstractmethod</span>
</span><span id="1-3180">    <span class="k">def</span><span class="w"> </span><span class="nf">mode</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
</span><span id="1-3181">        <span class="k">pass</span>
</span><span id="1-3182">
</span><span id="1-3183">    <span class="nd">@property</span>
</span><span id="1-3184">    <span class="nd">@abstractmethod</span>
</span><span id="1-3185">    <span class="k">def</span><span class="w"> </span><span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
</span><span id="1-3186">        <span class="k">pass</span>
</span><span id="1-3187">
</span><span id="1-3188">    <span class="nd">@abstractmethod</span>
</span><span id="1-3189">    <span class="k">def</span><span class="w"> </span><span class="nf">close</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
</span><span id="1-3190">        <span class="k">pass</span>
</span><span id="1-3191">
</span><span id="1-3192">    <span class="nd">@property</span>
</span><span id="1-3193">    <span class="nd">@abstractmethod</span>
</span><span id="1-3194">    <span class="k">def</span><span class="w"> </span><span class="nf">closed</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
</span><span id="1-3195">        <span class="k">pass</span>
</span><span id="1-3196">
</span><span id="1-3197">    <span class="nd">@abstractmethod</span>
</span><span id="1-3198">    <span class="k">def</span><span class="w"> </span><span class="nf">fileno</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
</span><span id="1-3199">        <span class="k">pass</span>
</span><span id="1-3200">
</span><span id="1-3201">    <span class="nd">@abstractmethod</span>
</span><span id="1-3202">    <span class="k">def</span><span class="w"> </span><span class="nf">flush</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
</span><span id="1-3203">        <span class="k">pass</span>
</span><span id="1-3204">
</span><span id="1-3205">    <span class="nd">@abstractmethod</span>
</span><span id="1-3206">    <span class="k">def</span><span class="w"> </span><span class="nf">isatty</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
</span><span id="1-3207">        <span class="k">pass</span>
</span><span id="1-3208">
</span><span id="1-3209">    <span class="nd">@abstractmethod</span>
</span><span id="1-3210">    <span class="k">def</span><span class="w"> </span><span class="nf">read</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">AnyStr</span><span class="p">:</span>
</span><span id="1-3211">        <span class="k">pass</span>
</span><span id="1-3212">
</span><span id="1-3213">    <span class="nd">@abstractmethod</span>
</span><span id="1-3214">    <span class="k">def</span><span class="w"> </span><span class="nf">readable</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
</span><span id="1-3215">        <span class="k">pass</span>
</span><span id="1-3216">
</span><span id="1-3217">    <span class="nd">@abstractmethod</span>
</span><span id="1-3218">    <span class="k">def</span><span class="w"> </span><span class="nf">readline</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">limit</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">AnyStr</span><span class="p">:</span>
</span><span id="1-3219">        <span class="k">pass</span>
</span><span id="1-3220">
</span><span id="1-3221">    <span class="nd">@abstractmethod</span>
</span><span id="1-3222">    <span class="k">def</span><span class="w"> </span><span class="nf">readlines</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hint</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">AnyStr</span><span class="p">]:</span>
</span><span id="1-3223">        <span class="k">pass</span>
</span><span id="1-3224">
</span><span id="1-3225">    <span class="nd">@abstractmethod</span>
</span><span id="1-3226">    <span class="k">def</span><span class="w"> </span><span class="nf">seek</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">offset</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">whence</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
</span><span id="1-3227">        <span class="k">pass</span>
</span><span id="1-3228">
</span><span id="1-3229">    <span class="nd">@abstractmethod</span>
</span><span id="1-3230">    <span class="k">def</span><span class="w"> </span><span class="nf">seekable</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
</span><span id="1-3231">        <span class="k">pass</span>
</span><span id="1-3232">
</span><span id="1-3233">    <span class="nd">@abstractmethod</span>
</span><span id="1-3234">    <span class="k">def</span><span class="w"> </span><span class="nf">tell</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
</span><span id="1-3235">        <span class="k">pass</span>
</span><span id="1-3236">
</span><span id="1-3237">    <span class="nd">@abstractmethod</span>
</span><span id="1-3238">    <span class="k">def</span><span class="w"> </span><span class="nf">truncate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
</span><span id="1-3239">        <span class="k">pass</span>
</span><span id="1-3240">
</span><span id="1-3241">    <span class="nd">@abstractmethod</span>
</span><span id="1-3242">    <span class="k">def</span><span class="w"> </span><span class="nf">writable</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
</span><span id="1-3243">        <span class="k">pass</span>
</span><span id="1-3244">
</span><span id="1-3245">    <span class="nd">@abstractmethod</span>
</span><span id="1-3246">    <span class="k">def</span><span class="w"> </span><span class="nf">write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="n">AnyStr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
</span><span id="1-3247">        <span class="k">pass</span>
</span><span id="1-3248">
</span><span id="1-3249">    <span class="nd">@abstractmethod</span>
</span><span id="1-3250">    <span class="k">def</span><span class="w"> </span><span class="nf">writelines</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lines</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">AnyStr</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
</span><span id="1-3251">        <span class="k">pass</span>
</span><span id="1-3252">
</span><span id="1-3253">    <span class="nd">@abstractmethod</span>
</span><span id="1-3254">    <span class="k">def</span><span class="w"> </span><span class="fm">__enter__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;IO[AnyStr]&#39;</span><span class="p">:</span>
</span><span id="1-3255">        <span class="k">pass</span>
</span><span id="1-3256">
</span><span id="1-3257">    <span class="nd">@abstractmethod</span>
</span><span id="1-3258">    <span class="k">def</span><span class="w"> </span><span class="fm">__exit__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">type</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">traceback</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
</span><span id="1-3259">        <span class="k">pass</span>
</span><span id="1-3260">
</span><span id="1-3261">
</span><span id="1-3262"><span class="k">class</span><span class="w"> </span><span class="nc">BinaryIO</span><span class="p">(</span><span class="n">IO</span><span class="p">[</span><span class="nb">bytes</span><span class="p">]):</span>
</span><span id="1-3263"><span class="w">    </span><span class="sd">&quot;&quot;&quot;Typed version of the return of open() in binary mode.&quot;&quot;&quot;</span>
</span><span id="1-3264">
</span><span id="1-3265">    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">()</span>
</span><span id="1-3266">
</span><span id="1-3267">    <span class="nd">@abstractmethod</span>
</span><span id="1-3268">    <span class="k">def</span><span class="w"> </span><span class="nf">write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">bytes</span><span class="p">,</span> <span class="nb">bytearray</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
</span><span id="1-3269">        <span class="k">pass</span>
</span><span id="1-3270">
</span><span id="1-3271">    <span class="nd">@abstractmethod</span>
</span><span id="1-3272">    <span class="k">def</span><span class="w"> </span><span class="fm">__enter__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;BinaryIO&#39;</span><span class="p">:</span>
</span><span id="1-3273">        <span class="k">pass</span>
</span><span id="1-3274">
</span><span id="1-3275">
</span><span id="1-3276"><span class="k">class</span><span class="w"> </span><span class="nc">TextIO</span><span class="p">(</span><span class="n">IO</span><span class="p">[</span><span class="nb">str</span><span class="p">]):</span>
</span><span id="1-3277"><span class="w">    </span><span class="sd">&quot;&quot;&quot;Typed version of the return of open() in text mode.&quot;&quot;&quot;</span>
</span><span id="1-3278">
</span><span id="1-3279">    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">()</span>
</span><span id="1-3280">
</span><span id="1-3281">    <span class="nd">@property</span>
</span><span id="1-3282">    <span class="nd">@abstractmethod</span>
</span><span id="1-3283">    <span class="k">def</span><span class="w"> </span><span class="nf">buffer</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BinaryIO</span><span class="p">:</span>
</span><span id="1-3284">        <span class="k">pass</span>
</span><span id="1-3285">
</span><span id="1-3286">    <span class="nd">@property</span>
</span><span id="1-3287">    <span class="nd">@abstractmethod</span>
</span><span id="1-3288">    <span class="k">def</span><span class="w"> </span><span class="nf">encoding</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
</span><span id="1-3289">        <span class="k">pass</span>
</span><span id="1-3290">
</span><span id="1-3291">    <span class="nd">@property</span>
</span><span id="1-3292">    <span class="nd">@abstractmethod</span>
</span><span id="1-3293">    <span class="k">def</span><span class="w"> </span><span class="nf">errors</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
</span><span id="1-3294">        <span class="k">pass</span>
</span><span id="1-3295">
</span><span id="1-3296">    <span class="nd">@property</span>
</span><span id="1-3297">    <span class="nd">@abstractmethod</span>
</span><span id="1-3298">    <span class="k">def</span><span class="w"> </span><span class="nf">line_buffering</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
</span><span id="1-3299">        <span class="k">pass</span>
</span><span id="1-3300">
</span><span id="1-3301">    <span class="nd">@property</span>
</span><span id="1-3302">    <span class="nd">@abstractmethod</span>
</span><span id="1-3303">    <span class="k">def</span><span class="w"> </span><span class="nf">newlines</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
</span><span id="1-3304">        <span class="k">pass</span>
</span><span id="1-3305">
</span><span id="1-3306">    <span class="nd">@abstractmethod</span>
</span><span id="1-3307">    <span class="k">def</span><span class="w"> </span><span class="fm">__enter__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;TextIO&#39;</span><span class="p">:</span>
</span><span id="1-3308">        <span class="k">pass</span>
</span><span id="1-3309">
</span><span id="1-3310">
</span><span id="1-3311"><span class="k">class</span><span class="w"> </span><span class="nc">_DeprecatedType</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>
</span><span id="1-3312">    <span class="k">def</span><span class="w"> </span><span class="fm">__getattribute__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
</span><span id="1-3313">        <span class="k">if</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">{</span><span class="s2">&quot;__dict__&quot;</span><span class="p">,</span> <span class="s2">&quot;__module__&quot;</span><span class="p">,</span> <span class="s2">&quot;__doc__&quot;</span><span class="p">}</span> <span class="ow">and</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">:</span>
</span><span id="1-3314">            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
</span><span id="1-3315">                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> is deprecated, import directly &quot;</span>
</span><span id="1-3316">                <span class="sa">f</span><span class="s2">&quot;from typing instead. </span><span class="si">{</span><span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> will be removed &quot;</span>
</span><span id="1-3317">                <span class="s2">&quot;in Python 3.13.&quot;</span><span class="p">,</span>
</span><span id="1-3318">                <span class="ne">DeprecationWarning</span><span class="p">,</span>
</span><span id="1-3319">                <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
</span><span id="1-3320">            <span class="p">)</span>
</span><span id="1-3321">        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__getattribute__</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
</span><span id="1-3322">
</span><span id="1-3323">
</span><span id="1-3324"><span class="k">class</span><span class="w"> </span><span class="nc">io</span><span class="p">(</span><span class="n">metaclass</span><span class="o">=</span><span class="n">_DeprecatedType</span><span class="p">):</span>
</span><span id="1-3325"><span class="w">    </span><span class="sd">&quot;&quot;&quot;Wrapper namespace for IO generic classes.&quot;&quot;&quot;</span>
</span><span id="1-3326">
</span><span id="1-3327">    <span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;IO&#39;</span><span class="p">,</span> <span class="s1">&#39;TextIO&#39;</span><span class="p">,</span> <span class="s1">&#39;BinaryIO&#39;</span><span class="p">]</span>
</span><span id="1-3328">    <span class="n">IO</span> <span class="o">=</span> <span class="n">IO</span>
</span><span id="1-3329">    <span class="n">TextIO</span> <span class="o">=</span> <span class="n">TextIO</span>
</span><span id="1-3330">    <span class="n">BinaryIO</span> <span class="o">=</span> <span class="n">BinaryIO</span>
</span><span id="1-3331">
</span><span id="1-3332">
</span><span id="1-3333"><span class="n">io</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">=</span> <span class="vm">__name__</span> <span class="o">+</span> <span class="s1">&#39;.io&#39;</span>
</span><span id="1-3334"><span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">[</span><span class="n">io</span><span class="o">.</span><span class="vm">__name__</span><span class="p">]</span> <span class="o">=</span> <span class="n">io</span>
</span><span id="1-3335">
</span><span id="1-3336"><span class="n">Pattern</span> <span class="o">=</span> <span class="n">_alias</span><span class="p">(</span><span class="n">stdlib_re</span><span class="o">.</span><span class="n">Pattern</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</span><span id="1-3337"><span class="n">Match</span> <span class="o">=</span> <span class="n">_alias</span><span class="p">(</span><span class="n">stdlib_re</span><span class="o">.</span><span class="n">Match</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</span><span id="1-3338">
</span><span id="1-3339"><span class="k">class</span><span class="w"> </span><span class="nc">re</span><span class="p">(</span><span class="n">metaclass</span><span class="o">=</span><span class="n">_DeprecatedType</span><span class="p">):</span>
</span><span id="1-3340"><span class="w">    </span><span class="sd">&quot;&quot;&quot;Wrapper namespace for re type aliases.&quot;&quot;&quot;</span>
</span><span id="1-3341">
</span><span id="1-3342">    <span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Pattern&#39;</span><span class="p">,</span> <span class="s1">&#39;Match&#39;</span><span class="p">]</span>
</span><span id="1-3343">    <span class="n">Pattern</span> <span class="o">=</span> <span class="n">Pattern</span>
</span><span id="1-3344">    <span class="n">Match</span> <span class="o">=</span> <span class="n">Match</span>
</span><span id="1-3345">
</span><span id="1-3346">
</span><span id="1-3347"><span class="n">re</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">=</span> <span class="vm">__name__</span> <span class="o">+</span> <span class="s1">&#39;.re&#39;</span>
</span><span id="1-3348"><span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">[</span><span class="n">re</span><span class="o">.</span><span class="vm">__name__</span><span class="p">]</span> <span class="o">=</span> <span class="n">re</span>
</span><span id="1-3349">
</span><span id="1-3350">
</span><span id="1-3351"><span class="k">def</span><span class="w"> </span><span class="nf">reveal_type</span><span class="p">[</span><span class="n">T</span><span class="p">](</span><span class="n">obj</span><span class="p">:</span> <span class="n">T</span><span class="p">,</span> <span class="o">/</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">T</span><span class="p">:</span>
</span><span id="1-3352"><span class="w">    </span><span class="sd">&quot;&quot;&quot;Ask a static type checker to reveal the inferred type of an expression.</span>
</span><span id="1-3353">
</span><span id="1-3354"><span class="sd">    When a static type checker encounters a call to ``reveal_type()``,</span>
</span><span id="1-3355"><span class="sd">    it will emit the inferred type of the argument::</span>
</span><span id="1-3356">
</span><span id="1-3357"><span class="sd">        x: int = 1</span>
</span><span id="1-3358"><span class="sd">        reveal_type(x)</span>
</span><span id="1-3359">
</span><span id="1-3360"><span class="sd">    Running a static type checker (e.g., mypy) on this example</span>
</span><span id="1-3361"><span class="sd">    will produce output similar to &#39;Revealed type is &quot;builtins.int&quot;&#39;.</span>
</span><span id="1-3362">
</span><span id="1-3363"><span class="sd">    At runtime, the function prints the runtime type of the</span>
</span><span id="1-3364"><span class="sd">    argument and returns the argument unchanged.</span>
</span><span id="1-3365"><span class="sd">    &quot;&quot;&quot;</span>
</span><span id="1-3366">    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Runtime type is </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">!r}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">file</span><span class="o">=</span><span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="p">)</span>
</span><span id="1-3367">    <span class="k">return</span> <span class="n">obj</span>
</span><span id="1-3368">
</span><span id="1-3369">
</span><span id="1-3370"><span class="k">class</span><span class="w"> </span><span class="nc">_IdentityCallable</span><span class="p">(</span><span class="n">Protocol</span><span class="p">):</span>
</span><span id="1-3371">    <span class="k">def</span><span class="w"> </span><span class="fm">__call__</span><span class="p">[</span><span class="n">T</span><span class="p">](</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg</span><span class="p">:</span> <span class="n">T</span><span class="p">,</span> <span class="o">/</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">T</span><span class="p">:</span>
</span><span id="1-3372">        <span class="o">...</span>
</span><span id="1-3373">
</span><span id="1-3374">
</span><span id="1-3375"><span class="k">def</span><span class="w"> </span><span class="nf">dataclass_transform</span><span class="p">(</span>
</span><span id="1-3376">    <span class="o">*</span><span class="p">,</span>
</span><span id="1-3377">    <span class="n">eq_default</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
</span><span id="1-3378">    <span class="n">order_default</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
</span><span id="1-3379">    <span class="n">kw_only_default</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
</span><span id="1-3380">    <span class="n">frozen_default</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
</span><span id="1-3381">    <span class="n">field_specifiers</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">type</span><span class="p">[</span><span class="n">Any</span><span class="p">]</span> <span class="o">|</span> <span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">Any</span><span class="p">],</span> <span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="p">(),</span>
</span><span id="1-3382">    <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span>
</span><span id="1-3383"><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">_IdentityCallable</span><span class="p">:</span>
</span><span id="1-3384"><span class="w">    </span><span class="sd">&quot;&quot;&quot;Decorator to mark an object as providing dataclass-like behaviour.</span>
</span><span id="1-3385">
</span><span id="1-3386"><span class="sd">    The decorator can be applied to a function, class, or metaclass.</span>
</span><span id="1-3387">
</span><span id="1-3388"><span class="sd">    Example usage with a decorator function::</span>
</span><span id="1-3389">
</span><span id="1-3390"><span class="sd">        @dataclass_transform()</span>
</span><span id="1-3391"><span class="sd">        def create_model[T](cls: type[T]) -&gt; type[T]:</span>
</span><span id="1-3392"><span class="sd">            ...</span>
</span><span id="1-3393"><span class="sd">            return cls</span>
</span><span id="1-3394">
</span><span id="1-3395"><span class="sd">        @create_model</span>
</span><span id="1-3396"><span class="sd">        class CustomerModel:</span>
</span><span id="1-3397"><span class="sd">            id: int</span>
</span><span id="1-3398"><span class="sd">            name: str</span>
</span><span id="1-3399">
</span><span id="1-3400"><span class="sd">    On a base class::</span>
</span><span id="1-3401">
</span><span id="1-3402"><span class="sd">        @dataclass_transform()</span>
</span><span id="1-3403"><span class="sd">        class ModelBase: ...</span>
</span><span id="1-3404">
</span><span id="1-3405"><span class="sd">        class CustomerModel(ModelBase):</span>
</span><span id="1-3406"><span class="sd">            id: int</span>
</span><span id="1-3407"><span class="sd">            name: str</span>
</span><span id="1-3408">
</span><span id="1-3409"><span class="sd">    On a metaclass::</span>
</span><span id="1-3410">
</span><span id="1-3411"><span class="sd">        @dataclass_transform()</span>
</span><span id="1-3412"><span class="sd">        class ModelMeta(type): ...</span>
</span><span id="1-3413">
</span><span id="1-3414"><span class="sd">        class ModelBase(metaclass=ModelMeta): ...</span>
</span><span id="1-3415">
</span><span id="1-3416"><span class="sd">        class CustomerModel(ModelBase):</span>
</span><span id="1-3417"><span class="sd">            id: int</span>
</span><span id="1-3418"><span class="sd">            name: str</span>
</span><span id="1-3419">
</span><span id="1-3420"><span class="sd">    The ``CustomerModel`` classes defined above will</span>
</span><span id="1-3421"><span class="sd">    be treated by type checkers similarly to classes created with</span>
</span><span id="1-3422"><span class="sd">    ``@dataclasses.dataclass``.</span>
</span><span id="1-3423"><span class="sd">    For example, type checkers will assume these classes have</span>
</span><span id="1-3424"><span class="sd">    ``__init__`` methods that accept ``id`` and ``name``.</span>
</span><span id="1-3425">
</span><span id="1-3426"><span class="sd">    The arguments to this decorator can be used to customize this behavior:</span>
</span><span id="1-3427"><span class="sd">    - ``eq_default`` indicates whether the ``eq`` parameter is assumed to be</span>
</span><span id="1-3428"><span class="sd">        ``True`` or ``False`` if it is omitted by the caller.</span>
</span><span id="1-3429"><span class="sd">    - ``order_default`` indicates whether the ``order`` parameter is</span>
</span><span id="1-3430"><span class="sd">        assumed to be True or False if it is omitted by the caller.</span>
</span><span id="1-3431"><span class="sd">    - ``kw_only_default`` indicates whether the ``kw_only`` parameter is</span>
</span><span id="1-3432"><span class="sd">        assumed to be True or False if it is omitted by the caller.</span>
</span><span id="1-3433"><span class="sd">    - ``frozen_default`` indicates whether the ``frozen`` parameter is</span>
</span><span id="1-3434"><span class="sd">        assumed to be True or False if it is omitted by the caller.</span>
</span><span id="1-3435"><span class="sd">    - ``field_specifiers`` specifies a static list of supported classes</span>
</span><span id="1-3436"><span class="sd">        or functions that describe fields, similar to ``dataclasses.field()``.</span>
</span><span id="1-3437"><span class="sd">    - Arbitrary other keyword arguments are accepted in order to allow for</span>
</span><span id="1-3438"><span class="sd">        possible future extensions.</span>
</span><span id="1-3439">
</span><span id="1-3440"><span class="sd">    At runtime, this decorator records its arguments in the</span>
</span><span id="1-3441"><span class="sd">    ``__dataclass_transform__`` attribute on the decorated object.</span>
</span><span id="1-3442"><span class="sd">    It has no other runtime effect.</span>
</span><span id="1-3443">
</span><span id="1-3444"><span class="sd">    See PEP 681 for more details.</span>
</span><span id="1-3445"><span class="sd">    &quot;&quot;&quot;</span>
</span><span id="1-3446">    <span class="k">def</span><span class="w"> </span><span class="nf">decorator</span><span class="p">(</span><span class="n">cls_or_fn</span><span class="p">):</span>
</span><span id="1-3447">        <span class="n">cls_or_fn</span><span class="o">.</span><span class="n">__dataclass_transform__</span> <span class="o">=</span> <span class="p">{</span>
</span><span id="1-3448">            <span class="s2">&quot;eq_default&quot;</span><span class="p">:</span> <span class="n">eq_default</span><span class="p">,</span>
</span><span id="1-3449">            <span class="s2">&quot;order_default&quot;</span><span class="p">:</span> <span class="n">order_default</span><span class="p">,</span>
</span><span id="1-3450">            <span class="s2">&quot;kw_only_default&quot;</span><span class="p">:</span> <span class="n">kw_only_default</span><span class="p">,</span>
</span><span id="1-3451">            <span class="s2">&quot;frozen_default&quot;</span><span class="p">:</span> <span class="n">frozen_default</span><span class="p">,</span>
</span><span id="1-3452">            <span class="s2">&quot;field_specifiers&quot;</span><span class="p">:</span> <span class="n">field_specifiers</span><span class="p">,</span>
</span><span id="1-3453">            <span class="s2">&quot;kwargs&quot;</span><span class="p">:</span> <span class="n">kwargs</span><span class="p">,</span>
</span><span id="1-3454">        <span class="p">}</span>
</span><span id="1-3455">        <span class="k">return</span> <span class="n">cls_or_fn</span>
</span><span id="1-3456">    <span class="k">return</span> <span class="n">decorator</span>
</span><span id="1-3457">
</span><span id="1-3458">
</span><span id="1-3459"><span class="nb">type</span> <span class="n">_Func</span> <span class="o">=</span> <span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span>
</span><span id="1-3460">
</span><span id="1-3461">
</span><span id="1-3462"><span class="k">def</span><span class="w"> </span><span class="nf">override</span><span class="p">[</span><span class="n">F</span><span class="p">:</span> <span class="n">_Func</span><span class="p">](</span><span class="n">method</span><span class="p">:</span> <span class="n">F</span><span class="p">,</span> <span class="o">/</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">F</span><span class="p">:</span>
</span><span id="1-3463"><span class="w">    </span><span class="sd">&quot;&quot;&quot;Indicate that a method is intended to override a method in a base class.</span>
</span><span id="1-3464">
</span><span id="1-3465"><span class="sd">    Usage::</span>
</span><span id="1-3466">
</span><span id="1-3467"><span class="sd">        class Base:</span>
</span><span id="1-3468"><span class="sd">            def method(self) -&gt; None:</span>
</span><span id="1-3469"><span class="sd">                pass</span>
</span><span id="1-3470">
</span><span id="1-3471"><span class="sd">        class Child(Base):</span>
</span><span id="1-3472"><span class="sd">            @override</span>
</span><span id="1-3473"><span class="sd">            def method(self) -&gt; None:</span>
</span><span id="1-3474"><span class="sd">                super().method()</span>
</span><span id="1-3475">
</span><span id="1-3476"><span class="sd">    When this decorator is applied to a method, the type checker will</span>
</span><span id="1-3477"><span class="sd">    validate that it overrides a method or attribute with the same name on a</span>
</span><span id="1-3478"><span class="sd">    base class.  This helps prevent bugs that may occur when a base class is</span>
</span><span id="1-3479"><span class="sd">    changed without an equivalent change to a child class.</span>
</span><span id="1-3480">
</span><span id="1-3481"><span class="sd">    There is no runtime checking of this property. The decorator attempts to</span>
</span><span id="1-3482"><span class="sd">    set the ``__override__`` attribute to ``True`` on the decorated object to</span>
</span><span id="1-3483"><span class="sd">    allow runtime introspection.</span>
</span><span id="1-3484">
</span><span id="1-3485"><span class="sd">    See PEP 698 for details.</span>
</span><span id="1-3486"><span class="sd">    &quot;&quot;&quot;</span>
</span><span id="1-3487">    <span class="k">try</span><span class="p">:</span>
</span><span id="1-3488">        <span class="n">method</span><span class="o">.</span><span class="n">__override__</span> <span class="o">=</span> <span class="kc">True</span>
</span><span id="1-3489">    <span class="k">except</span> <span class="p">(</span><span class="ne">AttributeError</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">):</span>
</span><span id="1-3490">        <span class="c1"># Skip the attribute silently if it is not writable.</span>
</span><span id="1-3491">        <span class="c1"># AttributeError happens if the object has __slots__ or a</span>
</span><span id="1-3492">        <span class="c1"># read-only property, TypeError if it&#39;s a builtin class.</span>
</span><span id="1-3493">        <span class="k">pass</span>
</span><span id="1-3494">    <span class="k">return</span> <span class="n">method</span>
</span></pre></div>
        </article>
        
        <div class="navigation flex print:hidden">
  
  
</div>
        
      </div>
    </div>
  </main>
</div>
<footer class="sy-foot">
  <div class="sy-foot-inner sy-container mx-auto">
    
    <div class="sy-foot-reserved md:flex justify-between items-center">
      <div class="sy-foot-copyright"><p>2023, Jacob Coffee</p>
        
        <p>
          Made with
          
          <a href="https://www.sphinx-doc.org/">Sphinx</a> and
          
          <a href="https://shibuya.lepture.com">Shibuya theme</a>.
        </p>
      </div>
      <div class="sy-foot-socials">
          <a href="https://github.com/JacobCoffee/byte-bot" aria-label="GitHub"><i class="i-icon github"></i></a>
          <a href="https://twitter.com/_scriptr" aria-label="X (Twitter)"><i class="i-icon x-twitter"></i></a>
          <a href="https://discord.gg/ZVG8hN6RrJ/" aria-label="Discord"><i class="i-icon discord"></i></a>
          <a href="https://youtube.com/@monorepo" aria-label="YouTube"><i class="i-icon youtube"></i></a>
      </div>
    </div>
  </div>
</footer></div>
      <script src="../_static/documentation_options.js?v=8dde47fa"></script>
      <script src="../_static/doctools.js?v=9a2dae69"></script>
      <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script src="../_static/clipboard.min.js?v=a7894cd8"></script>
      <script src="../_static/copybutton.js?v=f281be69"></script>
      <script src="../_static/design-tabs.js?v=f930bc37"></script>
      <script src="../_static/shibuya.js?v=3e5c8598"></script>
      <script type="module" src="https://cdn.jsdelivr.net/npm/mermaid@11.2.0/dist/mermaid.esm.min.mjs"></script>
      <script type="module" src="https://cdn.jsdelivr.net/npm/@mermaid-js/layout-elk@0.1.4/dist/mermaid-layout-elk.esm.min.mjs"></script>
      <script type="module">import mermaid from "https://cdn.jsdelivr.net/npm/mermaid@11.2.0/dist/mermaid.esm.min.mjs";import elkLayouts from "https://cdn.jsdelivr.net/npm/@mermaid-js/layout-elk@0.1.4/dist/mermaid-layout-elk.esm.min.mjs";mermaid.registerLayoutLoaders(elkLayouts);mermaid.initialize({startOnLoad:false});</script>
      <script src="https://cdn.jsdelivr.net/npm/d3@7.9.0/dist/d3.min.js"></script>
      <script type="module">
import mermaid from "https://cdn.jsdelivr.net/npm/mermaid@11.2.0/dist/mermaid.esm.min.mjs";
window.addEventListener("load", () => mermaid.run());
</script>
    
</body>
</html>